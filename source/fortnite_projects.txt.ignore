<LUMBERJACK HEROES TYCOON EXAMPLE>
--- <afk_area_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }

# See https://dev.epicgames.com/documentation/en-us/uefn/create-your-own-device-in-verse for how to create a verse device.


afk_area_device := class(creative_device):
    OnBegin<override>()<suspends>:void=
        Print("Afk Area Device still needs to be implemented")--- </afk_area_device.verse> ---

--- <custom_player_device.verse> ---

using { /Fortnite.com/UI }
using { /Verse.org/Colors }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors/NamedColors }
using { /UnrealEngine.com/Temporary/UI }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/SpatialMath }


custom_player := class<unique>():
    ##### INITIALIZE #####
    RefPlayer : player
    RefGameManager : game_manager_device
    RefResourceManager : resource_manager_device

    InitiatePlayer() : void =
        RefGameManager.TestButton.InteractedWithEvent.Subscribe(TestButtonFunction)
        InitiateUI()

    ##### VARIABLES #####
    var Damage<private> : float = 1.0
    var Strength<private> : float = 1.0
        
    var ResourceAmount<private> : float = 500000000.0
    # var ResourceAmount2 : float = 0.0

    var UnlockedAreas<public> : []int = array{}

    ##### FUNCTIONS #####
    TestButtonFunction<private>(Agent : agent) : void =
        set Damage *= 1.7
        Print("Damage: {Damage}")
        ResourcePopup(50.0)
        OpenResourceHealthBar(resource_health_bar_information{MaxHealth := 5000.0, Health := 2750.0, OldHealth := 4500.0})

    PrimarySignal<public>(Agent : agent) : void =
        Print("Primary Signal Event fired")
        OpenUpgradeMenu()

    SecondarySignal<public>(Agent : agent) : void =
        block:


    #####################################   #####################################  #####################################   #####################################   #####################################
    #####################################   #####################################  #####################################   #####################################   #####################################
    #####################################   #####################################  #####################################   #####################################   #####################################

    #####################################
    #                 UI                #
    #####################################
    var Canvas<private> : canvas = canvas{}

    PrimaryResourceOverlay<private> : overlay = overlay{}


    PrimaryRessourceBackgroundTextureBlock<private> : texture_block = texture_block:
        DefaultImage := VerseAssets.ResourceBar
        DefaultDesiredSize := vector2{X:= 960.000000, Y:= 250.000000}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    PrimaryRessourceIconTextureBlock<private> : texture_block = texture_block:
        DefaultImage := VerseAssets.IconToiletPaper1
        DefaultDesiredSize := vector2{X:= 44.000000, Y:= 44.000000}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    PrimaryRessourceTextBlock<private> : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=2.0, Y:=2.0}
        DefaultShadowOpacity := 0.5
        DefaultShadowColor := NamedColors.Black


    InitiateUI<private>() : void =
        PrimaryRessourceTextBlock.SetText(AmountToMessage(ResourceAmount))

        PrimaryResourceOverlaySlots : []overlay_slot = array:
            overlay_slot:
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Fill
                Padding := margin{ Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                Widget := PrimaryRessourceBackgroundTextureBlock
            overlay_slot:
                HorizontalAlignment := horizontal_alignment.Left
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{ Left := 10.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                Widget := PrimaryRessourceIconTextureBlock
            overlay_slot:
                HorizontalAlignment := horizontal_alignment.Left
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{ Left := 78.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                Widget := PrimaryRessourceTextBlock

        for (PrimaryResourceOverlaySlot : PrimaryResourceOverlaySlots):
            PrimaryResourceOverlay.AddWidget(PrimaryResourceOverlaySlot)

        MyCanvas : canvas = canvas:
            Slots := array:
                canvas_slot:
                    Anchors := anchors{Minimum := vector2{X := 0.0, Y := 0.8}, Maximum := vector2{X := 0.0, Y := 0.8}}
                    Offsets := margin{Left := 10.000000, Top := -155.000000, Right := 250.000000, Bottom := 60.000000}
                    Alignment := vector2{X := 0.0, Y := 0.5}
                    SizeToContent := false
                    ZOrder := 0
                    Widget := PrimaryResourceOverlay
        set Canvas = MyCanvas
        
    

        if (PlayerUI := GetPlayerUI[RefPlayer]):
            Print("Adding Widget to PlayerUI")
            PlayerUI.AddWidget(Canvas)
            InitiateRessourcePopup()
            InitiateRessourceHealthBar()
            InitiateUpgradeMenu()

            
    UpdateUI<public>() : void =
        block:
        # RessourceAmountTextBlock.SetText(AmountToMessage(0.0))
        
    ########################################
    #             UPGRADE MENU             #
    ########################################
    var UpgradeMenu<private> : upgrade_menu_wrapper = upgrade_menu_wrapper{}

    InitiateUpgradeMenu<private>() : void =
        UpgradeMenu.Initiate(RefGameManager)

    OpenUpgradeMenu<public>() : void = 
        UpgradeMenu.Open(Self)

    # UpdateUiOnUpgradeSlotUnlocked()<suspends> : void = 
    #     loop:
    #         UpgradeMenu.UnlockedUpgradeSlotEvent.Await()
    #         if (UpgradeMenu.IsOpen?). UpgradeMenu.Update(Self)

    ########################################
    #          RESOURCE HEALTH BAR         #
    ########################################
    var ResourceHealthBar<public> : resource_health_bar_wrapper = resource_health_bar_wrapper{} 
    RessourceHealthBarLength<private> : float = 2.0
    
    InitiateRessourceHealthBar<private>() : void =
        ResourceHealthBar.Initiate(Canvas, RessourceHealthBarLength)

    OpenResourceHealthBar<public>(ResourceHealthBarInformation : resource_health_bar_information) : void =
        ResourceHealthBar.Popup(ResourceHealthBarInformation)

    ###################################
    #          RESOURCE POPUP         #
    ###################################
    RessourcePopupLength<private> : float = 2.5 # 2.4
    var WidgetPosition<private> : vector2 = vector2{X:=0.0, Y:=70.0}
    var PopupHeight<private> : float = -50.0
    
    var FixedRessourcePopup<public> : fixed_ressource_popup_wrapper = fixed_ressource_popup_wrapper{}
    var CurrentDynamicResourcePopupZOrder<public> : int = 2
    DynamicResourcePopups<public> : []dynamic_ressource_popup_wrapper = array:
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{},
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{},
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{},
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{},
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}

    InitiateRessourcePopup<private>() : void =
        set FixedRessourcePopup = fixed_ressource_popup_wrapper{
            Canvas := Canvas
            Position := WidgetPosition + vector2{}
            PopupLength := RessourcePopupLength 
        }; FixedRessourcePopup.Initiate()

        for (Index->DynamicResourePopup : DynamicResourcePopups):
            DynamicResourePopup.Initiate(RefPlayer, WidgetPosition + vector2{X:=0.0, Y:=PopupHeight})

    ResourcePopup<private>(Amount : float) : void =
        FixedRessourcePopup.Popup(Amount)

        var FoundPopup : logic = false
        for (Index->DynamicResourePopup : DynamicResourcePopups, not DynamicResourePopup.IsOpen?, not FoundPopup?):
            DynamicResourePopup.Popup(CurrentDynamicResourcePopupZOrder, Amount)
            set CurrentDynamicResourcePopupZOrder += 1
            set FoundPopup = true

    #####################################   #####################################  #####################################   #####################################   #####################################
    #####################################   #####################################  #####################################   #####################################   #####################################
    #####################################   #####################################  #####################################   #####################################   #####################################







    
    #####################################   #####################################  #####################################   #####################################   #####################################
    #####################################   #####################################  #####################################   #####################################   #####################################
    #####################################   #####################################  #####################################   #####################################   #####################################

    ###################################
    #            FUNCTIONS            #
    ###################################

    Collect<public>(Amount : float, ResourceType : resource_type) : void =
        if (ResourceType = resource_type.ToiletPaper):
            set ResourceAmount = ResourceAmount + Amount
            PrimaryRessourceTextBlock.SetText(AmountToMessage(ResourceAmount))
            ResourcePopup(Amount)
        else if (ResourceType = resource_type.Shit):
            block:
    
            if (UpgradeMenu.IsOpen?). UpgradeMenu.Update(Self)

    GetResourceAmount()<transacts> : float = 
        return ResourceAmount

    HasResource(Amount : float, ResourceType : resource_type)<transacts><decides> : decides_result =
        var DecidesResult : ?decides_result = false
        if (ResourceType = resource_type.ToiletPaper, ResourceAmount >= Amount):
            set DecidesResult = option. decides_result{Value:=true}
        else:
            PrintError("Not enough Resources") 
        return DecidesResult?

    SpendResource(Amount : float, ResourceType : resource_type) : void = 
        if (ResourceType = resource_type.ToiletPaper, ResourceAmount >= Amount):
            set ResourceAmount = ResourceAmount - Amount
            PrimaryRessourceTextBlock.SetText(AmountToMessage(ResourceAmount))
        if (UpgradeMenu.IsOpen?). UpgradeMenu.Update(Self)

    AddStrength(Amount : float) : void =
        set Strength += Amount
        if (UpgradeMenu.IsOpen?). UpgradeMenu.Update(Self)


    GetStrength()<transacts> : float = 
        return Strength

            
    UnlockArea(AreaId : int) : void = 
        set UnlockedAreas = UnlockedAreas + array{AreaId}
        Print("Area id: {AreaId}")
        if (ResourceArea := RefResourceManager.ResourceAreas[AreaId]):
            ResourceArea.EntryBarrier.AddToIgnoreList(RefPlayer)
            Print("Unlocked area")
            



custom_player_device := class(creative_device):
    
    @editable GameManager : game_manager_device = game_manager_device{}
    @editable ResourceManager : resource_manager_device = resource_manager_device{}
    @editable StartGameItemGranter : item_granter_device = item_granter_device{}
    @editable RemoteSignalManager : signal_remote_manager_device = signal_remote_manager_device{}
    @editable StartGameMapIndicator : map_indicator_device = map_indicator_device{}

    OnBegin<override>()<suspends>:void=
        Print("[+] Started Custom Player Manager")
        spawn. HandleCustomPlayer()
        spawn. HandleCustomPlayerFast()
        for(Spawner : GameManager.PlayerSpawners):     
            Spawner.SpawnedEvent.Subscribe(InitiatePlayer)
    
    InitiatePlayer(Agent:agent): void=
        StartGameItemGranter.GrantItem(Agent)
        if(Player := player[Agent]):
            spawn { InstantiateCustomPlayer(Player) }

    InstantiateCustomPlayer(Player : player)<suspends> : void =
        loop:
            Sleep(0.1)
            if(PlayerExists := GameManager.CustomPlayerMap[Player]):
                Print("Already existing Custom Player")
                break
            else:
                Print("Created Custom Player")
                CustomPlayer := custom_player{RefPlayer := Player, RefGameManager:=GameManager, RefResourceManager:=ResourceManager}
                set GameManager.CustomPlayerArray += array{CustomPlayer}
                if (set GameManager.CustomPlayerMap[Player] = CustomPlayer) { Print("Added Player to PlayerMap") }
                
                RemoteSignalManager.PrimarySignalEvent.Subscribe(CustomPlayer.PrimarySignal)
                for (I := 0..20). StartGameMapIndicator.ActivateObjectivePulse(Player)

                if (CheckCustomPlayer := GameManager.CustomPlayerMap[Player]):
                    Print("Initializing UI for player")
                    CustomPlayer.InitiatePlayer() #Initiates the Players UI


    HandleCustomPlayer()<suspends> : void = 
        FrameTime := 0.1
        loop:
            for (CustomPlayer : GameManager.CustomPlayerArray):
                set CustomPlayer.FixedRessourcePopup.CurrentTimer -= FrameTime
                if:
                    CustomPlayer.FixedRessourcePopup.CurrentTimer <= 0.0
                    CustomPlayer.FixedRessourcePopup.IsOpen?
                then:
                    if (Debug?). Print("Closed Resource Popup")
                    set CustomPlayer.CurrentDynamicResourcePopupZOrder = 2
                    CustomPlayer.FixedRessourcePopup.Close()

                set CustomPlayer.ResourceHealthBar.CurrentTimer -= FrameTime
                if:
                    CustomPlayer.ResourceHealthBar.CurrentTimer <= 0.0
                    CustomPlayer.ResourceHealthBar.IsOpen?
                then:
                    if (Debug?). Print("Closed Resource Health Bar")
                    CustomPlayer.ResourceHealthBar.Close()
            Sleep(FrameTime)

    HandleCustomPlayerFast()<suspends> : void = 
        FrameTime := 0.0
        loop:
            for (CustomPlayer : GameManager.CustomPlayerArray):
                var AtLeastOneDynamicResourcePopIsOpen : logic = false
                for (DynamicResourcePopup : CustomPlayer.DynamicResourcePopups, DynamicResourcePopup.IsOpen?):
                    set AtLeastOneDynamicResourcePopIsOpen = true
                    DynamicResourcePopup.Move()
                # if (not AtLeastOneDynamicResourcePopIsOpen? and CustomPlayer.CurrentDynamicResourcePopupZOrder <> 2):
                #     set CustomPlayer.CurrentDynamicResourcePopupZOrder = 2

                if: 
                    CustomPlayer.ResourceHealthBar.IsOpen?
                then:
                    CustomPlayer.ResourceHealthBar.ApproachTargetHealth(0.2, ?Minimum := 0.005)
            Sleep(FrameTime)--- </custom_player_device.verse> ---

--- <game_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Fortnite.com/Characters }
using { /UnrealEngine.com/Temporary/UI }
using { /Verse.org/Assets}
using { /Fortnite.com/UI }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /Verse.org/Colors/NamedColors }
using { /Verse.org/Random }
using { /Verse.org/Colors }

Debug : logic = false
TickRate : int = 20
NormalScale : vector3 = vector3{X:=1.0, Y:=1.0, Z:=1.0}
OutOfBounds : vector3 = vector3{X:=0.0, Y:=0.0, Z:=-1024.0}
Gravity : float = 981.0
StrengthUpgradeFactor : float = 1.2535

Assets := module:
    UI<public> := module:
        UpgradeMenu<public> := module{}
        ResourcePopup<public> := module{}
        ResourceBar<public> := module{}
        AreaPreviewImages<public> := module{}

decides_result := class():
    Value : logic

game_manager_device := class(creative_device):
    @editable PlayerSpawners : []player_spawner_device = array{}
    @editable MusicPlayerDevice : audio_player_device = audio_player_device{}
    @editable MusicPlayerSwitch : switch_device = switch_device{}

    @editable TestButton : button_device = button_device{}

    var CustomPlayerMap : [player]custom_player = map{}
    var CustomPlayerArray : []custom_player = array{}

    OnBegin<override>()<suspends> : void =
        MusicPlayerSwitch.TurnedOnEvent.Subscribe(TurnOnMusic) 
        MusicPlayerSwitch.TurnedOffEvent.Subscribe(TurnOffMusic) 

    PrintCustomPlayers() : void = 
        Print("Printing Custom Players")
        for (I->CustomPlayer : CustomPlayerArray):
            Print("{I}. CustomPlayer: ")


    TurnOnMusic(Agent : agent) : void = 
        MusicPlayerDevice.Register(Agent)
        MusicPlayerDevice.Play(Agent)

    TurnOffMusic(Agent : agent) : void = 
        MusicPlayerDevice.Unregister(Agent)
        MusicPlayerDevice.Stop(Agent)

    GetCustomPlayer<public>(Agent : agent)<decides><transacts> : custom_player =
        var MaybeCustomPlayer : ?custom_player = false
        if (Player : player = player[Agent], CustomPlayer : custom_player = CustomPlayerMap[Player]):
            set MaybeCustomPlayer = option{CustomPlayer}        
        else:
            Print("[!] Could not return custom player")
        return MaybeCustomPlayer?

    GetMaybeCustomPlayer<public>(Agent : agent)<transacts> : ?custom_player =
        var MaybeCustomPlayer : ?custom_player = false
        if (Player := player[Agent], CustomPlayer : custom_player = CustomPlayerMap[Player]):
            set MaybeCustomPlayer = option{CustomPlayer}        
        else:
            Print("[!] Could not return custom player")
        return MaybeCustomPlayer


    UpdateUI() : void =
        for (Player : GetPlayspace().GetPlayers(), CustomPlayer := CustomPlayerMap[Player]):
            CustomPlayer.UpdateUI()
            


#####################################
#           CUSTOM METHODS          #
#####################################
SpawnParticleSystem(CreativePropAsset : creative_prop_asset, Position : vector3, ?Delay : float = 3.0) : void = 
    SpawnPropResult := SpawnProp(CreativePropAsset, Position, rotation{})
    if (ParticleSystem := SpawnPropResult(0)?):
        if (Debug?). Print("Disposing Particle System in {Delay} Seconds")
        spawn. DisposeParticleSystem(ParticleSystem, ?Delay := Delay)

DisposeParticleSystem(ParticleSystem : creative_prop, ?Delay : float = 3.0)<suspends> : void = 
    Sleep(Delay)
    ParticleSystem.Dispose() 

            
###################################
#          GLOBAL METHODS         #
###################################
Modular<public>(Number: int, Modulator : int)<transacts> : int = 
    if (Div := Number / Modulator):
        return Number - Floor(Div)*Modulator
    return Number 

(Input: string).Split(Delimeter: string)<transacts>: []string =

    if. Delimeter.Length = 0 then. return for. Char : Input do. ToString(Char)
    
    var Result: []string = array{}
    var Start: int = 0
    var End: int = 0
    
    if. Input.Length > 0 then. loop:
        if:
            InputSlice := Input.Slice[End, End + Delimeter.Length]
            InputSlice = Delimeter
            ResultSlice := Input.Slice[Start, End]
        then:
            set Result += array{ResultSlice}
            set End += Delimeter.Length - 1
            set Start = End + 1
    
        set End += 1
    
        if. End = Input.Length then. break
    
    if:
        Start <= Input.Length - 1
        RemainingSlice := Input.Slice[Start]
    then. set Result += array{RemainingSlice}
    
    return Result

# Abs(X : float)<transacts> : float = 
#     if (X > 0.0): 
#         return X
#     else:
#         return -X
        
#####################################
#          PRINT METHODS         #
#####################################
PrintLine(?MiddleString : string = "", ?Duration:float = 2.0)<transacts>:void =
    String : string = "=================================================="
    if (MiddleString.Length = 0):
        Print("==================================================", ?Duration := Duration)
    else:
        var NewString : string = ""
        if (HalfCharacters := Floor[((50-MiddleString.Length-1)*1.0)/2.0]):
            for (X:=0..HalfCharacters). set NewString += "="
            set NewString += " {MiddleString} "
            for (X:=0..HalfCharacters). set NewString += "="
            Print(NewString, ?Duration := Duration)

PrintError(Msg:string, ?Duration:float = 2.0)<transacts>:void =
    Print("[ERROR] {Msg}", ?Color := NamedColors.Red, ?Duration := Duration)

PrintSuccess(Msg:string, ?Duration:float = 2.0)<transacts>:void =
    Print("[SUCCESS] {Msg}", ?Color := NamedColors.Green, ?Duration := Duration)
    
PrintStart(Msg:string, ?Duration:float = 2.0)<transacts>:void =
    Print("[START] {Msg}", ?Color := NamedColors.GreenYellow, ?Duration := Duration)

PrintInfo(Msg:string, ?Duration:float = 2.0)<transacts>:void =
    Print("[INFO] {Msg}", ?Color := NamedColors.Blue, ?Duration := Duration)

PrintEnd(Msg:string, ?Duration:float = 3.0)<transacts>:void =
    Print("[START] {Msg}", ?Color := NamedColors.GreenYellow, ?Duration := Duration)

#####################################
#          LOCALIZE METHODS         #
#####################################

StringToMessage<localizes>(String:string) : message = "{String}"

IntToMessage<localizes>(Integer:int) : message = "{Integer}"

FloatToMessage<localizes>(Float:float) : message = "{Float}"
FloatToMessageFloor(Float:float) : message = 
    if (FloorValue := Floor[Float]):
        return IntToMessage(FloorValue)
    return FloatToMessage(Float)

FloatToMessageRounded(Float:float) : message = 
    if (RoundedValue := Floor[Float]):
        return IntToMessage(RoundedValue)
    return FloatToMessage(Float)

FloatToPercentMessage(Float : float) : message = 
    if (RoundedValue := Round[Float]):
        return StringToMessage("{RoundedValue}%")
    return StringToMessage("{Float}%")

PlayerNameToMessage<localizes>(Agent:agent)<transacts> : message = "{Agent}"
PlayerName(Agent : agent) : string = PlayerNameToString(Agent)
PlayerNameToString(Agent : agent) : string = 
    Message : message = PlayerNameToMessage(Agent)
    RetString := Localize(Message)
    return RetString


GetFraction<public>(Number : float, ?DecimalPlaces : float = 2.0)<transacts> : int = 
    if:
        Sub := Floor[Number]*1.0
        Fraction := Number-Sub * Pow(10.0, DecimalPlaces)
        Result := Round[Fraction]
    then:
        return Result
    return 0

amount_to_suffix_wrapper := class:
    Amount : float = 0.0
    Suffix : string = ""

Repeat(Character : string, RepeatAmount : int)<transacts> : string = 
    var ReturnString : string = Character
    for (I := 0..RepeatAmount):
        set ReturnString += Character
    return ReturnString


AmountToString(Amount : float)<transacts> : string  =
    if (Amount < 100.0, IntValue := Floor[Amount]):
        return ToString(IntValue)
        
    Tuples : []amount_to_suffix_wrapper = array:
        amount_to_suffix_wrapper{Amount := 1000000000000.0, Suffix := "T"},
        amount_to_suffix_wrapper{Amount := 1000000000.0, Suffix := "B"},
        amount_to_suffix_wrapper{Amount := 1000000.0, Suffix := "M"},
        amount_to_suffix_wrapper{Amount := 1000.0, Suffix := "K"},
        amount_to_suffix_wrapper{Amount := 1.0, Suffix := ""}
    var Divisor : float = 1.0
    var Suffix : string = ""
    var Break : logic = false
    for (I := 0..Tuples.Length, not Break?):
        if: 
            T := Tuples[I]
            Amount >= T.Amount
        then:
            set Divisor = T.Amount
            set Suffix = T.Suffix
            set Break = true
    ScaledValue := Amount / Divisor
    var SlicePoint : int = 4
    if (ScaledValue >= 100.0):
        set SlicePoint = 3
    var StringValue : string = ToString(ScaledValue)
    # Print("StringValue: " + StringValue)
    # Print("SlicePoint: {SlicePoint}")
    if (CutValue := StringValue.Slice[0, SlicePoint]):
        return CutValue + Suffix
    return StringValue + Suffix
    

AmountToMessage(Amount: float) : message =
    String := AmountToString(Amount)
    return StringToMessage(String)
    # Tuples : []amount_to_suffix_wrapper = array:
    #     amount_to_suffix_wrapper{Amount := 1000000000000.0, Suffix := "T"},
    #     amount_to_suffix_wrapper{Amount := 1000000000.0, Suffix := "B"},
    #     amount_to_suffix_wrapper{Amount := 1000000.0, Suffix := "M"},
    #     amount_to_suffix_wrapper{Amount := 1000.0, Suffix := "K"},
    #     amount_to_suffix_wrapper{Amount := 1.0, Suffix := ""}
    # var Divisor : float = 1.0
    # var Suffix : string = ""
    # var Break : logic = false
    # for (I := 0..Tuples.Length, not Break?):
    #     if: 
    #         T := Tuples[I]
    #         InAmount >= T.Amount
    #     then:
    #         set Divisor = T.Amount
    #         set Suffix = T.Suffix
    #         set Break = true
    # ScaledValue := InAmount / Divisor
    # var SlicePoint : int = 4
    # if (ScaledValue >= 100.0):
    #     set SlicePoint = 3
    # var StringValue : string = ToString(ScaledValue)
    # # Print("StringValue: " + StringValue)
    # # Print("SlicePoint: {SlicePoint}")
    # if (CutValue := StringValue.Slice[0, SlicePoint]):
    #     # Print("CutValue: " + CutValue)
    #     return StringToMessage(CutValue + Suffix)
    # return StringToMessage(StringValue + Suffix)





HealthToMessage(Health: float, MaxHealth : float) : message =
    Tuples : []amount_to_suffix_wrapper = array:
        amount_to_suffix_wrapper{Amount := 1000000000000.0, Suffix := "T"},
        amount_to_suffix_wrapper{Amount := 1000000000.0, Suffix := "B"},
        amount_to_suffix_wrapper{Amount := 1000000.0, Suffix := "M"},
        amount_to_suffix_wrapper{Amount := 1000.0, Suffix := "K"},
        amount_to_suffix_wrapper{Amount := 1.0, Suffix := ""}
    var Divisor1 : float = 1.0
    var Suffix1 : string = ""
    var Break : logic = false
    for (I := 0..Tuples.Length, not Break?):
        if: 
            T := Tuples[I]
            Health >= T.Amount
        then:
            set Divisor1 = T.Amount
            set Suffix1 = T.Suffix
            set Break = true
    var Divisor2 : float = 1.0
    var Suffix2 : string = ""
    set Break = false
    for (I := 0..Tuples.Length, not Break?):
        if: 
            T := Tuples[I]
            MaxHealth >= T.Amount
        then:
            set Divisor2 = T.Amount
            set Suffix2 = T.Suffix
            set Break = true
    var ScaledValue1 : float = Health / Divisor1    
    var ScaledValue2 : float = MaxHealth / Divisor2  
    if (F := Floor[Health / Divisor1 * 100.0]):
        set ScaledValue1 = F*0.01
    if (F := Floor[MaxHealth / Divisor2 * 100.0]):
        set ScaledValue2 = F*0.01
    # Print("ScaledValue1: {ScaledValue1}")
    # Print("ScaledValue2: {ScaledValue2}")
    var SlicePoint1 : int = 4
    if (ScaledValue1 >= 100.0):
        set SlicePoint1 = 3
    var StringValue1 : string = ToString(ScaledValue1*1.0)
    var SlicePoint2 : int = 4
    if (ScaledValue2 >= 100.0):
        set SlicePoint2 = 3
    var StringValue2 : string = ToString(ScaledValue2*1.0)
    # Print("StringValue: " + StringValue1)
    # Print("StringValue2: " + StringValue2)
    # Print("SlicePoint1: {SlicePoint1}")
    # Print("SlicePoint2: {SlicePoint2}")
    if:
        CutValue1 := StringValue1.Slice[0, SlicePoint1]
        CutValue2 := StringValue2.Slice[0, SlicePoint2]
    then:
        return StringToMessage(CutValue1 + Suffix1 + " / " + CutValue2 + Suffix2)
    return StringToMessage("{Health} / {MaxHealth}")
    

FillNumberTo3Digits(Value : float)<transacts> : string = 
    var ReturnString : string = ""
    if (Value >= 100.0):
        if (IntValue := Floor[Value]). set ReturnString = "{IntValue}"
    else if (Value >= 10.0):
        if (IntValue := Floor[Value], DecimalValue := Value). set ReturnString = "{IntValue}.0"
    else:
        if (IntValue := Floor[Value]). set ReturnString = "{IntValue}.00"
    return ReturnString
--- </game_manager_device.verse> ---

--- <quest_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }

increase_event_data := struct:
    Agent : agent
    Value : int

completed_event_wrapper := class():
    Index : int
    QuestWrappers : []quest_wrapper
    
    HandleCompleteEvent(Agent : agent) : void =
        spawn . HandleCompleteEventSuspends(Agent)

    HandleCompleteEventSuspends(Agent : agent)<suspends> : void =
        var QuestWrapperIndex : int = 0
        var NextQuestIsNewQuest : logic = false 
        
        if(QuestWrapper := QuestWrappers[Index+1]):
            Sleep(1.5)
            QuestWrapper.Tracker.Assign(Agent)
            for(X := 0..20):
                QuestWrapper.MapIndicator.ActivateObjectivePulse(Agent)
 

quest_wrapper := class():
    @editable Tracker : tracker_device
    @editable MapIndicator : map_indicator_device
    var IncreaseEvent : event(increase_event_data) = event(increase_event_data){}
    var ActivatedPlayers : []agent = array{}

    CheckIncreaseEvent()<suspends> : void =
        loop:
            IncreaseEventData := IncreaseEvent.Await()
            if (Tracker.IsActive[IncreaseEventData.Agent]):
                Tracker.SetValue(IncreaseEventData.Agent, Tracker.GetValue() + IncreaseEventData.Value)


quest_manager_device := class(creative_device):

    @editable GameManager : game_manager_device = game_manager_device{}
    @editable ResourceManager : resource_manager_device = resource_manager_device{}

    @editable var QuestWrappers : []quest_wrapper = array{}


    # InitiatePlayer(Agent : agent) : void =
    #     if(FirstQuestWrapper := QuestWrappers[0]):
    #         set FirstQuestWrapper.ActivatedPlayers =  FirstQuestWrapper.ActivatedPlayers + array{Agent}

    OnBegin<override>()<suspends>:void=
        if(QuestWrapper := QuestWrappers[0]):
            set QuestWrapper.IncreaseEvent = ResourceManager.DamageEvent
        
        if(QuestWrapper := QuestWrappers[1]):
            set QuestWrapper.IncreaseEvent = ResourceManager.DamageEvent

        # for(Spawner : GameManager.PlayerSpawners):     
        #     Spawner.SpawnedEvent.Subscribe(InitiatePlayer)

        var QuestIndex : int = 0
        for (QuestWrapper : QuestWrappers):
            spawn. QuestWrapper.CheckIncreaseEvent()
            QuestWrapper.Tracker.CompleteEvent.Subscribe(completed_event_wrapper{Index:=QuestIndex, QuestWrappers:=QuestWrappers}.HandleCompleteEvent)
--- </quest_manager_device.verse> ---

--- <resource_manager_device.verse> ---

using { /Verse.org/Random }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Fortnite.com/Characters }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /Fortnite.com/Devices/CreativeAnimation }

ResourceRespawnTime : float = 10.0

resource_type := enum{
    None
    ToiletPaper
    Shit # ????? maybe cool
}

damage_animation := enum {
    None
    Bounce
    Shrink
} 

area_merchant_wrapper := class<unique>():

    @editable RefNPC<public> : character_device = character_device{}
    @editable WelcomeSequence : gameplay_camera_fixed_point_device = gameplay_camera_fixed_point_device{}
    var RefGameManager : game_manager_device = game_manager_device{}
    var Cost : float = 0.0
    var Level : int = 0

    var ShopUIWrapper : merchant_menu_wrapper = merchant_menu_wrapper{}
    BoughtAreaEvent : event(agent) = event(agent){}

    Initialize() : void =
        RefNPC.InteractedWithEvent.Subscribe(OpenShopUI)
        ShopUIWrapper.Initialize()

        spawn . HandleCloseEvent()
        spawn . HandleBuyEvent()
    
    OpenShopUI(Agent : agent) : void =
        spawn . OpenShopUISuspends(Agent)

    HandleBuyEvent()<suspends> : void =
        loop:
            Sleep(0.1)
            AgentInstigator : agent = ShopUIWrapper.BoughtUIEvent.Await()
            if(CustomPlayer := RefGameManager.GetCustomPlayer[AgentInstigator]):
                CustomPlayer.SpendResource(Cost, resource_type.ToiletPaper)
                CustomPlayer.UnlockArea(Level)
                ShopUIWrapper.ClosedUIEvent.Signal(AgentInstigator)
                Print("Wanted to buy area")

    HandleCloseEvent()<suspends> : void =
        loop:
            Sleep(0.1)
            AgentInstigator : agent = ShopUIWrapper.ClosedUIEvent.Await()
            WelcomeSequence.RemoveFrom(AgentInstigator)
        
    OpenShopUISuspends(Agent : agent)<suspends> : void = 
        if(CustomPlayer := RefGameManager.GetCustomPlayer[Agent]):
            WelcomeSequence.AddTo(Agent)
            # WelcomeSequence.TogglePause(Agent)
            Sleep(0.7)
            RefNPC.PlayEmote()
            Sleep(1.0)
            ShopUIWrapper.Open(Agent, CustomPlayer)


resource_area_wrapper := class<concrete>():
    var RefResourceManager : resource_manager_device = resource_manager_device{}
    var RefGameManager : game_manager_device = game_manager_device{}

    @editable var MerchantWrapper : area_merchant_wrapper = area_merchant_wrapper{}

    @editable Name : string = ""
    @editable Bonus : float = 0.0
    @editable Level : int = 0
    @editable Cost : int = 0

    @editable EntryBarrier : barrier_device = barrier_device{}

    @editable ResourceNames : ?string = false
    @editable ResourceHealth : ?float = false
    @editable ResourceNiagara : ?creative_prop_asset = false

    @editable SimpleResourceProps : []simple_resource_prop_wrapper = array{}
    @editable AdvancedResourceProps : []resource_prop_wrapper = array{}

    Initialize(ResourceManager : resource_manager_device, GameManager : game_manager_device) : void =
        set RefResourceManager = ResourceManager
        set RefGameManager = GameManager

        MerchantShopUIWrapper := merchant_menu_wrapper{AreaTitle:=Name, Cost:=Cost, GatherMultiplier:=Bonus}
        set MerchantWrapper.RefGameManager = RefGameManager 
        set MerchantWrapper.ShopUIWrapper = MerchantShopUIWrapper
        set MerchantWrapper.Level = Level

        var ActualResourceName : string = ""
        var ActualResourceHealth : float = 0.0
        var ActualResourceNiagara : creative_prop_asset = DefaultCreativePropAsset

        if (ResourceName := ResourceNames?):
            set ActualResourceName = ResourceName
        if (cResourceHealth := ResourceHealth?):
            set ActualResourceHealth = cResourceHealth
        if (cResourceNiagara := ResourceNiagara?):
            set ActualResourceNiagara = cResourceNiagara
        
        for (ResourceProp : SimpleResourceProps):
            ResourceProp.Initialize(
                ResourceManager.ResourceWrapperIds,
                RefResourceManager, 
                RefGameManager,
                ActualResourceName,
                ActualResourceHealth,
                Level,
                Bonus,
                ActualResourceNiagara
            ); ResourceManager.IncrementResourceWrapperId()

        for (ResourceProp : AdvancedResourceProps):
            ResourceProp.Initialize(ResourceManager.ResourceWrapperIds, RefResourceManager, RefGameManager)
            ResourceManager.IncrementResourceWrapperId()
        
        MerchantWrapper.Initialize()
        spawn . HandleBuyRequests()
    
    HandleBuyRequests()<suspends> : void =
        loop:
            Sleep(0.1)
            AgentInstigator : agent = MerchantWrapper.BoughtAreaEvent.Await()
            if(BuyingCustomPlayer := RefGameManager.GetCustomPlayer[AgentInstigator]):
                
                BuyingCustomPlayer.UnlockArea(Level)


simple_resource_prop_wrapper := class<concrete>():
    @editable CreativeProp<private> : creative_prop = creative_prop{}
    @editable PropManipulator<private> : prop_manipulator_device = prop_manipulator_device{}

    var ResourceProp<private> : resource_prop_wrapper = resource_prop_wrapper{}

    GetResourceProp<public>()<transacts> : resource_prop_wrapper =
        return ResourceProp

    var Initialized : logic = false
    Initialize<public>(
        Id : int,
        ResourceManager : resource_manager_device, 
        GameManager : game_manager_device,
        Name : string,
        Health : float,
        Level : int,
        Bonus : float,
        NiagaraSystem : creative_prop_asset
    ) : void = 
        if (Initialized?). return
        set Initialized = true
        set ResourceProp = resource_prop_wrapper:
            CreativeProp := CreativeProp
            PropManipulator := PropManipulator
            Name := Name
            Health := Health
            Level := Level
            Bonus := Bonus
            NiagaraSystem := NiagaraSystem
        ResourceProp.Initialize(Id, ResourceManager, GameManager)

resource_prop_wrapper := class<concrete>():
    var RefResourceManager : resource_manager_device = resource_manager_device{}
    var RefGameManager : game_manager_device = game_manager_device{}

    var Id : int = -1
    @editable CreativeProp : creative_prop = creative_prop{}
    @editable PropManipulator : prop_manipulator_device = prop_manipulator_device{}
    @editable NiagaraSystem : creative_prop_asset = DefaultCreativePropAsset

    @editable Name : string = ""
    @editable Level : int = 0
    @editable Bonus : float = 0.0

    @editable Health : float = 0.0
    # @editable RessourceAmount : float = 0.0
    # @editable RessourceType : ressource_type = ressource_type.Metal
    
    @editable DamageAnimation : damage_animation = damage_animation.Shrink

    @editable RespawnTime<private> : float = ResourceRespawnTime
    @editable Indestructible<private> : logic = false
    var RandomFactorUntilReset<private> : float = 0.5
    
    var IsPlayingAnimation<private> : logic = false
    var CurrentHealth<private> : float = 0.0
    var OriginalTransform<private> : transform = transform{}
    
    var LastHitTimestamp<private> : ?float = false
    var HealTime<private> : float = 15.0

    HitBounceMinScale<private> : float = 0.9
    HitBounceTime<private> : float = 0.17

    HitShrinkMinScale<private> : float = 0.667
    HitShrinkTime<private> : float = 0.17

    var Initialized : logic = false
    var IsHidden : logic = false

    ResourcePopupNiagaraSystemOffset<private> : vector3 = vector3{X:=0.0, Y:=0.0, Z:=80.0}

    Initialize(InId : int, ResourceManager : resource_manager_device, GameManager : game_manager_device) : void = 
        if (Initialized?). return
        set Initialized = true

        set Id = InId
        set RefResourceManager = ResourceManager
        set RefGameManager = GameManager
        set CurrentHealth = Health
        set OriginalTransform = CreativeProp.GetTransform()
        
        PropManipulator.DamagedEvent.Subscribe(Damage)

        if:
            AnimationController := CreativeProp.GetAnimationController[]
        then:
            AnimationController.MovementCompleteEvent.Subscribe(WaitForAnimationFinish)

    Damage(Agent : agent) : void = 
        if:
            CustomPlayer := RefGameManager.GetCustomPlayer[Agent]
        then:
            OldHealth := CurrentHealth 
            
            var TotalDamage : float = CustomPlayer.GetStrength()
            set CurrentHealth = Max(CurrentHealth - TotalDamage, 0.0)

            CustomPlayer.OpenResourceHealthBar(
                resource_health_bar_information{
                    ResourceWrapper := Self
                    MaxHealth := Health
                    Health := CurrentHealth
                    OldHealth := OldHealth
                    AreaBonus := Bonus
                    Level := Level
                    Name := Name
                }
            )
            
            RefResourceManager.DamageEvent.Signal(increase_event_data{Agent:= Agent, Value:=1})


            if:
                Indestructible?
                CurrentHealth < Health*RandomFactorUntilReset
            then:
                set RandomFactorUntilReset = GetRandomFloat(0.267, 0.789)
                set CurrentHealth = Health
            else:


            if:
                not Indestructible?
            then:
                if (GetRandomFloat(0.0, 1.0) < 0.333):
                    # implement for critical hit etc.
                    SpawnParticleSystem(RefResourceManager.ToiletPaperNiagaraSystem, OriginalTransform.Translation + ResourcePopupNiagaraSystemOffset * OriginalTransform.Scale.Z)


            if (CurrentHealth <= 0.0):
                set LastHitTimestamp = false
                if (DamageAnimation = damage_animation.Bounce). Bounce(HitBounceMinScale, HitBounceTime, ?ForceAnimation:=true)
                else if (DamageAnimation = damage_animation.Shrink). Shrink(HitBounceMinScale, HitShrinkTime)
                Destroy(Agent)
            else:
                set LastHitTimestamp = option. GetSecondsSinceEpoch()
                # if (DamageAnimation <> damage_animation.None):
                    
                if (DamageAnimation = damage_animation.Bounce). Bounce(HitBounceMinScale, HitBounceTime, ?ForceAnimation:=true)
                else if (DamageAnimation = damage_animation.Shrink). Shrink(HitBounceMinScale, HitShrinkTime)


            var TotalResourceAmount : float = CustomPlayer.GetStrength()
            CustomPlayer.Collect(TotalResourceAmount, resource_type.ToiletPaper)
        else:
            Print("Could not get Custom Player for {PlayerNameToString(Agent)}")

    Destroy(Agent : agent) : void =
        spawn. DestroySuspended()

    DestroySuspended()<suspends> : void =
        Sleep(HitShrinkTime)
        SpawnParticleSystem(NiagaraSystem, OriginalTransform.Translation)
        SpawnParticleSystem(RefResourceManager.RadialBurstNiagaraSystem, OriginalTransform.Translation)
        set LastHitTimestamp = false
        Hide()
        RespawnSuspended()

    Heal<public>() : void = 
        if (not LastHitTimestamp?). return
        if (Respawning?). return
        if (CurrentHealth = Health). return
        if (LastHit := LastHitTimestamp?):
            # Print("Time since last hit: {GetSecondsSinceEpoch() - LastHit}")  
        if (GetSecondsSinceEpoch() - LastHitTimestamp? > HealTime):
            # Print("Succesfully Healed Resource Prop")
            Reset()
            set CurrentHealth = Health
            set LastHitTimestamp = false


    var Respawning : logic = false
    RespawnSuspended()<suspends> : void =
        if (Respawning?). return
        set Respawning = true 
        Sleep(RespawnTime)
        if (not Respawning?). return # If this Asserts -> ResourceProp got Force Respawned by other Function
        Respawn()

    Respawn() : void = 
        if (IsHidden?). PropManipulator.ShowProps()
        set CurrentHealth = Health
        Reset()
        set Respawning = false

    Reset() : void =
        Scale(OriginalTransform.Scale, 1.0, ?InterpolationType := InterpolationTypes.Ease, ?ForceAnimation := true)
        if (CreativeProp.TeleportTo[OriginalTransform]) {}
        

        # OriginalScale := OriginalTransform.Scale
        # ScaleFactor := (CurrentHealth / Health) * (1.0-MinScale) + MinScale
        # NewScale := OriginalScale * ScaleFactor

        # Scale(NewScale, 0.17, ?InterpolationType := InterpolationTypes.Ease, ?ForceAnimation := true)


    Shrink<private>(MinScale : float, Time : float) : void = 
        # Print("Baka Scale: {CreativeProp.GetTransform().Scale}")
        HealthToScale := ((CurrentHealth / Health) * (1.0-MinScale) + MinScale)
        CalculatedScale := vector3{X:=HealthToScale, Y:=HealthToScale, Z:=HealthToScale}
        CurrentScale := (CreativeProp.GetTransform().Scale / OriginalTransform.Scale)

        ShrinkScale := vector3{X:=0.88, Y:=0.88, Z:=0.88}
        TargetScale := CalculatedScale / (CurrentScale * ShrinkScale)

        PropScale := CreativeProp.GetTransform().Scale

        # Print("ShrinkScale: {ShrinkScale}")
        # Print("Scale := {PropScale.X} -> {PropScale.X * ShrinkScale} -> wait -> {(PropScale.X * TargetScale)}")

        MovementKeyFrame: keyframe_delta = keyframe_delta {
            DeltaLocation := vector3{}
            DeltaRotation := rotation{}
            DeltaScale := ShrinkScale
            Time := Time
            Interpolation := InterpolationTypes.Ease
        }

        MovementKeyFrame2: keyframe_delta = keyframe_delta {
            DeltaLocation := vector3{}
            DeltaRotation := rotation{}
            DeltaScale := TargetScale
            Time := Time
            Interpolation := InterpolationTypes.Ease
        }

        if:
            AnimationController := CreativeProp.GetAnimationController[]
            AnimationState := AnimationController.GetState()
        then:
            if (AnimationState = animation_controller_state.Playing). AnimationController.Stop()
            FortVaderKeyFrames : []keyframe_delta = array{MovementKeyFrame, MovementKeyFrame2}
            AnimationController.SetAnimation(FortVaderKeyFrames, ?Mode:=animation_mode.OneShot)
            AnimationController.Play()
        else:
            PrintError("Creative Prop is already playing an Animation")









    Bounce<private>(MinScale : float, Time : float, ?InterpolationType : cubic_bezier_parameters = InterpolationTypes.Ease, ?ForceAnimation : logic = false) : void = 
        CurrentScale := CreativeProp.GetTransform().Scale / OriginalTransform.Scale # need to divide by currentscale to normalize
        var CalculatedScale : vector3 = vector3{X:=MinScale, Y:=MinScale, Z:=MinScale} / CurrentScale     


        MovementKeyFrame: keyframe_delta = keyframe_delta {
            DeltaLocation := vector3{}
            DeltaRotation := rotation{}
            DeltaScale := CalculatedScale
            Time := Time
            Interpolation := InterpolationType
        }

        set CalculatedScale = OriginalTransform.Scale / (vector3{X:=MinScale, Y:=MinScale, Z:=MinScale} * CreativeProp.GetTransform().Scale)

        MovementKeyFrame2: keyframe_delta = keyframe_delta {
            DeltaLocation := vector3{}
            DeltaRotation := rotation{}
            DeltaScale := CalculatedScale
            Time := Time
            Interpolation := InterpolationType
        }

        if:
            AnimationController := CreativeProp.GetAnimationController[]
            AnimationState := AnimationController.GetState()
            not AnimationState = animation_controller_state.Playing or ForceAnimation?
        then:
            if (ForceAnimation?). AnimationController.Stop()
            FortVaderKeyFrames : []keyframe_delta = array{MovementKeyFrame, MovementKeyFrame2}
            AnimationController.SetAnimation(FortVaderKeyFrames, ?Mode:=animation_mode.OneShot)
            AnimationController.Play()
        else:
            PrintError("Creative Prop is already playing an Animation")

    Scale<private>(NewScale : vector3, Time : float, ?InterpolationType : cubic_bezier_parameters = InterpolationTypes.Ease, ?ForceAnimation : logic = false) : void = 
        # set IsPlayingAnimation = true
        # if (IsPlayingAnimation?):
        #     PrintError("Creative Prop is already playing an Animation")
        #     return

        OldTransform := CreativeProp.GetTransform()
        var CalculatedScale : vector3 = NewScale / OldTransform.Scale                

        MovementKeyFrame: keyframe_delta = keyframe_delta {
            DeltaLocation := vector3{}
            DeltaRotation := rotation{}
            DeltaScale := CalculatedScale
            Time := Time
            Interpolation := InterpolationType
        }
        if:
            AnimationController := CreativeProp.GetAnimationController[]
            AnimationState := AnimationController.GetState()
            not AnimationState = animation_controller_state.Playing or ForceAnimation?
        then:
            if (ForceAnimation?). AnimationController.Stop()
            FortVaderKeyFrames : []keyframe_delta = array{MovementKeyFrame}
            AnimationController.SetAnimation(FortVaderKeyFrames, ?Mode:=animation_mode.OneShot)
            AnimationController.Play()
        else:
            PrintError("Creative Prop is already playing an Animation") 

    Animate<private>(Transform : transform, Time : float, ?InterpolationType : cubic_bezier_parameters = InterpolationTypes.Ease, ?ForceAnimation : logic = false) : void = 
        # set IsPlayingAnimation = true
        # if (IsPlayingAnimation?):
        #     PrintError("Creative Prop is already playing an Animation")
        #     return


        OldTransform := CreativeProp.GetTransform()
        MovementKeyFrame: keyframe_delta = keyframe_delta {
            DeltaLocation := Transform.Translation-OldTransform.Translation
            DeltaRotation := Transform.Rotation
            DeltaScale := Transform.Scale/OldTransform.Scale
            Time := Time
            Interpolation := InterpolationType
        }
        if:
            AnimationController := CreativeProp.GetAnimationController[]
            AnimationState := AnimationController.GetState()
            not AnimationState = animation_controller_state.Playing or ForceAnimation?
        then:
            if (ForceAnimation?):
                AnimationController.Stop()
            FortVaderKeyFrames : []keyframe_delta = array{MovementKeyFrame}
            AnimationController.SetAnimation(FortVaderKeyFrames, ?Mode:=animation_mode.OneShot)
            AnimationController.Play()
        else:
            PrintError("Creative Prop is already playing an Animation") 

    WaitForAnimationFinish<private>() : void = 
        set IsPlayingAnimation = false

    Hide<private>() : void = 
        if (CreativeProp.TeleportTo[OutOfBounds, rotation{}]) {}
        PropManipulator.HideProps()
        set IsHidden = true


       

resource_manager_device := class(creative_device):

    @editable GameManager : game_manager_device = game_manager_device{}
    @editable TestButton : button_device = button_device{}

    @editable RadialBurstNiagaraSystem : creative_prop_asset = DefaultCreativePropAsset
    @editable ToiletPaperNiagaraSystem : creative_prop_asset = DefaultCreativePropAsset

    var ResourceWrapperIds : int = 0
    @editable ResourceAreas : []resource_area_wrapper = array{}
    # @editable RessourceProps : []resource_prop_wrapper = array{}

    DamageEvent<public> : event(increase_event_data) = event(increase_event_data){}

    OnBegin<override>()<suspends> : void =
        TestButton.InteractedWithEvent.Subscribe(TestButtonFunction)
    
        for (ResourceArea : ResourceAreas): 
            ResourceArea.Initialize(Self, GameManager)
        spawn. HealDamagedResourceProps()


    IncrementResourceWrapperId() : void =
        set ResourceWrapperIds += 1

    TestButtonFunction(Agent : agent) : void = 
        block:


    HealDamagedResourceProps()<suspends> : void = 
        loop:
            Sleep(1.0)
            for (ResourceArea : ResourceAreas): 
                for (SimpleResourceProp : ResourceArea.SimpleResourceProps, ResourceProp := SimpleResourceProp.GetResourceProp()):
                    ResourceProp.Heal()
                for (ResourceProp : ResourceArea.AdvancedResourceProps):
                    ResourceProp.Heal()
    














    # PART OF DESTROY CODE FOR RESOURCE PROP
    # if:
    #     FortCharacter := Agent.GetFortCharacter[]
    # then:
    #     block:
    # 1.
    # (X=1280.000002,Y=112.000000,Z=1056.000000)
    # (Pitch=0.000000,Yaw=-89.999999,Roll=0.000000)
    # var Transform : transform = CreativeProp.GetTransform()

    # ForwardVector : vector3 = FortCharacter.GetTransform().Rotation.GetLocalForward() * 287.0

    # var NewTransform : transform = transform {
    #     Translation := Transform.Translation + ForwardVector * 0.8 + vector3{X:=0.0, Y:=0.0, Z:=80.0}
    #     Rotation := Transform.Rotation.ApplyPitch(DegreesToRadians(0.0)).ApplyYaw(DegreesToRadians(0.0)).ApplyRoll(DegreesToRadians(0.0))
    #     Scale := Transform.Scale
    # }

    # MovementKeyFrame1 : keyframe_delta = keyframe_delta {
    #     DeltaLocation := NewTransform.Translation-Transform.Translation
    #     DeltaRotation := MakeShortestRotationBetween(Transform.Rotation, NewTransform.Rotation)
    #     DeltaScale := NewTransform.Scale/Transform.Scale
    #     Time := 0.5
    #     Interpolation := InterpolationTypes.Linear
    # }

    # # 2.
    # # (X=1392.000003,Y=0.000001,Z=1120.000000)
    # # (Pitch=-43.271475,Yaw=-126.031298,Roll=5.383049)
    # set Transform = NewTransform
    # set NewTransform = transform{
    #     Translation := Transform.Translation + ForwardVector * 0.5 + vector3{X:=0.0, Y:=0.0, Z:=26.0}
    #     Rotation := Transform.Rotation.ApplyPitch(DegreesToRadians(0.0)).ApplyYaw(DegreesToRadians(0.0)).ApplyRoll(DegreesToRadians(0.0))
    #     Scale := Transform.Scale
    # }

    # MovementKeyFrame2 : keyframe_delta = keyframe_delta {
    #     DeltaLocation := NewTransform.Translation-Transform.Translation
    #     DeltaRotation := MakeShortestRotationBetween(Transform.Rotation, NewTransform.Rotation)
    #     DeltaScale := NewTransform.Scale/Transform.Scale
    #     Time := 0.5
    #     Interpolation := InterpolationTypes.Linear
    # }

    # # 3. 
    # # (X=1601.657752,Y=-80.680890,Z=1058.305414)
    # # (Pitch=-8.650000,Yaw=-249.140908,Roll=2.024718)
    # set Transform = NewTransform
    # set NewTransform = transform{
    #     Translation := Transform.Translation + ForwardVector * 0.35 + vector3{X:=0.0, Y:=0.0, Z:= -106.0}
    #     Rotation := Transform.Rotation.ApplyPitch(DegreesToRadians(0.0)).ApplyYaw(DegreesToRadians(0.0)).ApplyRoll(DegreesToRadians(0.0))
    #     Scale := Transform.Scale
    # }

    # MovementKeyFrame3 : keyframe_delta = keyframe_delta {
    #     DeltaLocation := NewTransform.Translation-Transform.Translation
    #     DeltaRotation := MakeShortestRotationBetween(Transform.Rotation, NewTransform.Rotation)
    #     DeltaScale := NewTransform.Scale/Transform.Scale
    #     Time := 0.5
    #     Interpolation := InterpolationTypes.EaseOut
    # }

    # if:
    #     AnimationController := CreativeProp.GetAnimationController[]
    #     AnimationState := AnimationController.GetState()
    #     not AnimationState = animation_controller_state.Playing
    # then:
    #     FortVaderKeyFrames : []keyframe_delta = array{MovementKeyFrame1, MovementKeyFrame2, MovementKeyFrame3}
    #     AnimationController.SetAnimation(FortVaderKeyFrames, ?Mode:=animation_mode.OneShot)
    #     AnimationController.Play()
    # else:
    #     PrintError("Block is already playing an Animation") 
--- </resource_manager_device.verse> ---

--- <ui_manager_device.verse> ---

using { /Fortnite.com/UI }
using { /Verse.org/Colors }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/UI }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Verse.org/Colors/NamedColors }

resource_health_bar_information := class():
    ResourceWrapper : resource_prop_wrapper = resource_prop_wrapper{}

    MaxHealth : float
    Health : float
    OldHealth : float

    Level : int = 0
    Name : string = ""
    AreaBonus : float = 0.0


UpgradeSlotTints : []color = array:
    color{ R := 1.0000000000, G := 1.0000000000, B := 1.0000000000 }
    color{ R := 0.5058823529, G := 0.8313725490, B := 0.1019607843 }
    color{ R := 0.0000000000, G := 0.8901960784, B := 0.9843137255 }
    color{ R := 0.9490196078, G := 0.5333333333, B := 0.9764705882 }
    color{ R := 0.8941176471, G := 0.7294117647, B := 0.3529411765 }

UpgradeEfficiencyMinLevels : []int = array{1, 5, 25, 50, 100, 150, 200, 250}

upgrade_slot_wrapper := class():
    ##### CONSTRUCT #####
    Strength<public> : float  
    Cost<public> : float
    Level<public> : int = 0
    StartingStrength<public> : float = 0.0
    
    ##### INITIALIZE #####  
    var RefGameManager<private> : game_manager_device = game_manager_device{}
    var Canvas<private> : canvas = canvas{}
    var Id<private> : int = -1
    var Height<private> : float = 0.0
    
    ##### CONST / FINAL #####
    Anchor<private> : anchors = anchors{Minimum := vector2{X := 0.5, Y := 0.5}, Maximum := vector2{X := 0.5, Y := 0.5}}



    ##### PUBLIC VARIABLES #####



    ##### EVENTS #####
    UpgradedEvent<public> : event(custom_player) = event(custom_player){}







    ##### PRIVATE VARIABLES #####
    var UpgradeSlotName<private> : string = "Strength 1"
    var UpgradeSlotLevel<private> : int = 0
    
    var ActualUpgradeCost<private> : float = 0.0

    var UpgradeCost<private> : float = 0.0
    var UpgradeStrength<private> : float = 0.0
    var TotalUpgradedStrength<private> : float = 0.0

    var UpgradeEfficiencyCost<private> : float = 0.0
    var UpgradeEfficiencyLevel<private> : int = 0

    var BulkMultiplier<private> : int = 1


    UpgradeSlotTextureBlock : texture_block = texture_block:
        DefaultImage := Assets.UI.UpgradeMenu.T_UpgradeSlot
        DefaultDesiredSize := vector2{X:= 1820.0, Y:= 100.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    UpgradeIconTextureBlock : texture_block = texture_block:  
        DefaultImage := VerseAssets.IconStrength
        DefaultDesiredSize := vector2{X:= 50.0, Y:= 50.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    UpgradeSlotNameTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.Black

    UpgradeSlotLevelTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.Black

    UpgradeSlotStrengthStackBox : stack_box = stack_box:
        Orientation := orientation.Horizontal

    UpgradeSlotStrengthTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.Black

    UpgradeSlotAddedStrengthTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.LawnGreen
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.Black
        
    ##################################
    #         UPGRADE BUTTONS        #
    ##################################
    BuyUpgradeButton : button_quiet = button_quiet{}
    BuyUpgradeStackBox : stack_box = stack_box:
        Orientation := orientation.Horizontal

    BuyUpgradeNameTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.Black

    BuyUpgradeIconTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.IconToiletPaper1
        DefaultDesiredSize := vector2{X:= 49.0, Y:= 48.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    BuyUpgradeCostTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.Black

    BuyUpgradeEfficiencyButton : button_quiet = button_quiet{}
    BuyUpgradeEfficiencyStackBox : stack_box = stack_box:
        Orientation := orientation.Horizontal
        
    BuyUpgradeEfficiencyNameTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.Black

    BuyUpgradeEfficiencyIconTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.IconToiletPaper1
        DefaultDesiredSize := vector2{X:= 49.0, Y:= 48.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    BuyUpgradeEfficiencyCostTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.Black
    

    var Initialized : logic = false
    Initiate(InId : int, InHeight : float, InCanvas : canvas, InGameManager : game_manager_device) : void = 
        if (Initialized?):
            PrintError("UpgradeSlotWrapper already initialized")
            return
        set Initialized = true

        
        set Id = InId
        set Canvas = InCanvas
        set RefGameManager = InGameManager
        set Height = InHeight
        
        set UpgradeCost = Cost
        set ActualUpgradeCost = Cost
        set UpgradeStrength = Strength

        set UpgradeEfficiencyCost = Cost*10.0
        set UpgradeSlotName = "Strength {Id+1}"

        set UpgradeSlotLevel = Level
        set TotalUpgradedStrength = StartingStrength*1.0

        # BuyUpgradeButton.SetText(StringToMessage(""))
        # BuyUpgradeEfficiencyButton.SetText(StringToMessage(""))
        BuyUpgradeButton.OnClick().Subscribe(Upgrade)
        BuyUpgradeEfficiencyButton.OnClick().Subscribe(UpgradeEfficiency)

        
        
        UpgradeSlotNameTextBlock.SetText(StringToMessage(UpgradeSlotName))
        UpgradeSlotLevelTextBlock.SetText(IntToMessage(UpgradeSlotLevel))
        UpgradeSlotStrengthTextBlock.SetText(AmountToMessage(TotalUpgradedStrength))

        UpgradeSlotAddedStrengthTextBlock.SetText(StringToMessage("(+ {AmountToString(UpgradeStrength)})"))

        StrengthColorIndex := Modular(Id, 5)
        if (UpgradeSlotTint := UpgradeSlotTints[StrengthColorIndex]):
            UpgradeIconTextureBlock.SetTint(UpgradeSlotTint)

        BuyUpgradeNameTextBlock.SetText(StringToMessage("BUY"))
        BuyUpgradeCostTextBlock.SetText(StringToMessage("{AmountToString(ActualUpgradeCost)} (x{BulkMultiplier})"))
        
        BuyUpgradeEfficiencyNameTextBlock.SetText(StringToMessage("BUY"))
        BuyUpgradeEfficiencyCostTextBlock.SetText(StringToMessage("{AmountToString(UpgradeEfficiencyCost)}"))


        BuyUpgradeInnerStackBox : stack_box = stack_box:
            Orientation := orientation.Horizontal
            Slots := array:
                stack_box_slot:
                    HorizontalAlignment := horizontal_alignment.Left
                    VerticalAlignment := vertical_alignment.Center
                    Padding := margin{Left := 0.0, Top := 0.0, Right := 5.0, Bottom := 0.0}
                    Distribution := false
                    Widget := BuyUpgradeIconTextureBlock
                stack_box_slot:
                    HorizontalAlignment := horizontal_alignment.Right
                    VerticalAlignment := vertical_alignment.Center
                    Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                    Distribution := false
                    Widget := BuyUpgradeCostTextBlock
            
        BuyUpgradeStackBoxSlots : []stack_box_slot = array:
            stack_box_slot:
                HorizontalAlignment := horizontal_alignment.Center
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                Distribution := option. 1.0
                Widget := BuyUpgradeNameTextBlock
            stack_box_slot:
                HorizontalAlignment := horizontal_alignment.Left
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 0.0, Top := 0.0, Right := 35.0, Bottom := 0.0}
                Distribution := false
                Widget := BuyUpgradeInnerStackBox

        for (BuyUpgradeStackBoxSlot : BuyUpgradeStackBoxSlots):
            BuyUpgradeStackBox.AddWidget(BuyUpgradeStackBoxSlot)



        BuyUpgradeEfficiencyInnerStackBox : stack_box = stack_box:
            Orientation := orientation.Horizontal
            Slots := array:
                stack_box_slot:
                    HorizontalAlignment := horizontal_alignment.Left
                    VerticalAlignment := vertical_alignment.Center
                    Padding := margin{Left := 0.0, Top := 0.0, Right := 5.0, Bottom := 0.0}
                    Distribution := false
                    Widget := BuyUpgradeEfficiencyIconTextureBlock
                stack_box_slot:
                    HorizontalAlignment := horizontal_alignment.Right
                    VerticalAlignment := vertical_alignment.Center
                    Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                    Distribution := false
                    Widget := BuyUpgradeEfficiencyCostTextBlock
            
        BuyUpgradeEfficiencyStackBoxSlots : []stack_box_slot = array:
            stack_box_slot:
                HorizontalAlignment := horizontal_alignment.Center
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                Distribution := option. 1.0
                Widget := BuyUpgradeEfficiencyNameTextBlock
            stack_box_slot:
                HorizontalAlignment := horizontal_alignment.Left
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 0.0, Top := 0.0, Right := 35.0, Bottom := 0.0}
                Distribution := false
                Widget := BuyUpgradeEfficiencyInnerStackBox
            # stack_box_slot:
            #     HorizontalAlignment := horizontal_alignment.Center
            #     VerticalAlignment := vertical_alignment.Center
            #     Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
            #     Distribution := option. 1.0
            #     Widget := BuyUpgradeEfficiencyIconTextureBlock
            # stack_box_slot:
            #     HorizontalAlignment := horizontal_alignment.Right
            #     VerticalAlignment := vertical_alignment.Center
            #     Padding := margin{Left := -52.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
            #     Distribution := false
            #     Widget := BuyUpgradeEfficiencyCostTextBlock

        for (BuyUpgradeEfficiencyStackBoxSlot : BuyUpgradeEfficiencyStackBoxSlots):
            BuyUpgradeEfficiencyStackBox.AddWidget(BuyUpgradeEfficiencyStackBoxSlot)

        UpgradeSlotStrengthStackBoxSlots : []stack_box_slot = array:
            stack_box_slot:
                Widget := UpgradeSlotStrengthTextBlock
                HorizontalAlignment := horizontal_alignment.Left
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 0.0, Top := 0.0, Right := 29.0, Bottom := 0.0}
            stack_box_slot:
                Widget := UpgradeSlotAddedStrengthTextBlock
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
        for (UpgradeSlotStrengthStackBoxSlot : UpgradeSlotStrengthStackBoxSlots):
            UpgradeSlotStrengthStackBox.AddWidget(UpgradeSlotStrengthStackBoxSlot)
        
        Widgets : []canvas_slot = array:
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := 0.0, Top := Height, Right := 0.0, Bottom  := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 202
                Widget := UpgradeSlotTextureBlock

            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := -857.500000, Top := Height, Right := 0.0, Bottom  := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 203
                Widget := UpgradeIconTextureBlock
                
            canvas_slot: 
                Anchors := Anchor
                Offsets := margin{Left := -806.000000, Top := Height, Right := 0.0, Bottom  := 0.0}
                Alignment := vector2{X:=0.0, Y:=0.5}
                SizeToContent := true
                ZOrder := 203
                Widget := UpgradeSlotNameTextBlock
            canvas_slot: 
                Anchors := Anchor
                Offsets := margin{Left := -530.000000 + 11.0 , Top := Height, Right := 0.0, Bottom  := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 203
                Widget := UpgradeSlotLevelTextBlock
            canvas_slot: 
                Anchors := Anchor
                Offsets := margin{Left := -433.000000, Top := Height, Right := 300.000000, Bottom  := 100.000000}
                Alignment := vector2{X:=0.0, Y:=0.5}
                SizeToContent := false
                ZOrder := 203
                Widget := UpgradeSlotStrengthStackBox
            canvas_slot: 
                Anchors := Anchor
                Offsets := margin{Left := 155.000000, Top := Height, Right := 470.000000, Bottom  := 80.000000}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := false
                ZOrder := 204
                Widget := BuyUpgradeButton
            canvas_slot: 
                Anchors := Anchor
                Offsets := margin{Left := 155.000000, Top := Height, Right := 380.000000, Bottom  := 80.000000}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := false
                ZOrder := 203
                Widget := BuyUpgradeStackBox
            canvas_slot: 
                Anchors := Anchor
                Offsets := margin{Left := 665.250000, Top := Height, Right := 470.000000, Bottom  := 80.000000}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := false
                ZOrder := 204
                Widget := BuyUpgradeEfficiencyButton
            canvas_slot: 
                Anchors := Anchor
                Offsets := margin{Left := 665.250000, Top := Height, Right := 300.000000, Bottom  := 80.000000}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := false
                ZOrder := 203
                Widget := BuyUpgradeEfficiencyStackBox
        for (Widget : Widgets):
            Canvas.AddWidget(Widget)
        Close()


    Update(CustomPlayer : custom_player) : void =
        if (CustomPlayer.GetResourceAmount() < UpgradeCost * BulkMultiplier). BuyUpgradeCostTextBlock.SetTextColor(NamedColors.Red)
        else. BuyUpgradeCostTextBlock.SetTextColor(NamedColors.White)

        SetMultiplier(BulkMultiplier, CustomPlayer)
        SetUpgradeCost(CustomPlayer)
        SetUpgradeEfficiency(CustomPlayer)


    var IsOpen : logic = false
    Open(CustomPlayer : custom_player) : void = 
        if (not Initialized?):
            PrintError("UpgradeSlotWrapper is not initialized correctly")
            return
        if (IsOpen?):
            PrintError("UpgradeSlotWrapper is already open")
            return

        ##################################################
        #    correctly set variables for custom player   #
        ##################################################
        Update(CustomPlayer)
     
        ##################################################
        UpgradeSlotNameTextBlock.SetVisibility(widget_visibility.Visible)
        UpgradeSlotLevelTextBlock.SetVisibility(widget_visibility.Visible)
        UpgradeSlotStrengthTextBlock.SetVisibility(widget_visibility.Visible)
        UpgradeSlotAddedStrengthTextBlock.SetVisibility(widget_visibility.Visible)
        UpgradeIconTextureBlock.SetVisibility(widget_visibility.Visible)
        BuyUpgradeButton.SetVisibility(widget_visibility.Visible)
        BuyUpgradeEfficiencyButton.SetVisibility(widget_visibility.Visible)
        BuyUpgradeNameTextBlock.SetVisibility(widget_visibility.Visible)
        BuyUpgradeIconTextureBlock.SetVisibility(widget_visibility.Visible)
        BuyUpgradeCostTextBlock.SetVisibility(widget_visibility.Visible)
        BuyUpgradeEfficiencyCostTextBlock.SetVisibility(widget_visibility.Visible)
        set IsOpen = true

    Close() : void = 
        set IsOpen = false
        UpgradeSlotNameTextBlock.SetVisibility(widget_visibility.Hidden)
        UpgradeSlotLevelTextBlock.SetVisibility(widget_visibility.Hidden)
        UpgradeSlotStrengthTextBlock.SetVisibility(widget_visibility.Hidden)
        UpgradeSlotAddedStrengthTextBlock.SetVisibility(widget_visibility.Hidden)
        BuyUpgradeButton.SetVisibility(widget_visibility.Hidden)
        UpgradeIconTextureBlock.SetVisibility(widget_visibility.Hidden)
        BuyUpgradeEfficiencyButton.SetVisibility(widget_visibility.Hidden)
        BuyUpgradeNameTextBlock.SetVisibility(widget_visibility.Hidden)
        BuyUpgradeIconTextureBlock.SetVisibility(widget_visibility.Hidden)
        BuyUpgradeCostTextBlock.SetVisibility(widget_visibility.Hidden)
        BuyUpgradeEfficiencyCostTextBlock.SetVisibility(widget_visibility.Hidden)
        BuyUpgradeEfficiencyNameTextBlock.SetVisibility(widget_visibility.Hidden)
        BuyUpgradeEfficiencyIconTextureBlock.SetVisibility(widget_visibility.Hidden)

    
    var _IsUnlocked<private> : logic = false
    Unlock<public>() : void =
        set _IsUnlocked = true
        
    IsUnlocked<public>()<transacts><decides> : decides_result = 
        var MaybeDecidesResult : ?decides_result = false
        if (_IsUnlocked?):
            set MaybeDecidesResult = option. decides_result{Value := _IsUnlocked}
        return MaybeDecidesResult? 


    CalculateMaxLevelsPossible(CustomPlayer : custom_player) : int = 
        var TempCost : float = 0.0
        var LevelsPossible : int = 0
        loop:
            if (TempCost >= CustomPlayer.GetResourceAmount() or LevelsPossible = 100):
                break
            set TempCost += UpgradeCost * Pow(StrengthUpgradeFactor, LevelsPossible*1.0)
            set LevelsPossible += 1
        return LevelsPossible-1

    SetMultiplier(InMultiplier : int, CustomPlayer : custom_player) : void =         
        MaxLevelsPossible := CalculateMaxLevelsPossible(CustomPlayer)
        if (InMultiplier <> 1):
            if (MaxLevelsPossible <> 0). set BulkMultiplier = Min(InMultiplier, MaxLevelsPossible)
            else. set BulkMultiplier = InMultiplier

            set ActualUpgradeCost = UpgradeCost
            for (I := 1..BulkMultiplier-1):
                set ActualUpgradeCost += UpgradeCost * Pow(StrengthUpgradeFactor, I*1.0)
        else:
            set BulkMultiplier = 1
            set ActualUpgradeCost = UpgradeCost

    SetUpgradeEfficiency(CustomPlayer : custom_player) : void = 
        if:
            NextUpgradeEfficiencyMinLevel := UpgradeEfficiencyMinLevels[UpgradeEfficiencyLevel]
        then:
            if:
                UpgradeSlotLevel >= NextUpgradeEfficiencyMinLevel
            then:
                BuyUpgradeEfficiencyNameTextBlock.SetVisibility(widget_visibility.Visible)
                BuyUpgradeEfficiencyIconTextureBlock.SetVisibility(widget_visibility.Visible)
                BuyUpgradeEfficiencyCostTextBlock.SetText(AmountToMessage(UpgradeEfficiencyCost))
                if (CustomPlayer.GetResourceAmount() >= UpgradeEfficiencyCost). BuyUpgradeEfficiencyCostTextBlock.SetTextColor(NamedColors.White)
                else. BuyUpgradeEfficiencyCostTextBlock.SetTextColor(NamedColors.Red)
            else:
                BuyUpgradeEfficiencyNameTextBlock.SetVisibility(widget_visibility.Hidden)
                BuyUpgradeEfficiencyIconTextureBlock.SetVisibility(widget_visibility.Hidden)
                BuyUpgradeEfficiencyCostTextBlock.SetText(StringToMessage("Requires Lv. {NextUpgradeEfficiencyMinLevel}"))
                BuyUpgradeEfficiencyCostTextBlock.SetTextColor(NamedColors.Red)
        else:
            BuyUpgradeEfficiencyNameTextBlock.SetVisibility(widget_visibility.Hidden)
            BuyUpgradeEfficiencyIconTextureBlock.SetVisibility(widget_visibility.Hidden)
            BuyUpgradeEfficiencyCostTextBlock.SetText(StringToMessage("MAX LEVEL"))
            BuyUpgradeEfficiencyCostTextBlock.SetTextColor(NamedColors.White)


    SetUpgradeCost(CustomPlayer : custom_player) : void = 
        if:
            CustomPlayer.GetResourceAmount() >= ActualUpgradeCost
        then:
            BuyUpgradeCostTextBlock.SetText(StringToMessage("{AmountToString(ActualUpgradeCost)} (x{BulkMultiplier})"))
            BuyUpgradeCostTextBlock.SetTextColor(NamedColors.White)
        else:
            BuyUpgradeCostTextBlock.SetText(StringToMessage("{AmountToString(ActualUpgradeCost)} (x{BulkMultiplier})"))
            BuyUpgradeCostTextBlock.SetTextColor(NamedColors.Red)
            

    Upgrade(WidgetMessage : widget_message) : void = 
        if:
            Player := WidgetMessage.Player
            CustomPlayer := RefGameManager.GetCustomPlayer[Player]
            FloorCost := Floor[ActualUpgradeCost]
            CustomPlayer.HasResource[FloorCost*1.0, resource_type.ToiletPaper]
        then:
            CustomPlayer.SpendResource(ActualUpgradeCost, resource_type.ToiletPaper)
            set UpgradeSlotLevel = UpgradeSlotLevel + 1*BulkMultiplier 

            CustomPlayer.AddStrength(UpgradeStrength * BulkMultiplier)
            set TotalUpgradedStrength += UpgradeStrength * BulkMultiplier


            set UpgradeCost = UpgradeCost * Pow(StrengthUpgradeFactor, BulkMultiplier*1.0)
            if (BulkMultiplier <> 1):
                set ActualUpgradeCost = 0.0
                for (I := 1..BulkMultiplier-1):
                    set ActualUpgradeCost += UpgradeCost * Pow(StrengthUpgradeFactor, I*1.0)
            else:
                set ActualUpgradeCost = UpgradeCost
            
            UpgradedEvent.Signal(CustomPlayer)
            UpgradeSlotStrengthTextBlock.SetText(AmountToMessage(TotalUpgradedStrength))
            UpgradeSlotLevelTextBlock.SetText(IntToMessage(UpgradeSlotLevel))
            Update(CustomPlayer)


    UpgradeEfficiency(WidgetMessage : widget_message) : void = 
        if:
            Player := WidgetMessage.Player
            CustomPlayer := RefGameManager.GetCustomPlayer[Player]
            UpgradeEfficiencyMinLevel := UpgradeEfficiencyMinLevels[UpgradeEfficiencyLevel]
            UpgradeSlotLevel >= UpgradeEfficiencyMinLevel
            CustomPlayer.HasResource[UpgradeEfficiencyCost, resource_type.ToiletPaper]
        then:
            CustomPlayer.SpendResource(UpgradeEfficiencyCost, resource_type.ToiletPaper)
            set UpgradeEfficiencyLevel = UpgradeEfficiencyLevel + 1
            CustomPlayer.AddStrength(TotalUpgradedStrength)
            set UpgradeStrength = UpgradeStrength * 2
            set TotalUpgradedStrength = TotalUpgradedStrength * 2

            
            if (UpgradeEfficiencyLevel = 1):
                set UpgradeEfficiencyCost = UpgradeEfficiencyCost * 10 
            else if (UpgradeEfficiencyLevel = 2):
                set UpgradeEfficiencyCost = UpgradeEfficiencyCost * 5
            else if (UpgradeEfficiencyLevel = 3):
                set UpgradeEfficiencyCost = UpgradeEfficiencyCost * 10
            else if (UpgradeEfficiencyLevel = 4):   
                set UpgradeEfficiencyCost = UpgradeEfficiencyCost * 5
            else if (UpgradeEfficiencyLevel = 5):   
                set UpgradeEfficiencyCost = UpgradeEfficiencyCost * 10

            UpgradeSlotStrengthTextBlock.SetText(AmountToMessage(TotalUpgradedStrength))
            UpgradeSlotAddedStrengthTextBlock.SetText(StringToMessage("(+ {AmountToString(UpgradeStrength)})"))
            Update(CustomPlayer)


upgrade_menu_wrapper := class():
    ##### INITIALIZE #####
    var RefGameManager<private> : game_manager_device = game_manager_device{}
    var Canvas<private> : canvas = canvas{}

    ##### CONST / FINAL #####
    Anchor<private> : anchors = anchors{Minimum := vector2{X := 0.5, Y := 0.5}, Maximum := vector2{X := 0.5, Y := 0.5}}


    
    # UnlockedUpgradeSlotEvent<public> : event() = event(){}

    ##### VARIABLES #####
    var BulkMultiplier<private> : int = 1

    var TotalPages<private> : int = 1
    var CurrentPage<private> : int = 1
    var UnlockedUpgradeSlots<private> : int = 1

    UpgradeSlots<private> : []upgrade_slot_wrapper = array:
        upgrade_slot_wrapper{ Level := 1, StartingStrength := 1.0, Strength := 1.0, Cost := 15.0 }
        upgrade_slot_wrapper{ Strength := 10.0, Cost := 100.0 }
        upgrade_slot_wrapper{ Strength := 100.0, Cost := 1200.0 }
        upgrade_slot_wrapper{ Strength := 500.0, Cost := 12000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        upgrade_slot_wrapper{ Strength := 1000.0, Cost := 120000.0 }
        # upgrade_slot_wrapper{ Strength := 2500.0, Cost := 1500000.0 }




    ######### FIXED #########
    BackgroundTextureBlock : texture_block = texture_block:
        DefaultImage := Assets.UI.UpgradeMenu.T_UpgradeMenu
        DefaultDesiredSize := vector2{X:= 1920.0, Y:= 1080.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
    
    IconResourceTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.IconToiletPaper1
        DefaultDesiredSize := vector2{X:= 48.0, Y:= 48.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    IconStrengthTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.IconStrength
        DefaultDesiredSize := vector2{X:= 48.0, Y:= 48.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    TitleTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.White

    ColumnNameTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 0.5
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.White

    ColumnLevelTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 0.5
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.White

    ColumnStrengthTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 0.5
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.White
    
    ColumnUpgradeTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 0.5
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.White

    ColumnUpgradeEfficiencyTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 0.5
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.White


    ######### DYNAMIC #########

    PageTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 0.3
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.White

    PagePreviousButton : button_quiet = button_quiet{}
    PageNextButton : button_quiet = button_quiet{}





    ######### DYNAMIC #########
    StrengthTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.White

    ResourceTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.White

    BuyTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Right
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=0.0, Y:=0.0}
        DefaultShadowOpacity := 0.0
        DefaultShadowColor := NamedColors.White

    Button1x : button_quiet = button_quiet{}
    Button10x : button_quiet = button_quiet{}
    Button100x : button_quiet = button_quiet{}
    CloseButton : button_loud = button_loud{}


    
        

    var Initialized : logic = false
    Initiate(InGameManager : game_manager_device) : void =
        if (Initialized?):
            PrintError("UpgradeMenuWrapper already initialized")
            return
        set Initialized = true

        set RefGameManager = InGameManager

        if (UpgradeSlot := UpgradeSlots[0]). UpgradeSlot.Unlock()
        spawn. UnlockUpgradeSlots()

        TitleTextBlock.SetText(StringToMessage("Strength Upgrades"))
        ColumnNameTextBlock.SetText(StringToMessage("Name"))
        ColumnLevelTextBlock.SetText(StringToMessage("Level"))
        ColumnStrengthTextBlock.SetText(StringToMessage("Strength"))
        ColumnUpgradeTextBlock.SetText(StringToMessage("Upgrade"))
        ColumnUpgradeEfficiencyTextBlock.SetText(StringToMessage("Upgrade Efficiency"))

        BuyTextBlock.SetText(StringToMessage("Buy (x1):"))

        Button1x.SetText(StringToMessage("X1"))
        Button10x.SetText(StringToMessage("X10"))
        Button100x.SetText(StringToMessage("X100"))
        CloseButton.SetText(StringToMessage("CLOSE"))
        Button1x.OnClick().Subscribe(SetMultiplier1x)
        Button10x.OnClick().Subscribe(SetMultiplier10x)
        Button100x.OnClick().Subscribe(SetMultiplier100x)
        CloseButton.OnClick().Subscribe(Close)

        # ResourceTextBlock.SetText(StringToMessage("0"))
        # StrengthTextBlock.SetText(StringToMessage("1"))


        PageTextBlock.SetText(StringToMessage("Page {CurrentPage} / {TotalPages}"))
        PagePreviousButton.SetText(StringToMessage(""))
        PageNextButton.SetText(StringToMessage(""))
        PagePreviousButton.OnClick().Subscribe(GoToPreviousPage)
        PageNextButton.OnClick().Subscribe(GoToNextPage)

        if (TotalPages < 2):
            PageTextBlock.SetVisibility(widget_visibility.Hidden)
            PagePreviousButton.SetVisibility(widget_visibility.Hidden)
            PageNextButton.SetVisibility(widget_visibility.Hidden)
    
        


        MyCanvas : canvas = canvas:
            Slots := array:
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 200
                    Widget := BackgroundTextureBlock

                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := -880.000000, Top := -390.000000, Right := 0.0, Bottom := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := IconResourceTextureBlock

                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := -609.000000, Top := -390.000000, Right := 0.0, Bottom := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := IconStrengthTextureBlock

                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 0.0, Top := -470.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := TitleTextBlock


                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := -763.0, Top := -299.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := ColumnNameTextBlock

                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := -526.5, Top := -299.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := ColumnLevelTextBlock

                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := -365.0, Top := -299.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := ColumnStrengthTextBlock

                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := -15.0, Top := -299.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := ColumnUpgradeTextBlock

                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 578.0, Top := -299.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := ColumnUpgradeEfficiencyTextBlock

                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := -559.72, Top := -390.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.0, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := StrengthTextBlock
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := -830.30, Top := -390.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.0, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := ResourceTextBlock
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 590.946777, Top := -390.168213, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=1.0, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := BuyTextBlock
                
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 638.0, Top := -390.0, Right := 78.0, Bottom  := 60.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 201
                    Widget := Button1x

                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 735.0, Top := -390.0, Right := 99.0, Bottom  := 60.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 201
                    Widget := Button10x

                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 852.296692, Top := -390.0, Right := 116.56, Bottom  := 60.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 201
                    Widget := Button100x



                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := -834.0, Top := 360.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := PageTextBlock

                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := -728.0, Top := 364.0, Right := 808.0, Bottom  := 60.0}
                    Alignment := vector2{X:=0.0, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 201
                    Widget := PagePreviousButton

                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 100.0, Top := 364.0, Right := 808.0, Bottom  := 60.0}
                    Alignment := vector2{X:=0.0, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 201
                    Widget := PageNextButton

    





                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 0.0, Top := 470.0, Right := 171.0, Bottom  := 81.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 201
                    Widget := CloseButton
        set Canvas = MyCanvas

        for (Index->UpgradeSlot : UpgradeSlots):
            PositionOffset : int = Modular(Index, 5)
            UpgradeSlot.Initiate(Index, -194.000000+PositionOffset*111.0, Canvas, RefGameManager)


        # StrengthTextBlock
        # ResourceTextBlock
        # BuyTextBlock
        # Button1x
        # Button10x
        # Button100x
        # CloseButton
            
        # for (CanvasSlot : CanvasSlots):
        #     Canvas.AddWidget(CanvasSlot)
        

    Update(CustomPlayer : custom_player) : void = 
        ResourceTextBlock.SetText(AmountToMessage(CustomPlayer.GetResourceAmount()))
        StrengthTextBlock.SetText(AmountToMessage(CustomPlayer.GetStrength()))
        for (
            I := ((CurrentPage-1)*5)..(CurrentPage*5-1), 
            UpgradeSlot := UpgradeSlots[I],
            UpgradeSlot.IsUnlocked[]
        ):
            if (not UpgradeSlot.IsOpen?):
                UpgradeSlot.Open(CustomPlayer)
            UpgradeSlot.Update(CustomPlayer)


    var IsOpen : logic = false
    Open(CustomPlayer : custom_player) : void = 
        if (not Initialized?):
            PrintError("Resource Health Bar is not initialized")
            return
        if (IsOpen?):
            PrintError("Resource Health Bar is already open")
            return

        for (
            I := ((CurrentPage-1)*5)..(CurrentPage*5-1), 
            UpgradeSlot := UpgradeSlots[I],
            UpgradeSlot.IsUnlocked[]
        ):
            UpgradeSlot.Open(CustomPlayer)


        BackgroundTextureBlock.SetVisibility(widget_visibility.Visible)
        TitleTextBlock.SetVisibility(widget_visibility.Visible)
        ColumnNameTextBlock.SetVisibility(widget_visibility.Visible)
        ColumnLevelTextBlock.SetVisibility(widget_visibility.Visible)
        ColumnStrengthTextBlock.SetVisibility(widget_visibility.Visible)
        ColumnUpgradeTextBlock.SetVisibility(widget_visibility.Visible)
        ColumnUpgradeEfficiencyTextBlock.SetVisibility(widget_visibility.Visible)
        StrengthTextBlock.SetVisibility(widget_visibility.Visible)
        ResourceTextBlock.SetVisibility(widget_visibility.Visible)
        BuyTextBlock.SetVisibility(widget_visibility.Visible)
        Button1x.SetVisibility(widget_visibility.Visible)
        Button10x.SetVisibility(widget_visibility.Visible)
        Button100x.SetVisibility(widget_visibility.Visible)
        CloseButton.SetVisibility(widget_visibility.Visible)


        if (TotalPages > 1):
            PageTextBlock.SetText(StringToMessage("Page {CurrentPage} / {TotalPages}"))
            PageTextBlock.SetVisibility(widget_visibility.Visible)
            PagePreviousButton.SetVisibility(widget_visibility.Visible)
            PageNextButton.SetVisibility(widget_visibility.Visible)

        BuyTextBlock.SetText(StringToMessage("Buy (x{BulkMultiplier}):"))
        ResourceTextBlock.SetText(AmountToMessage(CustomPlayer.GetResourceAmount()))
        StrengthTextBlock.SetText(AmountToMessage(CustomPlayer.GetStrength()))

        if (PlayerUI := GetPlayerUI[CustomPlayer.RefPlayer]):
            PlayerUI.AddWidget(Canvas, player_ui_slot{InputMode:=ui_input_mode.All, ZOrder := 200})
        else:
            PrintError("Could not retrieve Player UI")
        set IsOpen = true


    UnlockUpgradeSlots()<suspends> : void = 
        for (I->UpgradeSlot : UpgradeSlots):
            CustomPlayer := UpgradeSlot.UpgradedEvent.Await()
            if (NextUpgradeSlot := UpgradeSlots[I+1]):
                NextUpgradeSlot.Unlock()
                Self.Update(CustomPlayer)
                
                set UnlockedUpgradeSlots += 1
                Print("UnlockedUpgradeSlots: {UnlockedUpgradeSlots}")
                if (CeilPages := Ceil[UnlockedUpgradeSlots*1.0 / 5.0]):
                    Print("CeilPages: {CeilPages}")
                    set TotalPages = Max(CeilPages, 1)
                    Print("TotalPages: {TotalPages}")

                    if (TotalPages > 1): 
                        PageTextBlock.SetText(StringToMessage("Page {CurrentPage} / {TotalPages}"))
                        PageTextBlock.SetVisibility(widget_visibility.Visible)
                        PagePreviousButton.SetVisibility(widget_visibility.Visible)
                        PageNextButton.SetVisibility(widget_visibility.Visible)           

    ChangePage(ChangeAmount : int, CustomPlayer : custom_player) : void = 
        set CurrentPage += ChangeAmount
        if (CurrentPage < 1):
            set CurrentPage = TotalPages
        else if (CurrentPage > TotalPages):
            set CurrentPage = 1

        for (I->UpgradeSlot : UpgradeSlots):
            if:
                I >= ((CurrentPage-1)*5)
                I <= (CurrentPage*5-1)
                UpgradeSlot.IsUnlocked[]
            then:
                UpgradeSlot.Open(CustomPlayer)
            else:
                UpgradeSlot.Close()
        PageTextBlock.SetText(StringToMessage("Page {CurrentPage} / {TotalPages}"))


    GoToPreviousPage(WidgetMessage : widget_message) : void = 
        if:
            CustomPlayer := RefGameManager.GetCustomPlayer[WidgetMessage.Player]
        then:
            ChangePage(-1, CustomPlayer)

    GoToNextPage(WidgetMessage : widget_message) : void = 
        if:
            CustomPlayer := RefGameManager.GetCustomPlayer[WidgetMessage.Player]
        then:
            ChangePage(+1, CustomPlayer)


    Close(WidgetMessage : widget_message) : void = 
        set IsOpen = false
        Player := WidgetMessage.Player

        for (Index->UpgradeSlot : UpgradeSlots):
            UpgradeSlot.Close()

        BackgroundTextureBlock.SetVisibility(widget_visibility.Hidden)
        TitleTextBlock.SetVisibility(widget_visibility.Hidden)
        ColumnNameTextBlock.SetVisibility(widget_visibility.Hidden)
        ColumnLevelTextBlock.SetVisibility(widget_visibility.Hidden)
        ColumnStrengthTextBlock.SetVisibility(widget_visibility.Hidden)
        ColumnUpgradeTextBlock.SetVisibility(widget_visibility.Hidden)
        ColumnUpgradeEfficiencyTextBlock.SetVisibility(widget_visibility.Hidden)
        StrengthTextBlock.SetVisibility(widget_visibility.Hidden)
        ResourceTextBlock.SetVisibility(widget_visibility.Hidden)
        BuyTextBlock.SetVisibility(widget_visibility.Hidden)
        Button1x.SetVisibility(widget_visibility.Hidden)
        Button10x.SetVisibility(widget_visibility.Hidden)
        Button100x.SetVisibility(widget_visibility.Hidden)
        CloseButton.SetVisibility(widget_visibility.Hidden)


        PageTextBlock.SetVisibility(widget_visibility.Hidden)
        PagePreviousButton.SetVisibility(widget_visibility.Hidden)
        PageNextButton.SetVisibility(widget_visibility.Hidden)


        
        if (PlayerUI := GetPlayerUI[Player]):
            PlayerUI.RemoveWidget(Canvas)
        else:
            PrintError("Could not retrieve Player UI")

            
    SetMultiplier1x(WidgetMessage : widget_message) : void = 
        if:
            CustomPlayer := RefGameManager.GetCustomPlayer[WidgetMessage.Player]
        then:
            set BulkMultiplier = 1
            BuyTextBlock.SetText(StringToMessage("Buy (x{BulkMultiplier}):"))
            for (UpgradeSlot : UpgradeSlots):
                UpgradeSlot.SetMultiplier(BulkMultiplier, CustomPlayer)
                UpgradeSlot.Update(CustomPlayer)

    SetMultiplier10x(WidgetMessage : widget_message) : void = 
        if:
            CustomPlayer := RefGameManager.GetCustomPlayer[WidgetMessage.Player]
        then:
            set BulkMultiplier = 10
            BuyTextBlock.SetText(StringToMessage("Buy (x{BulkMultiplier}):"))
            for (UpgradeSlot : UpgradeSlots):
                UpgradeSlot.SetMultiplier(BulkMultiplier, CustomPlayer)
                UpgradeSlot.Update(CustomPlayer)

    SetMultiplier100x(WidgetMessage : widget_message) : void = 
        if:
            CustomPlayer := RefGameManager.GetCustomPlayer[WidgetMessage.Player]
        then:
            set BulkMultiplier = 100
            BuyTextBlock.SetText(StringToMessage("Buy (x{BulkMultiplier}):"))
            for (UpgradeSlot : UpgradeSlots):
                UpgradeSlot.SetMultiplier(BulkMultiplier, CustomPlayer)
                UpgradeSlot.Update(CustomPlayer)
                
resource_health_bar_wrapper := class(): 
    ##### INITIALIZE #####
    var Canvas<private> : canvas = canvas{}
    var HealthBarLength<private> : float = 0.0  
    
    ##### CONST / FINAL #####
    Anchor<private> : anchors = anchors{Minimum := vector2{X := 0.5, Y := 0.05}, Maximum := vector2{X := 0.5, Y := 0.05}}
    
    
    ##### VARIABLES #####
    var CurrentTimer<public> : float = 0.0

    var Level<private> : int = 0
    var Name<private> : string = ""
    var AreaBonus<private> : float = 0.0
    var ReferencedResourceWrapper<private> : resource_prop_wrapper = resource_prop_wrapper{}

    var CanvasSlots<private> : []canvas_slot = array{}
    var MaxHealth<private> : float = 0.0
    var DisplayedHealth<private> : float = 0.0
    var DisplayedSteps<private> : int = 0
    var InterpolateText<private> : logic = true
    var InterpolateTextOnlyPositive<private> : logic = false
    var BufferedHealth<private> : float = 0.0
    var TargetHealth<private> : float = 0.0

    ######### HEALTH BAR #########
    HealthBarBackgroundTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.HealthBarRectangle
        DefaultDesiredSize := vector2{X:= 600.0, Y:= 40.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    HealthBarTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=1.0, Y:=1.0}
        DefaultShadowOpacity := 1.0
        DefaultShadowColor := NamedColors.Black

    HealthBarStackBox : stack_box = stack_box:
        Orientation := orientation.Horizontal
    
    HealthBarLine : texture_block = texture_block:
        DefaultImage := VerseAssets.HealthBarLine
        DefaultDesiredSize := vector2{X:= 600.0, Y:= 40.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
    
    HealthBarFill : texture_block = texture_block:
        DefaultImage := VerseAssets.TransparentTexture
        DefaultDesiredSize := vector2{X:= 600.0, Y:= 40.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}


    BufferedHealthBarStackBox : stack_box = stack_box:
        Orientation := orientation.Horizontal
    
    BufferedHealthBarLine : texture_block = texture_block:
        DefaultImage := VerseAssets.HealthBarLineBuffered
        DefaultDesiredSize := vector2{X:= 600.0, Y:= 40.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
    
    BufferedHealthBarFill : texture_block = texture_block:
        DefaultImage := VerseAssets.TransparentTexture
        DefaultDesiredSize := vector2{X:= 600.0, Y:= 40.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}


    ######### AREA BONUS #########
    AreaBonusStackBox : stack_box = stack_box:
        Orientation := orientation.Horizontal
    
    AreaBonusTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.IconSupplyDrop
        DefaultDesiredSize := vector2{X:= 40.0, Y:= 40.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
    
    AreaBonusTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=2.0, Y:=2.0}
        DefaultShadowOpacity := 0.65
        DefaultShadowColor := NamedColors.Black

    ######### LEVEL AND NAME #########
    var LevelAndNameStackBoxSlots : []stack_box_slot = array{}
    var LevelIsHidden : logic = false

    LevelAndNameStackBox : stack_box = stack_box:
        Orientation := orientation.Horizontal

    LevelFixedTextBlock : text_block = text_block:
        DefaultTextColor := color{R:=0.958333, G:=0.208304, B:=0.0}
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=3.0, Y:=3.0}
        DefaultShadowOpacity := 0.4
        DefaultShadowColor := NamedColors.Black

    LevelTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=3.0, Y:=3.0}
        DefaultShadowOpacity := 0.5
        DefaultShadowColor := NamedColors.Black

    NameTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=3.0, Y:=3.0}
        DefaultShadowOpacity := 0.5
        DefaultShadowColor := NamedColors.Black
        
        
    var Initialized : logic = false
    Initiate(InCanvas : canvas, InHealthBarLength : float) : void =
        if (Initialized?):
            PrintError("ResourceHealthBarWrapper already initialized")
            return
        set Canvas = InCanvas
        set HealthBarLength = InHealthBarLength

        BufferedHealthBarStackBoxSlots : []stack_box_slot = array{
            stack_box_slot:
                Widget := BufferedHealthBarLine
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Fill
                Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
            stack_box_slot:
                Widget := BufferedHealthBarFill
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Fill
                Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
        }
        for (StackBoxSlot : BufferedHealthBarStackBoxSlots):
            BufferedHealthBarStackBox.AddWidget(StackBoxSlot)

        HealthBarStackBoxSlots : []stack_box_slot = array{
            stack_box_slot:
                Widget := HealthBarLine
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Fill
                Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
            stack_box_slot:
                Widget := HealthBarFill
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Fill
                Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
        }
        for (StackBoxSlot : HealthBarStackBoxSlots):
            HealthBarStackBox.AddWidget(StackBoxSlot)

        
        AreaBonusStackBoxSlots : []stack_box_slot = array{
            stack_box_slot:
                Widget := AreaBonusTextureBlock
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 0.0, Top := 0.0, Right := 5.0, Bottom := 0.0}
            stack_box_slot:
                Widget := AreaBonusTextBlock
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
        }

        for (StackBoxSlot : AreaBonusStackBoxSlots):
            AreaBonusStackBox.AddWidget(StackBoxSlot)


        set LevelAndNameStackBoxSlots = array{
            stack_box_slot:
                Widget := LevelFixedTextBlock
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 10.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
            stack_box_slot:
                Widget := LevelTextBlock
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 16.5, Top := 0.0, Right := 25.0, Bottom := 0.0}
            stack_box_slot:
                Widget := NameTextBlock
                HorizontalAlignment := horizontal_alignment.Fill
                VerticalAlignment := vertical_alignment.Center
                Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
        }

        for (StackBoxSlot : LevelAndNameStackBoxSlots):
            LevelAndNameStackBox.AddWidget(StackBoxSlot)

        
        set CanvasSlots = array{
            ######### HEALTH BAR #########
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := 0.0, Top := 19.0, Right := 600.0, Bottom := 40.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 1
                Widget := HealthBarBackgroundTextureBlock

            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := 0.0, Top := 19.0, Right := 600.0, Bottom := 40.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := false
                ZOrder := 2
                Widget := BufferedHealthBarStackBox

            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := 0.0, Top := 19.0, Right := 600.0, Bottom := 40.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := false
                ZOrder := 3
                Widget := HealthBarStackBox

            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := 0.0, Top := 19.0, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 4
                Widget := HealthBarTextBlock

            ######### AREA BONUS #########
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := 0.0, Top := 63.5, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 2
                Widget := AreaBonusStackBox

            ######### LEVEL AND NAME #########
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := 0.0, Top := -24.0, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 2
                Widget := LevelAndNameStackBox
        }

        for (CanvasSlot : CanvasSlots):
            Canvas.AddWidget(CanvasSlot)

        HealthBarTextBlock.SetText(StringToMessage("0 / 0"))
        NameTextBlock.SetText(StringToMessage(""))
        AreaBonusTextBlock.SetText(StringToMessage("0%"))
        LevelFixedTextBlock.SetText(StringToMessage("LvL."))
        LevelTextBlock.SetText(IntToMessage(1))

        HealthBarFill.SetVisibility(widget_visibility.Hidden)
        BufferedHealthBarFill.SetVisibility(widget_visibility.Hidden)

        if (HealthBarLength = 0.0):
            PrintError("Resource Health Bar Length not initialized correctly")

        set Initialized = true
        Close()



    var IsOpen : logic = false
    Open() : void = 
        if (not Initialized?):
            PrintError("Resource Health Bar is not initialized correctly")
            return
            
        if (IsOpen?):
            PrintError("Resource Health Bar is already open")
            return

        set IsOpen = true
        HealthBarBackgroundTextureBlock.SetVisibility(widget_visibility.Visible)
        HealthBarLine.SetVisibility(widget_visibility.Visible)
        BufferedHealthBarLine.SetVisibility(widget_visibility.Visible)
        HealthBarTextBlock.SetVisibility(widget_visibility.Visible)

        if (not AreaBonus = 0.0):
            AreaBonusTextureBlock.SetVisibility(widget_visibility.Visible)
            AreaBonusTextBlock.SetVisibility(widget_visibility.Visible)
        else:
            AreaBonusTextureBlock.SetVisibility(widget_visibility.Hidden)
            AreaBonusTextBlock.SetVisibility(widget_visibility.Hidden)

        if (not Level = 0):
            if (LevelIsHidden?):
                LevelAndNameStackBox.RemoveWidget(NameTextBlock)
                for (StackBoxSlot : LevelAndNameStackBoxSlots):
                    LevelAndNameStackBox.AddWidget(StackBoxSlot)
            set LevelIsHidden = false
            LevelFixedTextBlock.SetVisibility(widget_visibility.Visible)
            LevelTextBlock.SetVisibility(widget_visibility.Visible)
        else:
            LevelAndNameStackBox.RemoveWidget(LevelFixedTextBlock)
            LevelAndNameStackBox.RemoveWidget(LevelTextBlock)
            set LevelIsHidden = true
            LevelFixedTextBlock.SetVisibility(widget_visibility.Hidden)
            LevelTextBlock.SetVisibility(widget_visibility.Hidden)

        if (Name.Length > 0):
            NameTextBlock.SetVisibility(widget_visibility.Visible)
        else:
            NameTextBlock.SetVisibility(widget_visibility.Hidden)

            # AreaBonusTextureBlock.SetVisibility(widget_visibility.Visible)
            # AreaBonusTextBlock.SetVisibility(widget_visibility.Visible)
            # LevelFixedTextBlock.SetVisibility(widget_visibility.Visible)
            # LevelTextBlock.SetVisibility(widget_visibility.Visible)
            # NameTextBlock.SetVisibility(widget_visibility.Visible)
        set CurrentTimer = HealthBarLength

    Close() : void =
        HealthBarLine.SetDesiredSize(vector2{X:=HealthBarBackgroundTextureBlock.GetDesiredSize().X, Y:=HealthBarLine.GetDesiredSize().Y})
        BufferedHealthBarLine.SetDesiredSize(vector2{X:=HealthBarBackgroundTextureBlock.GetDesiredSize().X, Y:=HealthBarLine.GetDesiredSize().Y})

        set CurrentTimer = 0.0
        set TargetHealth = 0.0
        set MaxHealth = 0.0
        set BufferedHealth = 0.0
        set DisplayedHealth = 0.0
        
        set AreaBonus = 0.0
        set Level = 0
        set Name = ""

        HealthBarBackgroundTextureBlock.SetVisibility(widget_visibility.Hidden)
        HealthBarLine.SetVisibility(widget_visibility.Hidden)
        BufferedHealthBarLine.SetVisibility(widget_visibility.Hidden)
        HealthBarTextBlock.SetVisibility(widget_visibility.Hidden)
        AreaBonusTextureBlock.SetVisibility(widget_visibility.Hidden)
        AreaBonusTextBlock.SetVisibility(widget_visibility.Hidden)
        LevelFixedTextBlock.SetVisibility(widget_visibility.Hidden)
        LevelTextBlock.SetVisibility(widget_visibility.Hidden)
        NameTextBlock.SetVisibility(widget_visibility.Hidden)
        set IsOpen = false

    Popup(InHealthBarInformation : resource_health_bar_information) : void =
        set CurrentTimer = HealthBarLength

        set TargetHealth = InHealthBarInformation.Health
        set MaxHealth = InHealthBarInformation.MaxHealth
        set BufferedHealth = InHealthBarInformation.OldHealth
        
        set DisplayedHealth = InHealthBarInformation.OldHealth
        set DisplayedSteps = 0
        
        set AreaBonus = InHealthBarInformation.AreaBonus
        set Level = InHealthBarInformation.Level
        set Name = InHealthBarInformation.Name
        
        if (InterpolateText?): # or (InterpolateTextOnlyPositive? and TargetHealth - DisplayedHealth > 0.0)):
            HealthBarTextBlock.SetText(HealthToMessage(DisplayedHealth, MaxHealth)) # (StringToMessage("{DisplayedHealth} / {MaxHealth} "))
        else:
            HealthBarTextBlock.SetText(HealthToMessage(TargetHealth, MaxHealth)) # (StringToMessage("{TargetHealth} / {MaxHealth} "))
            
        NewDesiredSize := (TargetHealth / MaxHealth) * HealthBarBackgroundTextureBlock.GetDesiredSize().X
        HealthBarLine.SetDesiredSize(vector2{X:=NewDesiredSize, Y:=HealthBarLine.GetDesiredSize().Y})

        BufferedDesiredSize := (BufferedHealth / MaxHealth) * HealthBarBackgroundTextureBlock.GetDesiredSize().X
        BufferedHealthBarLine.SetDesiredSize(vector2{X:=BufferedDesiredSize, Y:=HealthBarLine.GetDesiredSize().Y})

        AreaBonusTextBlock.SetText(FloatToPercentMessage(AreaBonus))
        LevelTextBlock.SetText(IntToMessage(Level))
        NameTextBlock.SetText(StringToMessage(Name))

        if (Debug?). Print("Comparing ResourceWrapperIds: {ReferencedResourceWrapper.Id} <> {InHealthBarInformation.ResourceWrapper.Id}")
        if:
            not IsOpen? or
            ReferencedResourceWrapper.Id <> InHealthBarInformation.ResourceWrapper.Id
        then:
            set ReferencedResourceWrapper = InHealthBarInformation.ResourceWrapper
            Open()


    ApproachTargetHealth(Interpolation : float, ?Minimum : float = 0.0, ?Threshold : float = 0.01) : void = 
        if (not IsOpen?):
            PrintError("Tried approaching Target Health while ResourceHealthBar is not open")
            return

        # if (ReferencedResourceWrapper.CurrentHealth <> TargetHealth):
        #     set TargetHealth = ReferencedResourceWrapper.CurrentHealth
    
        if (InterpolateText?): # or (InterpolateTextOnlyPositive? and TargetHealth - DisplayedHealth > 0.0)):
            if (DisplayedSteps < 5):
                set DisplayedHealth = DisplayedHealth + (TargetHealth-DisplayedHealth) * (0.2)
                set DisplayedSteps += 1
                HealthBarTextBlock.SetText(HealthToMessage(DisplayedHealth, MaxHealth))
            else:
                set DisplayedHealth = TargetHealth
                HealthBarTextBlock.SetText(HealthToMessage(DisplayedHealth, MaxHealth))


        if (Abs(TargetHealth - BufferedHealth) < Threshold):
            set BufferedHealth = TargetHealth
        else:
            # set BufferedHealth = BufferedHealth + (TargetHealth-BufferedHealth) * Interpolation
            if (TargetHealth - BufferedHealth > 0.0):
                Sign := 1.0
                set BufferedHealth = BufferedHealth + Min((TargetHealth-BufferedHealth) * Interpolation, Sign*Minimum)
                # Print("pos: {Min((TargetHealth-BufferedHealth) * Interpolation, Sign*Minimum)}")
            else:
                Sign := -1.0
                # Print("neg: {Min((TargetHealth-BufferedHealth) * Interpolation, Sign*Minimum)}")
                set BufferedHealth = BufferedHealth + Min((TargetHealth-BufferedHealth) * Interpolation, Sign*Minimum)

        BufferedDesiredSize := (BufferedHealth / MaxHealth) * HealthBarBackgroundTextureBlock.GetDesiredSize().X
        BufferedHealthBarLine.SetDesiredSize(vector2{X:=BufferedDesiredSize, Y:=HealthBarLine.GetDesiredSize().Y})


        




fixed_ressource_popup_wrapper := class():
    var Canvas : canvas = canvas{}
    Position : vector2 = vector2{}
    PopupLength : float = 0.0
    Anchor : anchors = anchors{Minimum := vector2{X := 0.535, Y := 0.500000}, Maximum := vector2{X := 0.535, Y := 0.500000}}
    HasBackground : logic = true

    var CurrentAmount : float = 0.0
    var CurrentTimer : float = 0.0

    var RessourceTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.IconToiletPaper1
        DefaultDesiredSize := vector2{X:= 58.0, Y:= 58.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    var SplitTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=2.0, Y:=2.0}
        DefaultShadowOpacity := 1.0
        DefaultShadowColor := NamedColors.Black

    var TextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=2.0, Y:=2.0}
        DefaultShadowOpacity := 1.0
        DefaultShadowColor := NamedColors.Black

    var StackBox : stack_box = stack_box{Orientation := orientation.Horizontal}

    var BackgroundTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.IconBackgroundRectangle
        DefaultDesiredSize := vector2{X:= 260.0, Y:= 180.0}


    var Initialized : logic = false
    Initiate() : void = 
        if (Initialized?):
            PrintError("FixedResourcePopupWrapper already initialized")
            return

        SplitTextBlock.SetText(StringToMessage("x"))
        set StackBox = CreateStackBox()
        
        if (HasBackground?):
            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := Position.X, Top := Position.Y}
                    Alignment := vector2{X:=0.0, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 1
                    Widget := BackgroundTextureBlock
            )
        Canvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y}
                Alignment := vector2{X:=0.0, Y:=0.5}
                SizeToContent := true
                ZOrder := 1
                Widget := StackBox
        )
        set Initialized = true
        Close()

    CreateStackBox() : stack_box =
        MyStackBox : stack_box = stack_box:
            Orientation := orientation.Horizontal
            Slots := array:
                stack_box_slot:
                    Widget := RessourceTextureBlock
                    HorizontalAlignment := horizontal_alignment.Fill
                    VerticalAlignment := vertical_alignment.Center
                    Padding := margin{Left := 2.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                stack_box_slot:
                    Widget := SplitTextBlock
                    HorizontalAlignment := horizontal_alignment.Fill
                    VerticalAlignment := vertical_alignment.Center
                    Padding := margin{Left := 5.0, Top := 0.0, Right := 8.0, Bottom := 0.0}
                stack_box_slot:
                    Widget := TextBlock
                    HorizontalAlignment := horizontal_alignment.Fill
                    VerticalAlignment := vertical_alignment.Center
                    Padding := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                    
    var IsOpen : logic = false
    Open() : void = 
        if (PopupLength = 0.0 or not Initialized?):
            PrintError("Fixed Ressource Popup is not initialized correctly")

        if (IsOpen?):
            PrintError("Fixed Resource Popup is already open")
            return

        set IsOpen = true
        StackBox.SetVisibility(widget_visibility.Visible)
        RessourceTextureBlock.SetVisibility(widget_visibility.Visible)
        TextBlock.SetVisibility(widget_visibility.Visible)
        BackgroundTextureBlock.SetVisibility(widget_visibility.Visible)
        

    Close() : void = 
        set CurrentAmount = 0.0
        set IsOpen = false
        StackBox.SetVisibility(widget_visibility.Hidden)
        RessourceTextureBlock.SetVisibility(widget_visibility.Hidden)
        TextBlock.SetVisibility(widget_visibility.Hidden)
        BackgroundTextureBlock.SetVisibility(widget_visibility.Hidden)
        # Canvas.RemoveWidget(StackBox)
        # Canvas.RemoveWidget(BackgroundTextureBlock)
                 
    Popup(Amount : float) : void =
        set CurrentTimer = PopupLength
        set CurrentAmount += Amount
        TextBlock.SetText(AmountToMessage(CurrentAmount)) 
        if (not IsOpen?). Open()


        


dynamic_ressource_popup_wrapper := class():
    Canvas<private> : canvas = canvas{}
    var Position<private> : vector2 = vector2{}
    var RefPlayer<private> : ?player = false

    var Amount : float = 0.0
    MaxWidgetOffset : float = 152.0

    var WidgetOffset : float = 0.0
    var WidgetOpacity : float = 1.0

    var RessourceIconSize : float = 55.0
    MinRessourceIconSize : float = 36.0 
    MaxRessourceIconSize : float = 60.0

    Anchor : anchors = anchors{Minimum := vector2{X := 0.535, Y := 0.500000}, Maximum := vector2{X := 0.535, Y := 0.500000}}

    var StackBox : stack_box = stack_box{Orientation := orientation.Horizontal}

    RessourceTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.IconToiletPaperPopup1
        DefaultDesiredSize := vector2{X:= 55.0, Y:= 55.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    SplitTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=2.0, Y:=2.0}
        DefaultShadowOpacity := 1.0
        DefaultShadowColor := NamedColors.Black

    TextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=2.0, Y:=2.0}
        DefaultShadowOpacity := 1.0
        DefaultShadowColor := NamedColors.Black


    CreateStackBox() : stack_box =
        MyStackBox : stack_box = stack_box:
            Orientation := orientation.Horizontal
            Slots := array:
                stack_box_slot:
                    Widget := RessourceTextureBlock
                    HorizontalAlignment := horizontal_alignment.Fill
                    VerticalAlignment := vertical_alignment.Center
                stack_box_slot:
                    Widget := SplitTextBlock
                    HorizontalAlignment := horizontal_alignment.Fill
                    VerticalAlignment := vertical_alignment.Center
                    Padding := margin{Left := 5.0, Top := 0.0, Right := 5.5, Bottom := 0.0}
                stack_box_slot:
                    Widget := TextBlock
                    HorizontalAlignment := horizontal_alignment.Fill
                    VerticalAlignment := vertical_alignment.Center

    var Initialized : logic = false
    Initiate(InPlayer : player, InPosition : vector2) : void = 
        if (Initialized?):
            PrintError("DynamicResourcePopup already initialized")
            return
        set Initialized = true

        set RefPlayer = option. InPlayer
        set Position = InPosition

    SetTextOpacity(InOpacity : float) : void = 
        var TempOpacity : float = InOpacity
        if (TempOpacity > 1.0):
            set TempOpacity = 1.0
        else if (TempOpacity < 0.0):
            set TempOpacity = 0.0
        FinalOpacity := TempOpacity
        if (Opacity := type{_X:float where _X >= 0.000000, _X <= 1.000000}[FinalOpacity]):    
            TextBlock.SetShadowOpacity(Opacity)
            TextBlock.SetTextOpacity(Opacity)
            SplitTextBlock.SetShadowOpacity(Opacity)
            SplitTextBlock.SetTextOpacity(Opacity)


    var IsOpen : logic = false
    Popup(ZOrder : int, InAmount : float) : void =
        Open(ZOrder, InAmount)
            
    Open(ZOrder : int, InAmount : float) : void = 
        if (not Initialized?):
            PrintError("DynamicResourcePopup is not initialized")
            return
        if (IsOpen?):
            PrintError("DynamicPopupWrapper is already open")
            return
        set Amount = InAmount
        set WidgetOffset = 0.0
        set WidgetOpacity = 1.0
        set RessourceIconSize = MaxRessourceIconSize
        set AnimationFinished = false

        set StackBox = CreateStackBox()
        TextBlock.SetText(AmountToMessage(Amount))
        SplitTextBlock.SetText(StringToMessage("x"))
        StackBox.SetVisibility(widget_visibility.Visible)
        RessourceTextureBlock.SetVisibility(widget_visibility.Visible)
        TextBlock.SetVisibility(widget_visibility.Visible)

        # Canvas.AddWidget(
        #     canvas_slot:
        #         Anchors := Anchor
        #         Offsets := margin{Left := Position.X, Top := Position.Y}
        #         Alignment := vector2{X:=0.0, Y:=0.5}
        #         SizeToContent := true
        #         ZOrder := 0
        #         Widget := StackBox
        # ) 
        var ActualZOrder : type{_X:int where 0 <= _X, _X <= 2147483647} = 2
        if (NewZOrder := type{_X:int where 0 <= _X, _X <= 2147483647}[ZOrder]):
            set ActualZOrder = NewZOrder
        if (Player := RefPlayer?, PlayerUI := GetPlayerUI[Player]):
            PlayerUI.AddWidget(Canvas, player_ui_slot{InputMode:=ui_input_mode.None, ZOrder := ActualZOrder})
        else:
            PrintError("Could not retrieve Player UI")

        set IsOpen = true

    Close() : void = 
        StackBox.SetVisibility(widget_visibility.Hidden)
        RessourceTextureBlock.SetVisibility(widget_visibility.Hidden)
        TextBlock.SetVisibility(widget_visibility.Hidden)
        Canvas.RemoveWidget(StackBox)
        if (Player := RefPlayer?, PlayerUI := GetPlayerUI[Player]):
            PlayerUI.RemoveWidget(Canvas)
        else:
            PrintError("Could not retrieve Player UI")
        set IsOpen = false

    Reset() : void = 
        set Amount = 0.0
        set WidgetOffset = 0.0
        set WidgetOpacity = 1.0
        set RessourceIconSize = MaxRessourceIconSize

        RessourceTextureBlock.SetDesiredSize(vector2{X:=MaxRessourceIconSize, Y:=MaxRessourceIconSize})
        SetTextOpacity(1.0)

        
    var AnimationFinished : logic = false
    Move() : void = 
        if (not IsOpen?):
            return

        Speed : float = 2.0
        Step : float = Speed * MaxWidgetOffset / 100.0
        TotalSteps : float = MaxWidgetOffset / Step
        StepNormalized : float = 1.0 / TotalSteps

        if (not AnimationFinished?):
            set WidgetOffset -= Step
            set WidgetOpacity -= StepNormalized

            if (RessourceIconSize >= MinRessourceIconSize):
                set RessourceIconSize -= StepNormalized * 35.0

            StackBox.SetVisibility(widget_visibility.Hidden)
            Canvas.RemoveWidget(StackBox)
            StackBox.SetVisibility(widget_visibility.Visible)
            
            RessourceTextureBlock.SetDesiredSize(vector2{X:=RessourceIconSize, Y:=RessourceIconSize})
            SetTextOpacity(WidgetOpacity)
            set StackBox = CreateStackBox()

            # MyCanvas : canvas = canvas:
            #     Slots := array:
            #         canvas_slot:
            #             Anchors := Anchor
            #             Offsets := margin{Left := Position.X, Top := Position.Y + WidgetOffset}
            #             Alignment := vector2{X:=0.0, Y:=0.5}
            #             SizeToContent := true
            #             Widget := StackBox
      
            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := Position.X, Top := Position.Y + WidgetOffset}
                    Alignment := vector2{X:=0.0, Y:=0.5}
                    SizeToContent := true
                    Widget := StackBox
            )
            


            # Canvas.AddWidget(
            #     canvas_slot:
            #         Anchors := Anchor
            #         Offsets := margin{Left := Position.X, Top := Position.Y + WidgetOffset}
            #         Alignment := vector2{X:=0.0, Y:=0.5}
            #         SizeToContent := true
            #         Widget := StackBox
            # )
            if (WidgetOffset < -MaxWidgetOffset):
                set AnimationFinished = true
                # Sleep(0.0)
        else:
            Close()
        
    # PopupSuspended()<suspends> : void =
    #     set AnimationFinished = false
    #     Speed : float = 2.0
    #     Step : float = Speed * MaxWidgetOffset / 100.0
    #     TotalSteps : float = MaxWidgetOffset / Step
    #     StepNormalized : float = 1.0 / TotalSteps

    #     loop:
    #         if (AnimationFinished?). break
    #         set WidgetOffset -= Step
    #         set WidgetOpacity -= StepNormalized

    #         if (RessourceIconSize >= MinRessourceIconSize):
    #             set RessourceIconSize -= StepNormalized * 35.0

    #         StackBox.SetVisibility(widget_visibility.Hidden)
    #         Canvas.RemoveWidget(StackBox)
    #         StackBox.SetVisibility(widget_visibility.Visible)
            
    #         RessourceTextureBlock.SetDesiredSize(vector2{X:=RessourceIconSize, Y:=RessourceIconSize})
    #         SetTextOpacity(WidgetOpacity)
    #         set StackBox = CreateStackBox()

    #         Canvas.AddWidget(
    #             canvas_slot:
    #                 Anchors := Anchor
    #                 Offsets := margin{Left := Position.X, Top := Position.Y + WidgetOffset}
    #                 Alignment := vector2{X:=0.0, Y:=0.5}
    #                 SizeToContent := true
    #                 Widget := StackBox
    #         )
    #         if (WidgetOffset < -MaxWidgetOffset):
    #             set AnimationFinished = true
    #             Sleep(0.0)
    #     Close()
        

merchant_menu_wrapper := class():

    var AreaTitle : string = ""
    var Cost : int = 0
    var GatherMultiplier : float = 0.0
    var ResourceType : resource_type = resource_type.ToiletPaper

    BackgroundTextureBlock : texture_block = texture_block{DefaultImage:=VerseAssets.Menu}
    AreaPreviewImage : texture_block = texture_block{DefaultImage:=Assets.UI.AreaPreviewImages.toilet_wasteland}

    CloseButton : button_loud = button_loud{}

    UnlockButton : button_quiet = button_quiet{}

    AreaTitleWidget : text_block = text_block{DefaultTextColor := White, DefaultShadowOpacity := 0.0}
    CostHeaderTitleWidget : text_block = text_block{DefaultTextColor := Gray, DefaultShadowOpacity := 0.0}
    GatherMultiplierTitleWidget : text_block = text_block{DefaultTextColor := Gray, DefaultShadowOpacity := 0.0}

    CostHeaderWidget : text_block = text_block{DefaultTextColor := Gray, DefaultShadowOpacity := 0.0}
    GatherMultiplierWidget : text_block = text_block{DefaultTextColor := Gray, DefaultShadowOpacity := 0.0}

    ClosedUIEvent<public> : event(agent) = event(agent){}
    BoughtUIEvent<public> : event(agent) = event(agent){}

    var Canvas : canvas = canvas{}

    var Initialized : logic = false
    Initialize() : void = 
            
        CloseButton.OnClick().Subscribe(Close)
        UnlockButton.OnClick().Subscribe(Buy)

        AreaTitleWidget.SetText(StringToMessage(AreaTitle))
        CostHeaderTitleWidget.SetText(StringToMessage("Cost:"))
        GatherMultiplierTitleWidget.SetText(StringToMessage("Gather Multiplier:"))

        CostHeaderWidget.SetText(IntToMessage(Cost))
        GatherMultiplierWidget.SetText(FloatToMessage(GatherMultiplier))

        UnlockButton.SetText(StringToMessage("UNLOCK"))

        CloseButton.SetText(StringToMessage("CLOSE"))

        Anchor := vector2{X:=0.5, Y:=0.5}
        Alignment := vector2{X:=0.5, Y:=0.5}
        ScreenSize := vector2{X:=1920.0, Y:=1080.0}

        TempCanvas : canvas= canvas:
            Slots := array:
                canvas_slot:
                    Anchors := anchors{Minimum := Anchor, Maximum := Anchor}
                    Offsets := margin{Left := 0.0, Top := 0.0, Right := ScreenSize.X, Bottom := ScreenSize.Y}
                    Alignment := Alignment
                    SizeToContent := false
                    Widget := BackgroundTextureBlock
                    ZOrder := 30000

                canvas_slot:
                    Anchors := anchors{Minimum := Anchor, Maximum := Anchor}
                    Offsets := margin{Left := 0.0, Top := 384.000000, Right := 288.000000, Bottom := 80.000000}
                    Alignment := Alignment
                    SizeToContent := false
                    Widget := CloseButton
                    ZOrder := 30000

                canvas_slot:
                    Anchors := anchors{Minimum := Anchor, Maximum := Anchor}
                    Offsets := margin{Left := 0.0, Top := -395.0, Right := 0.0, Bottom := 0.0}
                    Alignment := Alignment
                    SizeToContent := true
                    Widget := AreaTitleWidget
                    ZOrder := 30000
                
                canvas_slot:
                    Anchors := anchors{Minimum := Anchor, Maximum := Anchor}
                    Offsets := margin{Left := 62.25, Top := 160.5, Right := 0.0, Bottom := 0.0}
                    Alignment := Alignment
                    SizeToContent := true
                    Widget := CostHeaderTitleWidget
                    ZOrder := 30000
                
                canvas_slot:
                    Anchors := anchors{Minimum := Anchor, Maximum := Anchor}
                    Offsets := margin{Left := 156.0, Top := 204.5, Right := 0.0, Bottom := 0.0}
                    Alignment := Alignment
                    SizeToContent := true
                    Widget := GatherMultiplierTitleWidget
                    ZOrder := 30000
                
                canvas_slot:
                    Anchors := anchors{Minimum := Anchor, Maximum := Anchor}
                    Offsets := margin{Left := 490.0, Top := 160.0, Right := 0.0, Bottom := 0.0}
                    Alignment := Alignment
                    SizeToContent := true
                    Widget := CostHeaderWidget
                    ZOrder := 30000
                
                canvas_slot:
                    Anchors := anchors{Minimum := Anchor, Maximum := Anchor}
                    Offsets := margin{Left := 490.0, Top := 205.0, Right := 0.0, Bottom := 0.0}
                    Alignment := Alignment
                    SizeToContent := true
                    Widget := GatherMultiplierWidget
                    ZOrder := 30000
                
                canvas_slot:
                    Anchors := anchors{Minimum := Anchor, Maximum := Anchor}
                    Offsets := margin{Left := -256.0, Top := -230.0, Right := 500.0, Bottom := 265.0}
                    Alignment := Alignment
                    SizeToContent := false
                    Widget := AreaPreviewImage
                    ZOrder := 30000

                canvas_slot:
                    Anchors := anchors{Minimum := Anchor, Maximum := Anchor}
                    Offsets := margin{Left := 276.5, Top := 273.0, Right := 505.000000, Bottom := 50.000000}
                    Alignment := Alignment
                    SizeToContent := false
                    Widget := UnlockButton
                    ZOrder := 30000
                    
        set Canvas = TempCanvas

    Open(Agent : agent, CustomPlayer : custom_player) : void = 
        # PrintUI("Opening Merchant Menu for {PlayerNameToString(Agent)}")
        if (Player := player[Agent], PlayerUI := GetPlayerUI[Player]):
            # BackgroundTextureBlock.SetVisibility(widget_visibility.Visible)
            PlayerUI.AddWidget(Canvas, player_ui_slot{InputMode:=ui_input_mode.All, ZOrder := 30000})

            if(CustomPlayer.HasResource[1.0*Cost, ResourceType]):
                UnlockButton.SetEnabled(true)
                CostHeaderWidget.SetTextColor(White)
            else:
                UnlockButton.SetEnabled(false)
                CostHeaderWidget.SetTextColor(Red)

        else:
            PrintError("Could not retrieve Player UI")
    
    Buy(WidgetMessage : widget_message) : void =
        BoughtUIEvent.Signal(WidgetMessage.Player)


    Close(WidgetMessage : widget_message) : void =
        # PrintUI("Closing Merchant Menu")
        if (PlayerUI := GetPlayerUI[WidgetMessage.Player]):
            PlayerUI.RemoveWidget(Canvas)
            ClosedUIEvent.Signal(WidgetMessage.Player)
        else:
            PrintError("Could not Remove Merchant Menu Widget")


    # Buy1(WidgetMessage : widget_message) : void = 
    #     if (Bought1?):
    #         return
    #     set Bought1 = true
    #     BuyButton1.SetText(StringToMessage("BOUGHT"))

    #     Cost := 600000.0
    #     if:
    #         CustomPlayer := RefGameManager.GetCustomPlayer(WidgetMessage.Player)?
    #         RefGameManager.SpendMoney(Cost, money_type.Money1)?
    #     then:
    #         RefSoundManager.Success(WidgetMessage.Player)
    #         CustomPlayer.UnlockItem(0)



            

ui_manager_device := class(creative_device):

    OnBegin<override>()<suspends>:void=
        block:

    
--- </ui_manager_device.verse> ---
</LUMBERJACK HEROES TYCOON EXAMPLE>

<MINECRAFT RECREATION PROJECT EXAMPLE>
--- <accolades_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }

accolades_manager_device := class(creative_device):

    OnBegin<override>()<suspends> : void =
        block{}--- </accolades_manager_device.verse> ---

--- <audio_manager_device.verse> ---
using { /Verse.org/Simulation }
using { /Fortnite.com/Devices }
using { /Fortnite.com/Game } # May be needed for Agent type, often included implicitly
using { /UnrealEngine.com/Temporary/SpatialMath } # For vector3, transform

# Assume item_type enum is defined globally like this (REMOVE THIS LINE if already defined):
# item_type<public> := enum: Wood, Stone, Metal, Potion, Bandage

# Structure to hold an item type and its specific override sound player
item_sound_override := struct<concrete>:
    @editable
    ItemType<public>:item_type = item_type.None # Default value helps in editor
    @editable
    SoundPlayer<public>:?audio_player_device = false

audio_manager_device := class(creative_device):

    # Base Sounds (Editable Defaults)
    @editable
    BaseEatSound<public>:?audio_player_device = false
    @editable
    BasePlaceSound<public>:?audio_player_device = false
    @editable
    BaseDestroySound<public>:?audio_player_device = false
    @editable
    BasePickupSound<public>:?audio_player_device = false
    @editable
    BaseKillSound<public>:?audio_player_device = false # This is the only one used for kills

    # Override Arrays (Editable Specifics)
    @editable
    PlaceSoundOverrides<public> : []item_sound_override = array{}
    @editable
    DestroySoundOverrides<public> : []item_sound_override = array{}
    # No override array for Kill sound as per requirements

    # --- Lifecycle ---
    OnBegin<override>()<suspends>:void=
        Print("Audio Manager Device Initialized.")
        # You can add validation here if needed, e.g., check if base sounds are set

    # --- Helper Function ---
    # Finds an override sound player for a given item type in a specific override list
    FindOverrideSound(Overrides:[]item_sound_override, TypeToFind:item_type):?audio_player_device =
        for (OverrideEntry : Overrides):
            if (OverrideEntry.ItemType = TypeToFind):
                if (Player := OverrideEntry.SoundPlayer?):
                    return option{Player} # Found a valid override player
                else:
                    # Entry exists for this type, but no player is assigned, treat as not found
                    Print("Warning: Override entry found for {} but SoundPlayer is not set.")
                    return false # Explicitly return false if player is not set for the matching type
        # Looped through all entries, no match found
        return false

    # --- Public Functions ---

    # Plays the eat sound for a specific item type, targeting an agent.
    # Checks overrides first, then falls back to the base eat sound.
    PlayEatSound<public>(PlayerToHear:agent) : void =
        var SoundToPlay:?audio_player_device = false

        # 2. If no override found, use base sound
        if (not SoundToPlay?):
            set SoundToPlay = BaseEatSound

        # 3. Play the sound if one was found
        if (Player := SoundToPlay?):
            Player.Play(PlayerToHear)
        else:
            Print("Audio Manager: Could not find a suitable Eat sound to play for ItemType: {}")

    # Plays the placed sound for a specific item type, targeting an agent.
    # Checks overrides first, then falls back to the base placed sound.
    PlayPlacedSound<public>(ItemType:item_type, PlayerToHear:agent) : void =
        var SoundToPlay:?audio_player_device = false

        # 1. Check for override
        set SoundToPlay = FindOverrideSound(PlaceSoundOverrides, ItemType)

        # 2. If no override found, use base sound
        if (not SoundToPlay?):
            set SoundToPlay = BasePlaceSound

        # 3. Play the sound if one was found
        if (Player := SoundToPlay?):
            Player.Play(PlayerToHear)
        else:
            Print("Audio Manager: Could not find a suitable Place sound to play for ItemType: {}")

    # Plays the pickup sound for a specific item type, targeting an agent.
    # Checks overrides first, then falls back to the base pickup sound.
    PlayPickupSound<public>(PlayerToHear:agent) : void =
        var SoundToPlay:?audio_player_device = false

        # 2. If no override found, use base sound
        if (not SoundToPlay?):
            set SoundToPlay = BasePickupSound

        # 3. Play the sound if one was found
        if (Player := SoundToPlay?):
            Player.Play(PlayerToHear)
        else:
            Print("Audio Manager: Could not find a suitable Pickup sound to play for ItemType: {}")


    PlayDestroyedSound<public>(PlayerToHear : agent, ItemType : item_type) : void =
        var SoundToPlay:?audio_player_device = false

        # 1. Check for override
        set SoundToPlay = FindOverrideSound(DestroySoundOverrides, ItemType)

        # 2. If no override found, use base sound
        if (not SoundToPlay?):
            set SoundToPlay = BaseDestroySound

        # 3. Play the sound if one was found
        if (Player := SoundToPlay?):
            Player.Play(PlayerToHear)
        else:
            Print("Audio Manager: Could not find a suitable Place sound to play for ItemType: {}")
    

    # Plays the kill sound at a specific world location.
    # Always uses the BaseKillSound; no overrides for this event.
    # Note: TeleportTo is a suspending function, so this function must also be <suspends>
    PlayKilledSound<public>(KillLocation:vector3)<suspends> : void =
        if (KillSoundPlayer := BaseKillSound?):
            # TeleportTo requires a transform (position, rotation, scale)
            KillTransform := transform{Translation := KillLocation, Rotation := IdentityRotation(), Scale := vector3{X:=1.0, Y:=1.0, Z:=1.0}}

            # Move the audio player device to the location
            if (KillSoundPlayer.TeleportTo[KillTransform]):
                # Play the sound at the new location (plays for everyone nearby)
                KillSoundPlayer.Play()
            else:
                Print("Audio Manager: Failed to teleport BaseKillSound player.")
        else:
            Print("Audio Manager: BaseKillSound is not set. Cannot play kill sound.")--- </audio_manager_device.verse> ---

--- <block_manager_device.verse> ---

using { /Verse.org/Assets }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Fortnite.com/Characters }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Fortnite.com/Devices/CreativeAnimation }
using { /Fortnite.com/Devices/CreativeAnimation/InterpolationTypes }
using { /Verse.org/Random }



block_type := enum{
    None
    GrassBlock
    Dirt
    Cobblestone

    OakLog
    OakPlanks
    OakLeaves
    OakSapling

    FactoryBlock
    Barrier

    CobblestoneGenerator

    Sand
    Sandstone
    Stone
    Diorite
    GrayConcrete

    CoalOre
    IronOre
    GoldOre
    DiamondOre
    IronOreGenerator
    GoldOreGenerator
    DiamondOreGenerator
    Furnace
    CraftingTable
    Netherrack
    Netherbrick
    Obsidian
    Farmland
    Hayball
    GrassyCobblestone
    GrassyStone
    RottenFleshBlock
    WeaponTable

    IronBlock
    DiamondBlock
    GoldBlock
    CoalBlock

    SpruceLog
    SpruceLeaves
    SpruceSapling

    WhiteWool

    LuckyblockGrappler
    LuckyblockNormal

    StoneBrick
    EmeraldBlock
}


DestroyStageMaterials : []material = array{
    Assets.Materials.M_Transparent
    Assets.Minecraft.Breaking.M_DestroyStage_0
    Assets.Minecraft.Breaking.M_DestroyStage_1
    Assets.Minecraft.Breaking.M_DestroyStage_2
    Assets.Minecraft.Breaking.M_DestroyStage_3
    Assets.Minecraft.Breaking.M_DestroyStage_4
    Assets.Minecraft.Breaking.M_DestroyStage_5
    Assets.Minecraft.Breaking.M_DestroyStage_6
    Assets.Minecraft.Breaking.M_DestroyStage_7
    Assets.Minecraft.Breaking.M_DestroyStage_8
    Assets.Minecraft.Breaking.M_DestroyStage_9
}

OutlineMaterial : material = Assets.Minecraft.UtilityBlockOutlineMaterial
InteractMaterial : material = Assets.Minecraft.InteractMaterial



block_state := enum{
    None
}
collision_type := enum{
    FullCollision
    PlayerOnlyCollision
    RaycastOnlyCollision
    NoCollision
}
orientation_sensitivity_type := enum{
    None
    Yaw
    Full
}

block_asset_wrapper := class<concrete>():
    @editable CreativePropAsset : creative_prop_asset = DefaultCreativePropAsset
    @editable BreakEffectAsset : creative_prop_asset = DefaultCreativePropAsset
    @editable DeathEffectAsset : creative_prop_asset = DefaultCreativePropAsset

lucky_block_item_drop := class<concrete>():
    @editable ItemType<public> : item_type = item_type.None
    @editable DropChance<public> : float = 1.0
    @editable MinAmount<public> : int = 1
    @editable MaxAmount<public> : int = 1

lucky_block_properties := class<concrete>():
    @editable PossibleDrops : []lucky_block_item_drop = array{}

    GrantLoot(InItemManager : item_manager_device, Position : vector3, Impulse : vector2) : void =
        for (Drop : PossibleDrops):
            if (GetRandomFloat(0.0, 1.0) <= Drop.DropChance):
                AmountToDrop : int = GetRandomInt(Drop.MinAmount, Drop.MaxAmount)
                if (AmountToDrop > 0):
                    InItemManager.SpawnItem(Position, Drop.ItemType, ?Amount := AmountToDrop, ?Impulse := Impulse)

block_properties_wrapper := class<concrete>():
    @editable MaybeBlockGenerator : ?block_generator = false
    @editable MaybeLuckyBlock : ?lucky_block_properties = false

    @editable Hardness : float = 1.0
    @editable EfficiencyType : efficiency_type = efficiency_type.None
    @editable RequireEfficientType : logic = false
    @editable RequireMinStrength : ?int = false

    @editable DropItemWhenNotEffcientType : ?item_type = false
    @editable DropItemWhenNotEffcientProbability : ?float = false

    @editable Collision : collision_type = collision_type.FullCollision
    @editable OrientationSensitivity : orientation_sensitivity_type = orientation_sensitivity_type.None




generator_spawnable_item := struct<concrete>:
    @editable ItemType : item_type = item_type.None
    @editable SpawnPriority : int = 1

block_generator := class<unique>():
    @editable SpawnableItems : []generator_spawnable_item = array{}

    GetItemToSpawn()<transacts> : item_type =
        var PrioritySum : int = 0
        for(SpawnableItem : SpawnableItems):
            set PrioritySum += SpawnableItem.SpawnPriority
        var PriorityId : int = GetRandomInt(0, PrioritySum-1)
        # Print("Spawning Priority: {PriorityId}")
        for(SpawnableItem : SpawnableItems):
            set PriorityId -= SpawnableItem.SpawnPriority
            if(PriorityId < 0):
                return SpawnableItem.ItemType
        return item_type.None

block_class := class<concrete>():
    var RefBlockManager<private> : block_manager_device = block_manager_device{}
    var RefItemManager<private> : item_manager_device = item_manager_device{}
    var RefAudioManager<private> : audio_manager_device = audio_manager_device{}

    @editable BlockName<private> : string = ""
    @editable BlockType<private> : block_type = block_type.None
    @editable ItemType<private> : item_type = item_type.None

    @editable BlockProperties<private> : block_properties_wrapper = block_properties_wrapper{}
    @editable BlockAssets<private> : block_asset_wrapper = block_asset_wrapper{}


    AccessItemManager<public>()<transacts> : item_manager_device = RefItemManager
    AccessBlockManager<public>()<transacts> : block_manager_device = RefBlockManager

    GetName<public>()<transacts> : string = BlockName
    GetBlockType<public>()<transacts> : block_type = BlockType
    GetItemType<public>()<transacts> : item_type = ItemType
    GetHardness<public>()<transacts> : float = BlockProperties.Hardness
    GetCollision<public>()<transacts> : collision_type = BlockProperties.Collision

    GetCreativePropAsset<public>()<transacts> : creative_prop_asset = BlockAssets.CreativePropAsset
    GetBreakParticleSystem<public>()<transacts> : creative_prop_asset = BlockAssets.BreakEffectAsset
    GetDeathParticleSystem<public>()<transacts> : creative_prop_asset = BlockAssets.DeathEffectAsset
    GetOrientationSensitivity<public>()<transacts> : orientation_sensitivity_type = BlockProperties.OrientationSensitivity
    GetBlockProperties<public>()<transacts> : block_properties_wrapper = BlockProperties

    GetAudioManager<public>() : audio_manager_device = RefAudioManager

    GetGeneratorItemType<public>()<transacts> : item_type = { if (B := BlockProperties.MaybeBlockGenerator?). return B.GetItemToSpawn() else. return item_type.None }
    IsGenerator<public>()<transacts> : logic = { if (BlockProperties.MaybeBlockGenerator?). return true else. return false }

    GetEfficiencyType<public>()<transacts> : efficiency_type = BlockProperties.EfficiencyType
    GetRequiredMinStrength<public>()<decides><transacts> : int = return BlockProperties.RequireMinStrength?
    IsEfficiencyTypeRequired<public>()<decides><transacts> : decides_result = { var D: ?decides_result = false; if (BlockProperties.RequireEfficientType?). set D = option. decides_result{}; return D? }
    GetMiningEfficiencyForItem<public>(InItem : item_instance)<transacts> : float =
        if (InItem.GetItemProperties().EfficiencyType = BlockProperties.EfficiencyType, Efficiency := InItem.GetItemProperties().MiningEfficiency?):
            return Efficiency
        return 1.0

    IsType<public>(CheckBlockType : block_type)<transacts> : logic = { if (BlockType = CheckBlockType). return true; return false }
    IsType<public>(BlockTypes : []block_type)<transacts> : logic = { for (CheckBlockType : BlockTypes, BlockType = CheckBlockType). return true; return false}
    HasPlayerCollision<public>()<transacts> : logic = if (BlockProperties.Collision = collision_type.FullCollision or BlockProperties.Collision = collision_type.PlayerOnlyCollision). return true else. return false

    IsSpecialBlock<public>()<transacts> : logic =
        if (BlockType = block_type.CraftingTable):
            return true
        if (BlockType = block_type.Furnace):
            return true
        return false

    var Initialized<private> : logic = false
    Initiate<public>(InBlockManager : block_manager_device, InItemManagager : item_manager_device, AudioManager : audio_manager_device) : void =
        if (Initialized?). Assert("{BlockName} is already initialized")
        set RefItemManager = InItemManagager
        set RefBlockManager = InBlockManager
        set RefAudioManager = AudioManager

        if:
            not IsEfficiencyTypeRequired[]
            GetRequiredMinStrength[]
        then:
            Assert("Block \"{BlockName}\" is not set up correctly. EfficiencyType is not required but MinStrength is set")




block_instance := class<unique>():
    __Class : block_class
    __Indestructable : logic = false

    var State<private> : block_state = block_state.None

    var GridPosition<private> : vector3i = vector3i{}

    var CreationTime<private> : ?float = false
    var CreativeProp<private> : ?creative_prop = false
    var OriginalTransform<private> : ?transform = false

    MinedEvent<public> : event() = event(){}
    var SubscribedToMineEvent<public> : logic = false
    var HasBeenDestroyed<public> : logic = false
    var CurrentBreakingStage<private> : int = 0
    var MaybeOnDestroyEvent : ?event(increase_event_data) = false

    var SpecialBlockId : int = -1

    GetName<public>()<transacts> : string = __Class.GetName()
    GetBlockType<public>()<transacts> : block_type = __Class.GetBlockType()
    GetItemType<public>()<transacts> : item_type = __Class.GetItemType()
    GetHardness<public>()<transacts> : float = __Class.GetHardness()
    GetCollision<public>()<transacts> : collision_type = __Class.GetCollision()
    GetGridPosition<public>()<transacts> : vector3i = GridPosition
    GetClass<public>()<transacts> : block_class = __Class
    GetCreativeProp()<transacts><decides> : creative_prop = CreativeProp?
    GetCreationTime<public>()<decides><transacts> : float = CreationTime?

    GetBlockProperties<public>()<transacts> : block_properties_wrapper = __Class.GetBlockProperties()
    GetCurrentBreakingStage<public>()<transacts> : int = CurrentBreakingStage

    GetMiningEfficiencyForItem<public>(InItem : item_instance)<transacts> : float = __Class.GetMiningEfficiencyForItem(InItem)
    GetEfficiencyType<public>()<transacts> : efficiency_type = __Class.GetEfficiencyType()
    GetRequiredMinStrength<public>()<decides><transacts> : int = __Class.GetRequiredMinStrength[]
    IsEfficiencyTypeRequired<public>()<decides><transacts> : decides_result = __Class.IsEfficiencyTypeRequired[]
    IsSpecialBlock<public>()<transacts> : logic = __Class.IsSpecialBlock()


    Spawn<public>(InGridPosition : vector3i, ?InRotation : rotation = IdentityRotation(), ?InScale : vector3 = vector3{X:=1.0, Y:=1.0, Z:=1.0}, ?InSpecialBlockId : int = -1) : void =
        set GridPosition = InGridPosition
        __Class.AccessBlockManager().AddBlockToMap(Self)
        set SpecialBlockId = InSpecialBlockId
        SpawnCreativeProp(InGridPosition, ?InRotation := InRotation, ?InScale := InScale)


    SpawnCreativeProp(InGridPosition : vector3i, ?InRotation : rotation = IdentityRotation(), ?InScale : vector3 = vector3{X:=1.0, Y:=1.0, Z:=1.0}) : void =
        var UsedRotation : rotation = InRotation
        if (not __Class.GetOrientationSensitivity() = orientation_sensitivity_type.None):
            set UsedRotation = IdentityRotation()
        else if:
            not __Class.GetOrientationSensitivity() = orientation_sensitivity_type.Yaw
            Yaw := UsedRotation.GetYawPitchRollDegrees()[0]
        then:
            # Zero : type{0.000000} = 0.000000 
            set UsedRotation = MakeRotationFromYawPitchRollDegrees(Yaw, 0.0, 0.0)


        Transform := transform:
            Translation := G2W(InGridPosition)
            Rotation := UsedRotation
            Scale := vector3{X:=0.1, Y:=0.1, Z:=0.1}

        SpawnPropResult := SpawnProp(__Class.GetCreativePropAsset(), Transform)
        if (SpawnPropResult(1) = spawn_prop_result.TooManyProps):
            Assert("Could not spawn Item because there are too many Props")
        else if (SpawnPropResult(1) = spawn_prop_result.SpawnPointOutOfBounds):
            Assert("Could not spawn Item because Spawn Point is out of Bounds")
        else if (SpawnPropResult(1) = spawn_prop_result.InvalidSpawnPoint):
            Assert("Could not spawn Item because Spawn Point is invalid")
        else if (SpawnPropResult(1) = spawn_prop_result.UnknownError):
            Assert("Could not spawn Item because of unknown error")
        else if:
            SpawnPropResult(1) = spawn_prop_result.Ok
            SpawnedCreativeProp := SpawnPropResult(0)?
            AnimationController := SpawnedCreativeProp.GetAnimationController[]
        then:
            MovementKeyFrame : keyframe_delta = keyframe_delta {
                DeltaLocation := vector3{}
                DeltaRotation := rotation{}
                DeltaScale := vector3{X:=10.0, Y:=10.0, Z:=10.0}
                Time := 0.075
                Interpolation := EaseIn
            }
            FortVaderKeyFrames : []keyframe_delta = array. MovementKeyFrame
            AnimationController.Stop()
            AnimationController.SetAnimation(FortVaderKeyFrames, ?Mode := animation_mode.OneShot)
            AnimationController.Play()
            set CreativeProp = option. SpawnedCreativeProp
            set OriginalTransform = option. Transform

            BaseCreationTime := GetSecondsSinceEpoch()
            CreationTimeOffset := GetRandomFloat(RANDOM_CREATION_TIME_OFFSET_LOWER, RANDOM_CREATION_TIME_OFFSET_HIGHER)
            # Print("BaseCreationTime: {BaseCreationTime} + {CreationTimeOffset}")
            set CreationTime = option. BaseCreationTime + CreationTimeOffset
        else:
            Assert("Could not spawn {__Class.GetName()}")




    Destroy<public>(Agent : agent, ?MaybeTool : ?item_instance = false) : void =
        ThrowStrength : float = 100.0
        if (FortCharacter := Agent.GetFortCharacter[]):
            PlayerPosition := vector2{X:=FortCharacter.GetTransform().Translation.X, Y:=FortCharacter.GetTransform().Translation.Y}
            ItemPosition := vector2{X:=G2W(GetGridPosition()).X, Y:=G2W(GetGridPosition()).Y}

            if(DirectionVector : vector2 = (PlayerPosition-ItemPosition).MakeUnitVector[]):
                Destroy(?Impulse := DirectionVector*ThrowStrength, ?MaybeTool := MaybeTool)

            __Class.GetAudioManager().PlayDestroyedSound(Agent, __Class.GetItemType())

        if (OnDestroyEvent := MaybeOnDestroyEvent?):
            OnDestroyEvent.Signal(increase_event_data{Agent:=Agent, Amount:=1, Value:=__Class.GetName(), Type:=quest_type.Destroy})


    Destroy(?Drop : logic = true,  ?Impulse : vector2 = vector2{X := 0.0, Y := 0.0}, ?MaybeTool : ?item_instance = false) : void =
        MinedEvent.Signal()
        ParticleSystem := __Class.GetDeathParticleSystem()
        SpawnParticleSystem(ParticleSystem, G2W(GridPosition))

        var DropItem : logic = true
        if (Drop?):
            if (IsEfficiencyTypeRequired[]):
                var CanMine : logic = false
                if (Tool := MaybeTool?):
                    if (MinStrength := GetRequiredMinStrength[], Strength := Tool.GetStrength[]):
                        if (Strength > MinStrength):
                            set CanMine = true
                    else:
                        RequiredEfficiencyType := GetEfficiencyType()
                        if (RequiredEfficiencyType <> efficiency_type.None and RequiredEfficiencyType = Tool.GetEfficiencyType()):
                            set CanMine = true
                if (CanMine?):
                    set DropItem = true
                else:
                    set DropItem = false


        if(__Class.IsGenerator()?):
            if (Drop? and DropItem?):
                __Class.AccessItemManager().SpawnItem(G2W(GridPosition), __Class.GetGeneratorItemType(), ?Amount := 1, ?MaybeApexHeightOffsetMultiplier:=option{1.3}, ?Impulse:=Impulse)

            if (Cp := CreativeProp?). Cp.Dispose()
            set CreativeProp = false
            set CreationTime = false
            Delay : float = 1.0
            Suspend(Respawn, Delay)
        else if (LuckyBlockProps := GetBlockProperties().MaybeLuckyBlock?):
            if (Drop?):
                LuckyBlockProps.GrantLoot(__Class.AccessItemManager(), G2W(GridPosition), Impulse)
            if (Cp := CreativeProp?). Cp.Dispose()
            set HasBeenDestroyed = true
            __Class.AccessBlockManager().RemoveBlockFromMap(Self)
        else:
            set HasBeenDestroyed = true
            if (Cp := CreativeProp?). Cp.Dispose()
            if:
                Drop?
            then:
                if (DropItem?):
                    __Class.AccessItemManager().SpawnItem(G2W(GridPosition), __Class.GetItemType(), ?Amount := 1)
                else if (AlternativeItemType := GetBlockProperties().DropItemWhenNotEffcientType?, GetRandomFloat(0.0, 1.0) <= GetBlockProperties().DropItemWhenNotEffcientProbability?):
                    __Class.AccessItemManager().SpawnItem(G2W(GridPosition), AlternativeItemType, ?Amount := 1)
            __Class.AccessBlockManager().RemoveBlockFromMap(Self)


    Respawn<public>() : void =
        if:
            not CreativeProp?
            T := OriginalTransform?
        then:
            SpawnCreativeProp(W2G(T.Translation), ?InRotation := T.Rotation, ?InScale := T.Scale)
            set HasBeenDestroyed = false
        # else:
            # PrintError("Cannot Respawn Block since Block is still active")

    Reset<public>() : void =
        set CurrentBreakingStage = 0
        SetBreakingStage(0)

    InteractHighlight<public>()<transacts> : void =
        if:
            Cp := CreativeProp?
        then:
            Cp.SetMaterial(InteractMaterial, ?Index := 0)


    Mine<public>(Agent : agent, ?MaybeTool : ?item_instance = false, ?FirstHit : logic = false) : logic =
        if (__Indestructable?):
            return false

        var HoldsSword : logic = false
        if:
            Tool := MaybeTool?
            Tool.GetEfficiencyType() = efficiency_type.Sword
        then:
            set HoldsSword = true

        if (FirstHit?):
            set CurrentBreakingStage = 0
            SetBreakingStage(CurrentBreakingStage)

        if (__Class.GetHardness() = 0.0):
            Destroy(Agent, ?MaybeTool := MaybeTool)
            return true

        if (HoldsSword?):
            set CurrentBreakingStage = 1
        else:
            set CurrentBreakingStage += 1
        if (CurrentBreakingStage = DestroyStageMaterials.Length):
            Destroy(Agent, ?MaybeTool := MaybeTool)
            return true
        else:
            ParticleSystem := __Class.GetBreakParticleSystem()
            SpawnParticleSystem(ParticleSystem, G2W(GridPosition))
            SetBreakingStage(CurrentBreakingStage)
        return false

    SetBreakingStage<private>(BreakingStage : int) : void =
        if:
            Material := DestroyStageMaterials[BreakingStage]
            Cp := CreativeProp?
        then:
            Cp.SetMaterial(Material, ?Index := 0)

    Scale<private>(NewScale : float, Time : float, ?InterpolationType : cubic_bezier_parameters = InterpolationTypes.EaseIn, ?ForceAnimation : logic = false) : void =
        if:
            OldTransform := CreativeProp?.GetTransform()
        then:
            var CalculatedScale : vector3 = vector3{X:=NewScale, Y:=NewScale, Z:=NewScale} / OldTransform.Scale

            MovementKeyFrame: keyframe_delta = keyframe_delta {
                DeltaLocation := vector3{}
                DeltaRotation := rotation{}
                DeltaScale := CalculatedScale
                Time := Time
                Interpolation := InterpolationType
            }
            if:
                AnimationController := CreativeProp?.GetAnimationController[]
                AnimationState := AnimationController.GetState()
                not AnimationState = animation_controller_state.Playing or ForceAnimation?
            then:
                if (ForceAnimation?). AnimationController.Stop()
                FortVaderKeyFrames : []keyframe_delta = array{MovementKeyFrame}
                AnimationController.SetAnimation(FortVaderKeyFrames, ?Mode:=animation_mode.OneShot)
                AnimationController.Play()
            else:
                PrintError("Block is already playing an Animation")


    Animate<private>(Transform : transform, Time : float, ?InterpolationType : cubic_bezier_parameters = InterpolationTypes.EaseIn, ?ForceAnimation : logic = false) : void =
        if:
            OldTransform := CreativeProp?.GetTransform()
        then:
            MovementKeyFrame: keyframe_delta = keyframe_delta {
                DeltaLocation := Transform.Translation-OldTransform.Translation
                DeltaRotation := Transform.Rotation
                DeltaScale := Transform.Scale/OldTransform.Scale
                Time := Time
                Interpolation := InterpolationType
            }
            if:
                AnimationController := CreativeProp?.GetAnimationController[]
                AnimationState := AnimationController.GetState()
                not AnimationState = animation_controller_state.Playing or ForceAnimation?
            then:
                if (ForceAnimation?):
                    AnimationController.Stop()
                FortVaderKeyFrames : []keyframe_delta = array{MovementKeyFrame}
                AnimationController.SetAnimation(FortVaderKeyFrames, ?Mode:=animation_mode.OneShot)
                AnimationController.Play()
            else:
                PrintError("Block is already playing an Animation")
            set GridPosition = GetGridPosition(Transform.Translation)



    IsType<public>(BlockType : block_type)<transacts> : logic = __Class.IsType(BlockType)
    IsType<public>(BlockTypes : []block_type)<transacts> : logic = __Class.IsType(BlockTypes)



















block_utility_wrapper := class():
    BlockHighlightCreativeProp : creative_prop
    InteractHighlightCreativeProp : creative_prop

    RefRaycastManager : raycast_manager_device
    RefBlockManager : block_manager_device
    var GridPosition : ?vector3i = false
    var MaybeOldBlock : ?block_instance = false

    var IsHiddenHighlightBlock : logic = false
    HideHightlightBlock() : void =
        if (IsHiddenHighlightBlock?):
            return
        set IsHiddenHighlightBlock = true
        set GridPosition = false
        BlockHighlightCreativeProp.Hide()
        if (BlockHighlightCreativeProp.TeleportTo[OUT_OF_BOUNDS, rotation{}]) {}

    ShowHightlightBlock() : void =
        if (not IsHiddenHighlightBlock?):
            return
        set IsHiddenHighlightBlock = false
        BlockHighlightCreativeProp.Show()

    var IsHiddenHighlightInteract : logic = false

    HideHightlightInteract() : void =
        if (IsHiddenHighlightInteract?):
            return
        set IsHiddenHighlightInteract = true
        InteractHighlightCreativeProp.Hide()
        if (InteractHighlightCreativeProp.TeleportTo[OUT_OF_BOUNDS, rotation{}]) {}

    ShowHightlightInteract() : void =
        if (not IsHiddenHighlightInteract?):
            return
        set IsHiddenHighlightInteract = false
        InteractHighlightCreativeProp.Show()


    Update(CustomPlayer : custom_player)<suspends> : void =
        RaycastHitResult : raycast_hit_result = RefRaycastManager.RaycastAlternative(CustomPlayer.RefPlayer, CustomPlayer.IsFirstPerson)
        if (RaycastHitResult.HasHit?):
            HighlightTargetBlock(RaycastHitResult)
            HideHightlightBlock()
        else:
            HighlightBridgeBlock(CustomPlayer)
            HideHightlightInteract()

    HighlightTargetBlock(RaycastHitResult : raycast_hit_result)<suspends> : void =
        MaybeTargetBlock := RefBlockManager.GetBlock(RaycastHitResult)
        if:
            TargetBlock := MaybeTargetBlock?
        then:
            if:
                OldBlock := MaybeOldBlock?
                OldBlock = TargetBlock
            then:
                return

            if:
                TargetBlock.IsSpecialBlock()?
                InteractPosition := TargetBlock.GetGridPosition()
            then:
                if (InteractHighlightCreativeProp.TeleportTo[G2W(InteractPosition), IdentityRotation()]) {}
                # Print("Is Special Block")
                ShowHightlightInteract()


            set MaybeOldBlock = MaybeTargetBlock
        else if (OldBlock := MaybeOldBlock?):
                HideHightlightInteract()
                OldBlock.Reset()
                set MaybeOldBlock = false

    HighlightBridgeBlock(CustomPlayer : custom_player)<suspends> : void =
        if:
            Item := CustomPlayer.GetActiveItem[]
            Item.GetBlockType() <> block_type.None
            MaybeFortCharacter := CustomPlayer.RefPlayer.GetFortCharacter[]
            FortCharacter := MaybeFortCharacter
            CharTransform := FortCharacter.GetTransform()
            CharViewRotation := FortCharacter.GetViewRotation()
            Pitch := CharViewRotation.GetYawPitchRollDegrees()[1]
        then:
            if (Pitch < BRIDGE_FORWARD_LOWER_ANGLE or Pitch > BRIDGE_FORWARD_HIGHER_ANGLE):
                HideHightlightBlock()
                return
            ForwardVector := CharViewRotation.GetLocalForward()
            var AddVector : vector3i = vector3i{}
            HeightOffset := -1

            if (Abs(ForwardVector.X) > Abs(ForwardVector.Y)):
                XSign := if (ForwardVector.X > 0.0) then 1 else -1
                set AddVector = vector3i{X:=XSign, Y:=0, Z:=HeightOffset }
            else:
                YSign := if (ForwardVector.Y > 0.0) then 1 else -1
                set AddVector = vector3i{X:=0, Y:=YSign, Z:=HeightOffset }

            CurrentGridPos := W2G(CharTransform.Translation)
            PlacePosition := CurrentGridPos.Add(AddVector)

            if (GridPosition?.X = PlacePosition.X and GridPosition?.Y = PlacePosition.Y and GridPosition?.Z = PlacePosition.Z):
                return
            if (not RefBlockManager.GetBlock(CurrentGridPos.Add(vector3i{X:=0, Y:=0, Z:=-1}))?):
                HideHightlightBlock()
                return
            if (RefBlockManager.GetBlock(PlacePosition)?):
                HideHightlightBlock()
                return

            if (BlockHighlightCreativeProp.TeleportTo[G2W(PlacePosition), IdentityRotation()]):
                set GridPosition = option{PlacePosition}
                ShowHightlightBlock()
            else:
                HideHightlightBlock()
        else:
            HideHightlightBlock()




block_manager_device := class(creative_device):
    @editable GameManager : game_manager_device = game_manager_device{}
    @editable ItemManager : item_manager_device = item_manager_device{}
    @editable RaycastManager : raycast_manager_device = raycast_manager_device{}
    @editable StructureManager : structure_manager_device = structure_manager_device{}
    @editable AudioManager : audio_manager_device = audio_manager_device{}
    @editable FurnaceManager : furnace_manager_device = furnace_manager_device{}

    @editable TestButton : button_device = button_device{}


    @editable BlockHighlightCreativePropAsset : creative_prop_asset = DefaultCreativePropAsset
    @editable InteractHighlightCreativePropAsset : creative_prop_asset = DefaultCreativePropAsset

    @editable ShowRaycastArrow : logic = false
    @editable ArrowProp : creative_prop = creative_prop{}

    var __BlockClasses : []block_class = array{}

    @editable BlockClasses : []block_class = array{}
    @editable UtilityBlockClasses : []block_class = array{}


    TREE_GROW_TIME : float = 20.0


    InitializedEvent<public> : event() = event(){}
    var IsInitialized<public> : logic = false

    OnBegin<override>()<suspends> : void =
        set __BlockClasses += BlockClasses
        set __BlockClasses += UtilityBlockClasses

        for (I->BlockClass : __BlockClasses):
            if (BlockClass.GetBlockType() = block_type.None):
                Assert("BlockClasses are not set up correctly. BlockClass with ItemType \"None\" found")
            for (J->OtherBlockClass : __BlockClasses, I <> J, BlockClass.GetBlockType() = OtherBlockClass.GetBlockType()):
                Assert("BlockClasses are not set up correctly. Two BlockClasses share the same BlockType \"{BlockClass.GetName()}\"")
            BlockClass.Initiate(Self, ItemManager, AudioManager)

        spawn. HandleBlocks()

        TestButton.InteractedWithEvent.Subscribe(TestButtonFunction)

        InitializedEvent.Signal()
        set IsInitialized = true

    TestButtonFunction(Agent : agent) : void =
        block:

    CheckReference<public>() : void = { if (__BlockClasses.Length < 1). Assert("Reference to BlockManager is not set up properly"); }





    var BlocksToRegenerate : []regenerative_block_wrapper = array{}


    CreateBlock(BlockType : block_type, ?Indestructable : logic = false)<decides><transacts> : block_instance =
        var MaybeBlock : ?block_instance = false
        if:
            Class := GetBlockClass[BlockType]
        then:
            Block := block_instance:
                __Class := Class
                __Indestructable := Indestructable
            set MaybeBlock = option. Block
        return MaybeBlock?


    SpawnBlock(BlockType : block_type, GridPosition : vector3i, Rotation : rotation, ?Indestructable : logic = false, ?RespawnTime : ?float = false) : void =
        if:
            Block : block_instance = CreateBlock[BlockType, ?Indestructable := Indestructable]
        then:
            Block.Spawn(GridPosition, ?InRotation := Rotation)

        if (RegenerativeTime := RespawnTime?):
            RegenerativeBlock := regenerative_block_wrapper:
                GridPosition := GridPosition
                BlockType := BlockType
                DestroyedTime := false
                RegenerativeTime := RegenerativeTime
            set BlocksToRegenerate += array. RegenerativeBlock


    SpawnBlock(BlockType : block_type, GridPosition : vector3i) : void =
        if:
            Block : block_instance = CreateBlock[BlockType]
        then:
            Block.Spawn(GridPosition)

    SpawnBlock(BlockClass : block_class, GridPosition : vector3i) : void =
        Block := block_instance:
            __Class := BlockClass
        Block.Spawn(GridPosition)

    SpawnBlock(BlockClass : block_class, GridPosition : vector3i, Rotation : rotation) : void =
        Block := block_instance:
            __Class := BlockClass

        if(Block.GetBlockType() = block_type.Furnace):
            FurnaceInterface := furnace_interface:
                        RefItemManager := FurnaceManager.ItemManager
                        CookItemFunction:=FurnaceManager.CookItem
                        GetRecipesFunction:=FurnaceManager.GetCraftableRecipes
                        CollectItemFunction:=FurnaceManager.CollectItem
                        TimeToCook := FurnaceManager.TIME_TO_COOK

            FurnaceInterface.Initialize()
            FurnaceId := FurnaceManager.AddFurnace(FurnaceInterface)
            # Print("Spawned furnace: {FurnaceId}")
            Block.Spawn(GridPosition, ?InRotation := Rotation, ?InSpecialBlockId := FurnaceId)
        else:
            Block.Spawn(GridPosition, ?InRotation := Rotation)













    BuildPrebuildBlocks(BlockTypes : block_type, PrebuildBlocks : []creative_prop, ?Indestructable : logic = false, ?RespawnTime : ?float = false) : void =
        for (PrebuildBlock : PrebuildBlocks) {
            Transform := PrebuildBlock.GetTransform()
            PlacePosition := W2G(Transform.Translation)
            PlaceRotation :=  Transform.Rotation
            SpawnBlock(BlockTypes, PlacePosition , rotation{}, ?Indestructable := Indestructable, ?RespawnTime := RespawnTime)
        }




































    PlayMineSound(Block : block_instance) : void =
        block:

    PlayDestriySound(Block : block_instance) : void =
        block:


    CheckForSpecialBlock<public>(CustomPlayer : custom_player, GridPosition : vector3i) : logic =
        if (Block := GetBlockFromMap[GridPosition]):
            if (Block.GetBlockType() = block_type.CraftingTable):
                CustomPlayer.OpenCraftingTable()
                return true
            else if (Block.GetBlockType() = block_type.Furnace):
                CustomPlayer.OpenFurnace(Block.SpecialBlockId)
                return true
        return false


    CheckForPlacement(BlockClass : block_class, GridPosition : vector3i)<transacts> : logic =
        return true











    GetTargetBlock(Agent : agent, IsFirstPerson : logic)<suspends> : ?block_instance =
        RaycastHitResult : raycast_hit_result = RaycastManager.Raycast(Agent, IsFirstPerson)
        return GetBlock(RaycastHitResult)

    GetBlock(RaycastHitResult : raycast_hit_result): ?block_instance =
        if (not RaycastHitResult.HasHit?):
            return false

        var RaycastPosition : vector3 = RaycastHitResult.HitPosition
        var RaycastNormal : vector3 = RaycastHitResult.HitNormal
        var RaycastRotation : rotation = RaycastHitResult.HitRotation

        var GridPosition : vector3i = GetGridPosition(RaycastPosition)
        var GridRotation : rotation = IdentityRotation()
        var MaybeBlock : ?block_instance = false

        if (NewBlock := GetBlockFromMap[GridPosition]):
            set MaybeBlock = option. NewBlock
        else:
            set GridPosition = WorldToGridPosition(GridToWorldPosition(GridPosition) - RaycastNormal * GRID_SIZE)
            if (NewBlock := GetBlockFromMap[GridPosition]). set MaybeBlock = option. NewBlock

        var ArrowPosition : vector3 = GridToWorldPosition(GridPosition) + RaycastNormal * 128.0
        if (ShowRaycastArrow?):
            if (ArrowProp.TeleportTo[ArrowPosition, RaycastRotation.ApplyYaw(DegreesToRadians(180.0))]) {}
        if:
            Block := MaybeBlock?
            Block.GetBlockType() <> block_type.None
        then:
            return option. Block
        else:
            block{}
        return false

    GetBlock(InGridPosition : vector3i)<transacts> : ?block_instance =
        var GridPosition : vector3i = InGridPosition
        var MaybeBlock : ?block_instance = false
        if (NewBlock := GetBlockFromMap[GridPosition]):
            return option. NewBlock
        return false



    IsValid(Block : block_instance)<transacts> : logic =
        if (Block.GetBlockType() = block_type.None):
            return false
        else:
            return true


    var BlockMap : [string]?block_instance = map{}
    DestroyedBlockEvent : event(increase_event_data) = event(increase_event_data){}

    GetBlockClass(BlockType : block_type)<transacts><decides> : block_class =
        var MaybeBlockClass : ?block_class = false
        for (BlockClass : __BlockClasses, BlockClass.GetBlockType() = BlockType, not MaybeBlockClass?):
            set MaybeBlockClass = option. BlockClass
        return MaybeBlockClass?

    BlockTypeToString(BlockType : block_type) : string =
        for (BlockClass : __BlockClasses, BlockClass.GetBlockType() = BlockType):
            return BlockClass.GetName()
        return ""

    AddBlockToMap(Block : block_instance) : void =
        Index := GridToIndex(Block.GetGridPosition())
        if (DEBUG?). Print("Trying to add Block to Map[{Index}]")
        if (set BlockMap[Index] = option. Block):
            if (DEBUG?). Print("Succesfully added Block to Map[{Index}]")
            set Block.MaybeOnDestroyEvent = option{DestroyedBlockEvent}
        else:
            Assert("Could not add Block to Map at Index: {GridPositionToIndex(Block.GetGridPosition())}")


    CountSurroundingBlocks(GridPosition : vector3i, BlockType : block_type)<transacts> : int =
        var Count : int = 0
        for (Z := 0..2):
            for (Y := 0..2):
                for (X := 0..2):
                    Offset := vector3i{X:=X-1, Y:=Y-1, Z:=Z-1}
                    # # Print("Checking: {X}-{Y}-{Z}")
                    CheckPosition := GridPosition.Add(Offset)
                    if:
                        Block := GetBlockFromMap[CheckPosition]
                        Block.GetBlockType() = BlockType
                    then:
                        set Count += 1
        return Count


    GetBlockFromMap(GridPosition : vector3i)<decides><transacts> : block_instance =
        Index := GridPositionToIndex(GridPosition)
        if (DEBUG?). Print("Trying to get Block to Map[{Index}]")

        var MaybeBlock : ?block_instance = false
        if (Block := BlockMap[Index]):
            if (DEBUG?). Print("Succesfully got Block from Map[{Index}]")
            set MaybeBlock = Block
        return MaybeBlock?

    GetBlockFromMapIndex(Index : string)<decides><transacts> : block_instance =
        var MaybeBlock : ?block_instance = false
        if (Block := BlockMap[Index]):
            set MaybeBlock = Block
        return MaybeBlock?


    RemoveBlockFromMap(Block : block_instance) : void =
        Index := GridPositionToIndex(Block.GetGridPosition())
        RemoveBlockFromMapIndex(Index)

    RemoveBlockFromMapGrid(GridPosition : vector3i) : void =
        Index := GridPositionToIndex(GridPosition)
        RemoveBlockFromMapIndex(Index)

    RemoveBlockFromMapIndex(Index : string) : void =
        if (set BlockMap[Index] = false) {}
        else. Assert("Could not remove Block from BlockMap")


    HandleBlocks()<suspends> : void =
        FrameTime := 0.0

        var Cycles : int = 0
        var StartTime : float = GetSecondsSinceEpoch()
        var PrintCycle : logic = true



        loop:
            if (PROFILE_PERFORMANCE?):
                if (PrintCycle?):
                    set Cycles += 1
                    if (GetSecondsSinceEpoch() - StartTime > 30.0):
                        # Print("Did {Cycles} Cycles in 30 Seconds. HandleBlocks()")
                        set PrintCycle = false

            for:
                BlockToRegenerate : BlocksToRegenerate
                not GetBlock(BlockToRegenerate.GridPosition)?
            do:
                if (DestroyedTime := BlockToRegenerate.DestroyedTime?):
                    # Print("Regeneration: {DestroyedTime-GetSecondsSinceEpoch()} < {BlockToRegenerate.RegenerativeTime}")
                    if (GetSecondsSinceEpoch() - DestroyedTime > BlockToRegenerate.RegenerativeTime):
                        SpawnBlock(BlockToRegenerate.BlockType, BlockToRegenerate.GridPosition)
                else:
                    set BlockToRegenerate.DestroyedTime = option. GetSecondsSinceEpoch()


                    
            # Print("Checking to place Block")
            var RemovedBlock : logic = false
            for (MaybeBlock : BlockMap, Block := MaybeBlock?):
                if:
                    ItemType := Block.GetClass().GetItemType()
                    ItemType = item_type.OakSapling
                then:
                    if:
                        GetSecondsSinceEpoch()-Block.GetCreationTime[] > TREE_GROW_TIME
                    then:
                        Block.Destroy()
                        Print("Building Oak tree")
                        StructureManager.OakTree.Build(Self, Block.GetGridPosition())



                else if:
                    ItemType := Block.GetClass().GetItemType()
                    ItemType = item_type.SpruceSapling
                then:
                    if:
                        GetSecondsSinceEpoch()-Block.GetCreationTime[] > TREE_GROW_TIME
                    then:
                        # Count := CountSurroundingBlocks(Block.GetGridPosition(), Block.GetBlockType())
                        Block.Destroy()
                        # if (Count > 3):
                        #     StructureManager.BigSpruceTree.Build(Self, Block.GetGridPosition())
                        # else:
                        StructureManager.SpruceTree.Build(Self, Block.GetGridPosition())
            Sleep(FrameTime)




GetGridPosition(WorldPosition : vector3)<transacts> : vector3i =
    if:
        RetX : int = Round[WorldPosition.X / GRID_SIZE]
        RetY : int = Round[WorldPosition.Y / GRID_SIZE]
        RetZ : int = Round[WorldPosition.Z / GRID_SIZE]
    then:
        return vector3i{X:=RetX, Y:=RetY, Z:=RetZ}
    else:
        Assert("Could not Convert to Grid Position")
        return vector3i{X:=0, Y:=0, Z:=0}

GridPositionToIndex(GridPosition : vector3i)<transacts> : string = return "[{GridPosition.X}]-[{GridPosition.Y}]-[{GridPosition.Z}]"
WorldPositionToIndex(WorldPosition : vector3)<transacts> : string = GridPositionToIndex(WorldToGridPosition(WorldPosition))

GridToWorldPosition(GridFloat : float)<transacts> : float = GridFloat * GRID_SIZE
GridToWorldPosition(GridPosition : vector3i)<transacts> : vector3 = GridPosition.ToVector3() * GRID_SIZE
WorldToGridPosition(WorldPosition : vector3)<transacts> : vector3i = GetGridPosition(WorldPosition)

G2W(GridPosition : int)<transacts> : float  = GridPosition * GRID_SIZE
G2W(GridPosition : float)<transacts> : float  = GridPosition * GRID_SIZE
G2W(GridPositionV3i : vector3i)<transacts> : vector3 = GridPositionV3i.ToVector3() * GRID_SIZE
G2W(GridPositionV3 : vector3)<transacts> : vector3 = GridPositionV3 * GRID_SIZE

W2G(WorldPosition : vector3)<transacts> : vector3i = GetGridPosition(WorldPosition)


GridToIndex(Position : vector3i)<transacts> : string = GridPositionToIndex(Position)
WorldToIndex(Position : vector3)<transacts> : string = WorldPositionToIndex(Position)
G2I(Position : vector3i)<transacts> : string = GridPositionToIndex(Position)
W2I(Position : vector3)<transacts> : string = WorldPositionToIndex(Position)


IsPlayerInBlock(BlockGridPosition : vector3i, PlayerGridPosition : vector3i)<transacts> : logic =
    if:
        BlockGridPosition.X = PlayerGridPosition.X and
        BlockGridPosition.Y = PlayerGridPosition.Y and
        (BlockGridPosition.Z = PlayerGridPosition.Z or
        BlockGridPosition.Z = PlayerGridPosition.Z+1)
    then:
        return true
    else:
        return false
--- </block_manager_device.verse> ---

--- <button_manager_device.verse> ---
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Fortnite.com/Characters }
using { /UnrealEngine.com/Temporary/SpatialMath }

item_cost := struct<concrete>:
    @editable ItemType : item_type = item_type.None
    @editable Amount : int = 1


button_wrapper := class<concrete>():
    var RefButtonManager : button_manager_device = button_manager_device{}
    var RefGameManager : game_manager_device = game_manager_device{}
    var RefBlockManager : block_manager_device = block_manager_device{}
    var RefItemManager : item_manager_device = item_manager_device{}
    var NotEnoughItemsHUD : hud_message_device = hud_message_device{}
    # var RefSoundManager : sound_manager_device = sound_manager_device{}
    # var RefAccoladesManager : accolades_manager_device = accolades_manager_device{}

    var Initialized : logic = false
    Initiate<public>(InButtonManager : button_manager_device, InGameManager : game_manager_device, InNotEnoughItemsHUD : hud_message_device) : void = 
        if (Initialized?):
            Assert("Button {ButtonName} is already initialized")
        set RefGameManager = InGameManager
        set NotEnoughItemsHUD = InNotEnoughItemsHUD

        MutatorZone.AgentEntersEvent.Subscribe(ActivatedButton)
        
        set ButtonTransform = MutatorZone.GetTransform()
        if (MutatorZone.TeleportTo[OUT_OF_BOUNDS, rotation{}]) {}
        MutatorZone.Disable()

        for (ButtonToShow : ButtonsToShow):
            set ButtonsToShowTransform += array. ButtonToShow.GetTransform() 
            if (ButtonToShow.TeleportTo[OUT_OF_BOUNDS, rotation{}]) {}
            ButtonToShow.Disable()


        set Initialized = true

    @editable ButtonName: string = ""
    @editable ItemCosts : []item_cost = array{}
    @editable MutatorZone: mutator_zone_device = mutator_zone_device{}
    @editable ButtonsToShow : []mutator_zone_device = array{}
    @editable StructureToShow : prebuilt_structure_wrapper = prebuilt_structure_wrapper{}
    @editable MessageHUD : hud_message_device = hud_message_device{}
    @editable Cinematic : cinematic_sequence_device = cinematic_sequence_device{}

    var ButtonTransform : transform = transform{}
    var ButtonsToShowTransform : []transform = array{}

    PrintButton<public>() : void =
        Print("===== BUTTON DETAILS =====")
        Print("Name: {ButtonName}")
        Print("Item Costs:")
        for(Cost : ItemCosts):
            Print(" - {RefItemManager.GetItemName(Cost.ItemType)}, Amount: {Cost.Amount}") # Assumes ItemType has ToString
        Print("==========================")

    Activate<public>() : void =
        MutatorZone.Enable()
        if (MutatorZone.TeleportTo[ButtonTransform]) {}
        
    ActivatedButton<public>(Agent:agent) : void =
        if (not Initialized?):
            Assert("Button \"{ButtonName}\" was not initialized")

        PrintButton()
        if (Player := player[Agent]):
            if (CustomPlayer := RefGameManager.GetCustomPlayer[Agent]):
                if (CustomPlayer.HasItems[ItemCosts]):
                    CustomPlayer.ConsumeItems(ItemCosts)

                    MutatorZone.Disable()
                    if (MutatorZone.TeleportTo[OUT_OF_BOUNDS, rotation{}]) {}
                    
                    StructureToShow.Build(RefBlockManager)
                    spawn. UnlockButtonContent(Agent)
                    RefButtonManager.ButtonUnlockedEvent.Signal(increase_event_data{Agent:=Player, Value:=ButtonName, Type:=quest_type.None, Amount:=1})
            
                else:
                    Print("Player does NOT have required items or keys.")
                    NotEnoughItemsHUD.Show(Agent)
            else:
                Assert("Could not find CustomPlayer for Agent")
        else:
            Assert("Could not get Player from Agent")


    UnlockButtonContent<private>(Agent:agent)<suspends>: void=
        Cinematic.Play(Agent)
        for(Index->ButtonToShow : ButtonsToShow, Transform := ButtonsToShowTransform[Index]):
            if (ButtonToShow.TeleportTo[Transform]) {}
            ButtonToShow.Enable()

        # CheckForUniques(Agent)
    # CheckForUniques(Agent:agent)<suspends> : void =
    #     if (not UniqueIDX = 0). Print("UniqueIdx: {UniqueIDX} activated.")

button_manager_device := class(creative_device):

    ButtonUnlockedEvent : event(increase_event_data) = event(increase_event_data){}

    @editable GameManager : game_manager_device = game_manager_device{}
    @editable NotEnoughItemsHUD : hud_message_device = hud_message_device{}

    # @editable AccoladesManager : accolades_manager_device = accolades_manager_device{}
    # @editable AudioManager : audio_manager_device = audio_manager_device{}

    @editable Buttons : []button_wrapper = array{}

    OnBegin<override>()<suspends> : void =
        for (Button : Buttons):
            Button.Initiate(Self, GameManager, NotEnoughItemsHUD)

    ActivateButton<public>(ButtonName : string) : void =
        for (Button : Buttons, Button.ButtonName = ButtonName):
            Button.Activate()--- </button_manager_device.verse> ---

--- <crafting_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }

# See https://dev.epicgames.com/documentation/en-us/uefn/create-your-own-device-in-verse for how to create a verse device.

recipe_matrix := struct<concrete>:
    @editable RecipeLine1 : []item_type = array{item_type.None, item_type.None, item_type.None}
    @editable RecipeLine2 : []item_type = array{item_type.None, item_type.None, item_type.None}
    @editable RecipeLine3 : []item_type = array{item_type.None, item_type.None, item_type.None}

# recipe_base := class():
#     @editable RecipeMatrix<public> : recipe_matrix = recipe_matrix{}
#     @editable CraftedItemType<public> : item_type = item_type.None
#     @editable CraftedAmount<public> : int = 1


recipe_wrapper := class<unique>():
    var RefItemManager<private> : item_manager_device = item_manager_device{}
    @editable RecipeName<private> : string = ""
    @editable CraftedItemType<public> : item_type = item_type.None
    @editable CraftedAmount<public> : int = 1

    @editable RecipeMatrix<public> : recipe_matrix = recipe_matrix{}
    
    IsInitialized : logic = false
    Initiate<public>(InItemManager : item_manager_device) : void = 
        if (IsInitialized?):
            Assert("Recipe \"{RecipeName}\" is already initialized")
        set RefItemManager = InItemManager

    GetRecipeName<public>()<transacts> : string = RecipeName
    GetCraftedItemType()<transacts> : item_type = CraftedItemType
    GetCraftedAmount()<transacts> : int = CraftedAmount
    GetRecipeMatrix<public>()<transacts> : [][]item_type = array{RecipeMatrix.RecipeLine1, RecipeMatrix.RecipeLine2, RecipeMatrix.RecipeLine3}
    GetRecipeMatrixFlattened<public>()<transacts><decides> : []item_type = { FlattenedMatrix:=GetRecipeMatrix()[0]+GetRecipeMatrix()[1]+GetRecipeMatrix()[2]; return FlattenedMatrix }
    GetCraftedItemName() : string = RefItemManager.GetItemName(CraftedItemType)
    GetNeededItemMap<public>()<transacts> : [item_type]int = 
        var ItemMap : [item_type]int = map{}
        for(Row : GetRecipeMatrix()):
            for(Slot : Row):
                if(not Slot = item_type.None):
                    if(set ItemMap[Slot] += 1){}
                    else:
                        if(set ItemMap[Slot] = 1){}
        return ItemMap





crafting_manager_wrapper := class():
    RefCraftingManager : crafting_manager_device
    RefPlayer : player

    var MaybeCraftingBenchInterface : ?crafting_bench_interface = false

    Initialize()<suspends> : void =
        set MaybeCraftingBenchInterface = option{
            crafting_bench_interface:
                RefItemManager := RefCraftingManager.ItemManager
                CraftItemFunction:=RefCraftingManager.CraftItem
                GetRecipesFunction:=RefCraftingManager.GetCraftableRecipes
                GetAvailabilityMatrix:=RefCraftingManager.GetItemAvailabilityMatrix
                AllRecipes:=RefCraftingManager.Recipes
        }
        
        if(CraftingBenchInterface := MaybeCraftingBenchInterface?):
            CraftingBenchInterface.Initialize()
        
    Open() : void =
        if(CraftingBenchInterface := MaybeCraftingBenchInterface?):
            CraftingBenchInterface.Open(RefPlayer)

crafting_manager_device := class(creative_device):
    @editable GameManager : game_manager_device = game_manager_device{}
    @editable ItemManager : item_manager_device = item_manager_device{}

    var Recipes : []recipe_wrapper = array{}
    @editable RecipesCopy<private> : []recipe_wrapper = array{}
    @editable Recipes_Items<private> : []recipe_wrapper = array{}
    @editable Recipes_Blocks<private> : []recipe_wrapper = array{}
    @editable Recipes_Tools<private> : []recipe_wrapper = array{}
    @editable Recipes_FortniteItems<private> : []recipe_wrapper = array{}
    @editable Recipes_Consumables<private> : []recipe_wrapper = array{}
    @editable Recipes_Miscellaneous<private> : []recipe_wrapper = array{}


    CraftedItemEvent : event(increase_event_data) = event(increase_event_data){}

    CraftItem(Player : player, Recipe : recipe_wrapper) : void =
        for(NeededItem->Amount : Recipe.GetNeededItemMap(), CustomPlayer:=GameManager.GetCustomPlayer[Player]):
            if(CustomPlayer.GetItemAmount(NeededItem) < Amount):
                return
        for(ItemType->Amount : Recipe.GetNeededItemMap(), CustomPlayer:=GameManager.GetCustomPlayer[Player]):
            CustomPlayer.ConsumeItem(ItemType, Amount)

        ItemManager.GrantItem(Player, Recipe.GetCraftedItemType(), ?Amount := Recipe.GetCraftedAmount())
        ItemName := ItemManager.GetItemName((Recipe.GetCraftedItemType()))
        CraftedItemEvent.Signal(increase_event_data{Agent:=Player, Value:=ItemName, Type:=quest_type.Craft, Amount:=1})
        Print("Crafted item")

    GetCraftableRecipes(Player : player) : []recipe_wrapper =
        var CraftableRecipes : []recipe_wrapper = array{}
        for(Recipe : Recipes):
            for(NeededItem->Amount : Recipe.GetNeededItemMap(), CustomPlayer:=GameManager.GetCustomPlayer[Player]):
                if(CustomPlayer.GetItemAmount(NeededItem) >= 1):
                    if(not CraftableRecipes.Find[Recipe]):
                        set CraftableRecipes += array{Recipe}
        return CraftableRecipes

    GetItemAvailabilityMatrix(Player : player, Recipe : recipe_wrapper)<transacts> : []logic =
        var AvailabilityMatrix : []logic = array{}
        for(NeededItem : Recipe.GetRecipeMatrixFlattened[], CustomPlayer:=GameManager.GetCustomPlayer[Player]):
            if(Amount := Recipe.GetNeededItemMap()[NeededItem]):
                if(CustomPlayer.GetItemAmount(NeededItem) < Amount):
                    set AvailabilityMatrix += array{false}
                else:
                    set AvailabilityMatrix += array{true}
            else:
                set AvailabilityMatrix += array{true}
        return AvailabilityMatrix


    OpenCraftingTable(Agent : agent) : void =
        if(CustomPlayer:=GameManager.GetCustomPlayer[Agent]):
            CustomPlayer.OpenCraftingTable()

    OnBegin<override>() : void =
        set Recipes += Recipes_Blocks
        set Recipes += Recipes_Tools
        set Recipes += Recipes_FortniteItems
        set Recipes += Recipes_Consumables
        set Recipes += Recipes_Miscellaneous

        for (Recipe : Recipes):
            # if(FlattenedMatrix := Recipe.GetRecipeMatrixFlattened[]):
            #     for(Index->ItemType : FlattenedMatrix, ItemType = item_type.None):
            #         Assert("Could not initialize Crafting Bench because ItemType of recipe matrix[{Index}] of \"{Recipe.GetRecipeName()}\n is \"None\"")    
            Recipe.Initiate(ItemManager)
            if (Recipe.CraftedItemType = item_type.None):
                Assert("Could not initialize Crafting Bench Interface because ItemType of crafted Item recipe \"{Recipe.GetRecipeName()}\n is \"None\"")
            else:
                Print("Is not None")
            
--- </crafting_manager_device.verse> ---

--- <custom_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Fortnite.com/Characters }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Verse.org/Random }

custom_manager_device := class(creative_device):
    @editable GameManager : game_manager_device = game_manager_device{}
    
    @editable SkyMutatorZones : []mutator_zone_device = array{}
    @editable DontFallHUD : hud_message_device = hud_message_device{}


    OnBegin<override>()<suspends>:void=
        #spawn. ConvertItemsToMoney()

        for (SkyMutatorZone : SkyMutatorZones):
            SkyMutatorZone.AgentEntersEvent.Subscribe(ShowAgentSharkWarning)

    ShowAgentSharkWarning(Agent : agent) : void = 
        DontFallHUD.Show(Agent)
        # if (FortCharacter := Agent.GetFortCharacter[]):
        #     FortCharacter.Damage(10000.0)
        
        # if (FortCharacter := Agent.GetFortCharacter[]):
        #     Position := FortCharacter.GetTransform().Translation
        #     if (Position.Z < 0.0):
        #         DontFallHUD.Show(Agent)
        #     else:
        #         return
        # else:

    ConvertItemsToMoney()<suspends> : void = 
        loop:
            Sleep(0.05)
     --- </custom_manager_device.verse> ---

--- <custom_player_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Fortnite.com/UI }
using { /Fortnite.com/Game }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Characters }
using { /Verse.org/Colors/NamedColors }
using { /UnrealEngine.com/Temporary/SpatialMath }

custom_player := class<unique>():       #custom player class that holds the players values
    RefPlayer : player
    # RefCustomPlayerManager : custom_player_manager
    RefGameManager : game_manager_device
    RefBlockManager : block_manager_device
    RefItemManager : item_manager_device
    RefRaycastManager : raycast_manager_device
    RefAudioManager : audio_manager_device
    RefCraftingManager : crafting_manager_device
    RefFurnaceManager : furnace_manager_device
    RefVillagerManager : villager_manager_device
    BlockUtility : block_utility_wrapper

    InputTriggerDropItem : input_trigger_device
    InputTriggerLeftClick : input_trigger_device
    InputTriggerRightClick : input_trigger_device
    InputTriggerInventory : input_trigger_device
    
    PlacedBlockEvent : event(increase_event_data)
    PickUpItemEvent : event(increase_event_data)
    LevelUpEvent : event(increase_event_data)

    TestButtonFunction(Agent : agent) : void =
        GainExperiencePoints(0.25)
        # OpenInventory()


    var Initialized : logic = false
    Initiate<public>() : void =
        if (Initialized?). return
        set Initialized = true

        if (FortCharacter := RefPlayer.GetFortCharacter[]):
            FortCharacter.SprintedEvent().Subscribe(SprintedEvent)
            FortCharacter.JumpedEvent().Subscribe(JumpedEvent)
            FortCharacter.EliminatedEvent().Subscribe(EliminatedEvent)
        InitiateUI()

        set MaybeCraftingBenchInterface = option. crafting_manager_wrapper:
            RefCraftingManager:=RefCraftingManager
            RefPlayer:=RefPlayer
        set MaybeFurnaceInterface = option. furnace_manager_wrapper:
            RefFurnaceManager:=RefFurnaceManager
            RefPlayer:=RefPlayer
        set MaybeVillagerInterface = option. villager_manager_wrapper:
            RefVillagerManager:=RefVillagerManager
            RefPlayer:=RefPlayer
        if(CrafingBenchInterface := MaybeCraftingBenchInterface?). spawn. CrafingBenchInterface.Initialize()
        if(FurnaceInterface := MaybeFurnaceInterface?). spawn. FurnaceInterface.Initialize()
        if(VillagerInterface := MaybeVillagerInterface?). spawn. VillagerInterface.Initialize()


    ######################################
    #       VARIABLES & FUNCTIONS        #
    ######################################
    var __IsDead<public> : logic = false
    var __HasLeft<public> : logic = false
    var __HasDied<public> : logic = false


    IsDead<public>()<decides><transacts> : decides_result = { var D: ?decides_result = false; if (__IsDead?). set D = option. decides_result{}; return D? } 
    IsAlive<public>()<decides><transacts> : decides_result = { var D: ?decides_result = option. decides_result{}; if (__IsDead?). set D = false; return D? } 

    SpawnedEvent<public>(__ : agent) : void = 
        set __IsDead = false
        HungerBar.SetHungerBar(MAX_HUNGER_AMOUNT)
        ExperienceBar.SetExperiencePoints(0.0)
        ExperienceBar.SetLevel(0)
        
        Inventory.ShowHotBar()
        ExperienceBar.Show()
        HungerBar.Show()



        set ActiveHotBarIndex = 0
        GetActiveItemSlot().MakeActive()
        UpdateItemInHand()
        # Inventory.Clear()

        if (__HasDied?):
            RefItemManager.GrantItem(RefPlayer, item_type.WoodenSword)
            RefItemManager.GrantItem(RefPlayer, item_type.WoodenAxe)
            RefItemManager.GrantItem(RefPlayer, item_type.Carrot, ?Amount := 4)
            RefItemManager.GrantItem(RefPlayer, item_type.OakPlanks, ?Amount := 16)



    var IsSprinting : logic = false
    SprintedEvent<private>(SprintResult : tuple(fort_character, logic)) : void = 
        set IsSprinting = SprintResult(1)

    JumpedEvent<private>(__ : fort_character) : void =
        DecreaseHungerBar(JUMP_HUNGER_CONSUMPTION)

    EliminatedEvent<private>(__ : elimination_result) : void = 
        set __IsDead = true
        set __HasDied = true
        ClearItemInHand()
        Inventory.HideHotBar()
        HungerBar.Hide()
        Inventory.DropAll()
        ExperienceBar.Hide()

        



    var IsFirstPerson<public> : logic = false
    FirstPerson<public>() : void = 
        RefGameManager.FirstPersonCamera.AddTo(RefPlayer)
        set IsFirstPerson = true

    ThirdPerson<public>() : void = 
        RefGameManager.FirstPersonCamera.RemoveFrom(RefPlayer)
        set IsFirstPerson = false


    var IsHoldingFortniteItem : logic = false
    Damage<public>(DamageInHearts : float) : void =
        if:
            FortCharacter := RefPlayer.GetFortCharacter[]
        then:
            FortCharacter.Damage(DamageInHearts * 10.0)
            
    ClearInventory<public>() : void =
        Inventory.ClearAll()

    








    ###########################################
    #             EXPERIENCE BAR              #
    ###########################################
    ExperienceBar<private> : experience_bar_wrapper = experience_bar_wrapper{}
    MiddlewareLevelUpEvent<private> : event() = event(){}

    InitiateExperienceBar<private>() : void =
        ExperienceBarPosition : vector2 = vector2{X:=0.0, Y:= -74.0}
        ExperienceBar.Initiate(MiddlewareLevelUpEvent, ExperienceBarPosition, Canvas)
        spawn. LeveledUpSuspended()

    # ClearLevels<public>() : void = 
    #     ExperienceBar.SetExperiencePoints(0.0)
    #     ExperienceBar.SetLevel(0)

    GainExperiencePoints<public>(Amount : float) : void =
        ExperienceBar.GainExperiencePoints(Amount)


    LeveledUpSuspended<private>()<suspends> : void = 
        loop:
            MiddlewareLevelUpEvent.Await()
            Print("CustomPlayer Leveled Up")
            LevelUpEvent.Signal(increase_event_data{Agent:=RefPlayer, Amount:=1, Value:="Level: {ExperienceBar.GetLevel()}", Type:=quest_type.LevelUp})


    #######################################
    #             HUNGER BAR              #
    #######################################
    HungerBar<private> : hunger_bar_wrapper = hunger_bar_wrapper{}

    InitiateHungerBar<private>() : void =
        HungerBarPosition : vector2 = vector2{X:=150.0 + 67.0 + 10.0 - 6.0, Y:= -82.0 - 16.0 - 12.0}
        HungerBar.Initiate(HungerBarPosition, Canvas)
        
    DecreaseHungerBar<public>(Amount : float) : void =
        HungerBar.DecreaseHungerBar(Amount)

    IncreaseHungerBar<public>(Amount : float) : void =
        HungerBar.IncreaseHungerBar(Amount)

    GetHunger<public>() : float =  
        HungerBar.GetHunger()


    ConsumeActiveItem<public>() : void = 
        Inventory.Consume(ActiveHotBarIndex, 1)
        UpdateItemInHand()

            
    ConsumeItem<public>(ItemType : item_type, Amount : int) : void =
        Inventory.Consume(ItemType, Amount)
        UpdateItemInHand()
        
    ConsumeItems(Costs: []item_cost) : void =
        for (Cost : Costs):
            Inventory.Consume(Cost.ItemType, Cost.Amount)
        UpdateItemInHand()
            
    GetItemAmount(ItemType : item_type)<transacts> : int = 
        var TotalAmount : int = 0
        for (ItemSlot : Inventory.GetItemSlots(), Item := ItemSlot.GetItem[]):
            if (Item.GetItemType() = ItemType):
                set TotalAmount += Item.GetQuantity()
        return TotalAmount
    
    HasItems(Costs: []item_cost)<transacts><decides> : decides_result =
        var DecidesResult : ?decides_result = option. decides_result{}
        for (Cost : Costs):
            CurrentAmount := GetItemAmount(Cost.ItemType)
            if (CurrentAmount < Cost.Amount):
                Print("Player only has {CurrentAmount}/{Cost.Amount} of {RefItemManager.GetItemName(Cost.ItemType)} in Inventory")
                set DecidesResult = false
        return DecidesResult?


    ######################################
    #             INVENTORY              #
    ######################################
    Inventory : inventory_wrapper = inventory_wrapper{}    
    var SelectedItemSlot<public> : ?item_slot_wrapper = false

    
    var AllowHotBarSwitch : logic = true
    var ActiveHotBarIndex : int = 0

    InitiateInventory<private>() : void =
        Inventory.Initiate(RefPlayer, Canvas, RefGameManager)
        Inventory.AccessCloseButton().OnClick().Subscribe(CloseInventoryFromUI)
        
    OpenInventory<public>() : void = 
        Inventory.Open()
        set SelectedItemSlot = false

    OpenInventoryByInput<public>(Agent : agent) : void = 
        OpenInventory()

    CloseInventory<public>() : void = 
        Inventory.Close()
        set SelectedItemSlot = false

    CloseInventoryFromUI<public>(WidgetMessage : widget_message) : void = 
        Inventory.Close()
        set SelectedItemSlot = false


    PreviousItem(Agent : agent) : void =
        # Print("{PlayerNameToString(Agent)} swapped to previous Item")
        if (not AllowHotBarSwitch?):
            PrintError("Throttleing Item Switch for {PlayerNameToString(Agent)}")
            return
        set AllowHotBarSwitch = false
        SwitchHotBarSlot(ActiveHotBarIndex - 1)

    NextItem(Agent : agent) : void =
        # Print("{PlayerNameToString(Agent)} swapped to next Item")
        if (not AllowHotBarSwitch?):
            PrintError("Throttleing Item Switch for {PlayerNameToString(Agent)}")
            return
        set AllowHotBarSwitch = false
        SwitchHotBarSlot(ActiveHotBarIndex + 1)

    ClearItemInHand<public>() : void =
        RefItemManager.ItemRemover.Remove(RefPlayer)
        RefItemManager.EmptyVFXPowerup.Pickup(RefPlayer)
        InputTriggerLeftClick.Register(RefPlayer)
        InputTriggerRightClick.Register(RefPlayer)
        set OldActiveItem = false

    var OldActiveItem<private> : ?item_instance = false 
    UpdateItemInHand<public>() : void = 
        if:
            ActiveItem := GetActiveItem[]
        then:
            if:
                OldItem := OldActiveItem?
                ActiveItem.GetItemType() = OldItem.GetItemType()
            then:
                Print("Same Item")
                return

            set OldActiveItem = option. ActiveItem
            if:
                FortniteItemResult := ActiveItem.IsFortniteItem[]
                ItemGranter := FortniteItemResult(0)
                DamagePowerup := FortniteItemResult(1)
            then:
                # RefItemManager.EmptyVFXPowerup.Pickup(Agent)
                ActiveItem.Select(RefPlayer)
                ItemGranter.GrantItem(RefPlayer)
                DamagePowerup.Pickup(RefPlayer)
                set IsHoldingFortniteItem = true 
                InputTriggerLeftClick.Unregister(RefPlayer)
                InputTriggerRightClick.Unregister(RefPlayer)
                HideCrosshair()
            else:
                RefItemManager.ItemRemover.Remove(RefPlayer)
                RefItemManager.EmptyDMGPowerup.Pickup(RefPlayer)
                InputTriggerLeftClick.Register(RefPlayer)
                InputTriggerRightClick.Register(RefPlayer)
                spawn. SelectItemSuspended(ActiveItem)
                # ActiveItem.Select(RefPlayer)
                set IsHoldingFortniteItem = false
                ShowCrosshair()
        else:
            set OldActiveItem = false
            RefItemManager.ItemRemover.Remove(RefPlayer)
            RefItemManager.EmptyVFXPowerup.Pickup(RefPlayer)
            RefItemManager.EmptyDMGPowerup.Pickup(RefPlayer)
            InputTriggerLeftClick.Register(RefPlayer)
            InputTriggerRightClick.Register(RefPlayer)

    SelectItemSuspended<private>(CompareItem : item_instance)<suspends> : void = 
        Sleep(0.25) # Sleep(0.2)
        if:
            ActiveItem := GetActiveItem[]
            ActiveItem.GetItemType() = CompareItem.GetItemType()
        then:
            ActiveItem.Select(RefPlayer)



    SwitchHotBarSlot<public>(NewActiveHotBarIndex : int) : void =
        Print("Daihdaihjd")
        var MaybeOldItem : ?item_instance = false 
        if (Item := GetActiveItem[]):
            set MaybeOldItem = option. Item

        if (NewActiveHotBarIndex < 0):
            set ActiveHotBarIndex = NewActiveHotBarIndex+9
        else:
            set ActiveHotBarIndex = Modular(NewActiveHotBarIndex, 9)
        Inventory.SwitchHotBarSlot(ActiveHotBarIndex)
        UpdateItemInHand()
        if:
            (   OldItem := MaybeOldItem?
                Item := GetActiveItem[]
                OldItem.GetItemType() = Item.GetItemType()
            ) or (
                not MaybeOldItem?
                not GetActiveItem[]
            )
        then:
            block{}
        else:
            set SwitchedHotBarThisFrame = true

    GetActiveItemSlot<public>()<transacts> : item_slot_wrapper = 
        if (ItemSlot := Inventory.GetItemSlot[ActiveHotBarIndex]):
            return ItemSlot 
        Assert("Could not get Active HotBarSlot {ActiveHotBarIndex} / {Inventory.GetItemSlots().Length}")
        return item_slot_wrapper{}

    GetActiveItem<public>()<transacts><decides> : item_instance =
        var MaybeItem : ?item_instance = false
        if:
            ItemSlot := GetActiveItemSlot()
            not ItemSlot.IsEmpty[]
            Item := ItemSlot.GetItem[]
            Item.GetItemType() <> item_type.None
        then:
            set MaybeItem = option. Item
        return MaybeItem?
        

    
    ########################################
    #               Actions                #
    ########################################
    var SwitchedHotBarThisFrame<private> : logic = false
    var LeftClickIsHeld : logic = false

    LeftClick(__ : agent) : void = 
        if:
            not LeftClickIsHeld?
            not IsHoldingFortniteItem?
        then:      
            spawn. LeftClickSuspended()

    LeftClickSuspended()<suspends> : void =                  
        var MaybeTool : ?item_instance = false
        if:
            Item := GetActiveItem[] 
            ItemProperties := Item.GetItemProperties()
        then:
            set MaybeTool = option. Item
        
        var MaybeTargetBlock : ?block_instance = RefBlockManager.GetTargetBlock(RefPlayer, IsFirstPerson)

        if (TargetBlock := MaybeTargetBlock?, TargetBlock.GetBlockType() <> block_type.None):
            DestroyedBlock := TargetBlock.Mine(RefPlayer, ?MaybeTool := MaybeTool, ?FirstHit := true)
            if (DestroyedBlock?). DecreaseHungerBar(DESTROY_HUNGER_CONSUMPTION)
            

        var TimeUntilReset : float = 0.2
        var NextFrame : logic = false
        var LastFrameTime : float = GetSecondsSinceEpoch()
        var ElapsedTime : float = 0.0
        var StartTime :  float = GetSecondsSinceEpoch()
        
        set LeftClickIsHeld = false

        loop:
            if (IsHoldingFortniteItem?):
                break

            if:
                SwitchedHotBarThisFrame?
                TargetBlock := MaybeTargetBlock?
            then:
                TargetBlock.Reset()
                set MaybeTargetBlock = false
                set SwitchedHotBarThisFrame = false
                if:
                    Item := GetActiveItem[] 
                    ItemProperties := Item.GetItemProperties()
                then:
                    set MaybeTool = option. Item      
                Sleep(HOTBAR_SLOT_SWITCH_DELAY)


            set ElapsedTime = GetSecondsSinceEpoch() - LastFrameTime

            if (not InputTriggerLeftClick.IsHeld[RefPlayer]):
                set LeftClickIsHeld = false
                if:
                    TargetBlock := MaybeTargetBlock?
                    not TargetBlock.HasBeenDestroyed?
                    TargetBlock.GetBlockType() <> block_type.None
                then:
                    TargetBlock.Reset()
                return;

            MaybeCheckBlock := RefBlockManager.GetTargetBlock(RefPlayer, IsFirstPerson)

            if:
                not MaybeTargetBlock?
                CheckBlock := MaybeCheckBlock?
            then:
                set MaybeTargetBlock = MaybeCheckBlock
                set NextFrame = true

            if:
                not MaybeCheckBlock?
                TargetBlock := MaybeTargetBlock?
            then:
                TargetBlock.Reset()
                set MaybeTargetBlock = false
                set NextFrame = true

            if:
                TargetBlock := MaybeTargetBlock?
                CheckBlock := MaybeCheckBlock?
                TargetBlock <> CheckBlock
            then:
                if:
                    TargetBlock.GetBlockType() <> block_type.None
                    not TargetBlock.HasBeenDestroyed?
                then:
                    TargetBlock.Reset()
                set MaybeTargetBlock = MaybeCheckBlock 
                set StartTime = GetSecondsSinceEpoch()
                set NextFrame = true

            if (TargetBlock := MaybeTargetBlock?):
                if:
                    (   Tool := MaybeTool?
                        EfficiencyMultiplier := TargetBlock.GetMiningEfficiencyForItem(Tool)
                        ElapsedTime > (TargetBlock.GetHardness()/(DestroyStageMaterials.Length*1.0)) * EfficiencyMultiplier
                    ) or (
                        not MaybeTool?
                        ElapsedTime > (TargetBlock.GetHardness()/(DestroyStageMaterials.Length*1.0))
                    )
                then:
                    set NextFrame = true

            if:
                NextFrame?
                TargetBlock := MaybeTargetBlock?
                TargetBlock.GetBlockType() <> block_type.None
            then:
                set NextFrame = false
                set LastFrameTime = GetSecondsSinceEpoch()
                set ElapsedTime = 0.0
                DestroyedBlock := TargetBlock.Mine(RefPlayer, ?MaybeTool := MaybeTool)
                if (DestroyedBlock?):
                    DecreaseHungerBar(DESTROY_HUNGER_CONSUMPTION)
                    # Print("Total Time: {GetSecondsSinceEpoch() - StartTime}s") 

    Interact<public>(__ : agent) : void = 
        spawn. InteractSuspended()

    InteractSuspended<private>()<suspends> : void = 
        RaycastHitResult : raycast_hit_result = RefRaycastManager.Raycast(RefPlayer, IsFirstPerson)
        if (not RaycastHitResult.HasHit?):
            return
        if:
            FortCharacter := RefPlayer.GetFortCharacter[]
        then:
            var RaycastPosition : vector3 = RaycastHitResult.HitPosition
            var RaycastNormal : vector3 = RaycastHitResult.HitNormal
            var RaycastRotation : rotation = RaycastHitResult.HitRotation
            var GridPosition : vector3i = GetGridPosition(RaycastPosition)
            var SpawnRotation : rotation = MakeRotation(RaycastNormal, PiFloat*0.5).RotateBy(MakeRotationFromYawPitchRollDegrees(90.0, 0.0, 0.0))

            InteractedWithSpecialBlock1 := RefBlockManager.CheckForSpecialBlock(Self, GridPosition.Sub(ToVector3i(RaycastNormal)))
            if (InteractedWithSpecialBlock1?). return

            InteractedWithSpecialBlock2 := RefBlockManager.CheckForSpecialBlock(Self, GridPosition)
            if (InteractedWithSpecialBlock2?). return

            # if (not InteractedWithSpecialBlock1? and not InteractedWithSpecialBlock2?). return
            # # extra logic for special blocks?




    RightClick<public>(__ : agent) : void = 
        if:
            Item := GetActiveItem[]
            not IsHoldingFortniteItem?
        then:
            if (Item.IsPlaceable[]). Place(Item)
            if (Item.IsUseable[]). Use(Item)
            if (Item.IsEatable[]). Eat(Item)

            # SpecialBlock := RefBlockManager.CheckForSpecialBlock(Self, GridPosition)
            # SpecialBlock2 := RefBlockManager.CheckForSpecialBlock(Self, GridPosition.Sub(ToVector3i(RaycastNormal)))
            # if (SpecialBlock? or SpecialBlock2?). return

            # if (Item.IsPlaceable[]). Print("Placing {Item.GetName()}")
            # if (Item.IsUseable[]). Print("Using {Item.GetName()}")
            # if (Item.IsEatable[]). Print("Eating {Item.GetName()}")

    Place<private>(Item : item_instance) : void =
        BlockUtility.HideHightlightBlock()
        spawn. PlaceSuspended(Item)

    PlaceSuspended<private>(Item : item_instance)<suspends> : void =
        if:
            BlockType := Item.GetBlockType()
            BlockClass := RefBlockManager.GetBlockClass[BlockType]
        then:
            RaycastHitResult : raycast_hit_result = RefRaycastManager.Raycast(RefPlayer, IsFirstPerson)
            var MaybeGridPositionToPlace : ?vector3i = false
            var MaybeSpawnRotation : ?rotation = false

            if (RaycastHitResult.HasHit?):
                if:
                    PlaceHeight := GetGridPosition(RaycastHitResult.HitPosition).Z
                    PlaceHeight < VOID
                    PlaceHeight > HEIGHT_LIMIT
                then:
                    PrintError("Player is trying to build out of Bounds (Raycast Hit)")
                    return

                if:
                    FortCharacter := RefPlayer.GetFortCharacter[]
                then:
                    var RaycastPosition : vector3 = RaycastHitResult.HitPosition
                    var RaycastNormal : vector3 = RaycastHitResult.HitNormal
                    var RaycastRotation : rotation = RaycastHitResult.HitRotation
                    var GridPosition : vector3i = GetGridPosition(RaycastPosition)
                    var SpawnRotation : rotation = MakeRotation(RaycastNormal, PiFloat*0.5).RotateBy(MakeRotationFromYawPitchRollDegrees(90.0, 0.0, 0.0))

                    if:
                        Abs(RaycastNormal.X) > 0.05 and Abs(RaycastNormal.Y) > 0.05 or
                        Abs(RaycastNormal.Y) > 0.05 and Abs(RaycastNormal.Z) > 0.05 or
                        Abs(RaycastNormal.X) > 0.05 and Abs(RaycastNormal.Z) > 0.05
                    then:
                        set SpawnRotation = IdentityRotation()

                    PlayerPosition := FortCharacter.GetTransform().Translation
                    GridCharacterPosition := GetGridPosition(PlayerPosition)

                    if (BlockClass.HasPlayerCollision()? and IsPlayerInBlock(GridPosition, GridCharacterPosition)?):
                        return

                    if (RefBlockManager.GetBlockFromMap[GridPosition]):
                        set GridPosition = WorldToGridPosition(GridToWorldPosition(GridPosition) + RaycastNormal * GRID_SIZE)
                        if:
                            NewPlaceHeight := GridPosition.Z
                            NewPlaceHeight < VOID
                            NewPlaceHeight > HEIGHT_LIMIT
                        then:
                            PrintError("Player is trying to build out of Bounds (Adjacent Placement)")
                            return

                    if (BlockClass.HasPlayerCollision()? and IsPlayerInBlock(GridPosition, GridCharacterPosition)?):
                        return

                    if (RefBlockManager.GetBlockFromMap[GridPosition]):
                        return

                    if (not RefBlockManager.CheckForPlacement(BlockClass, GridPosition)?):
                        return

                    set MaybeGridPositionToPlace = option{GridPosition}
                    set MaybeSpawnRotation = option{SpawnRotation}

            else:
                if:
                    MaybeFortCharacter := RefPlayer.GetFortCharacter[]
                    FortCharacter := MaybeFortCharacter
                    CharTransform := FortCharacter.GetTransform()
                    CharViewRotation := FortCharacter.GetViewRotation()
                    Pitch := CharViewRotation.GetYawPitchRollDegrees()[1]
                then:
                    if (Pitch < BRIDGE_FORWARD_LOWER_ANGLE or Pitch > BRIDGE_FORWARD_HIGHER_ANGLE):
                        return

                    ForwardVector := CharViewRotation.GetLocalForward()
                    var AddVector : vector3i = vector3i{}
                    HeightOffset := -1

                    if (Abs(ForwardVector.X) > Abs(ForwardVector.Y)):
                        XSign := if (ForwardVector.X > 0.0) then 1 else -1
                        set AddVector = vector3i{X:=XSign, Y:=0, Z:=HeightOffset }
                    else:
                        YSign := if (ForwardVector.Y > 0.0) then 1 else -1
                        set AddVector = vector3i{X:=0, Y:=YSign, Z:=HeightOffset }

                    CurrentGridPos := GetGridPosition(CharTransform.Translation)
                    PlacePosition := CurrentGridPos.Add(AddVector)

                    if:
                        PlaceHeight := PlacePosition.Z
                        PlaceHeight < VOID
                        PlaceHeight > HEIGHT_LIMIT
                    then:
                        PrintError("Player is trying to build out of Bounds (Bridge)")
                        return

                    if (not RefBlockManager.GetBlockFromMap[CurrentGridPos.Add(vector3i{X:=0, Y:=0, Z:=-1})]):
                        return
                    if (RefBlockManager.GetBlockFromMap[PlacePosition]):
                        return
                    # GridCharacterPosition := CurrentGridPos
                    # if (BlockClass.HasPlayerCollision()? and IsPlayerInBlock(PlacePosition, GridCharacterPosition)?):
                    #     return
                    if (not RefBlockManager.CheckForPlacement(BlockClass, PlacePosition)?):
                        return

                    set MaybeGridPositionToPlace = option{PlacePosition}
                    set MaybeSpawnRotation = option{IdentityRotation()}
            if:
                GridPosition : vector3i = MaybeGridPositionToPlace?
                SpawnRotation : rotation = MaybeSpawnRotation?
            then:
                RefAudioManager.PlayPlacedSound(Item.GetItemType(), RefPlayer)
                RefBlockManager.SpawnBlock(BlockClass, GridPosition, SpawnRotation)
                ConsumeActiveItem()
                PlacedBlockEvent.Signal(increase_event_data{Agent:=RefPlayer, Amount:=1, Type:=quest_type.Place, Value:=Item.GetName()})
                DecreaseHungerBar(DESTROY_HUNGER_CONSUMPTION)
        else:
            Assert("Cannot place Item. Either BlockType is None or BlockClass could not be found")
        
    Use<private>(Item : item_instance) : void = 
        block{}

    Eat<private>(Item : item_instance) : void = 
        if (HungerBar.GetHunger() >= 10.0):
            return
        if (Nutrition := Item.GetNutrition[]):
            IncreaseHungerBar(Nutrition)
            ConsumeActiveItem()
            RefAudioManager.PlayEatSound(RefPlayer)

    Drop<public>(ItemSlot : item_slot_wrapper) : void =
        if:
            FortCharacter := RefPlayer.GetFortCharacter[]
            PlayerTransform :=  FortCharacter.GetTransform() 
            SpawnPosition := PlayerTransform.Translation
            LocalForward := PlayerTransform.Rotation.GetLocalForward()
            Impulse := vector2{X := LocalForward.X, Y := LocalForward.Y} * 256.0 # * 256.0
            Item := ItemSlot.GetItem[]
            Quantity := ItemSlot.GetQuantity[]
        then:
            NewItem := item_instance:
                __Class := Item.__Class
                __Quantity := Item.__Quantity
            NewItem.Spawn(SpawnPosition, ?Impulse := Impulse)
            ItemSlot.DecreaseItem(Quantity)
            UpdateItemInHand()

    DropActiveItem<public>(Agent : agent) : void =
        if:
            Item := GetActiveItem[]
            HotbarSlot := GetActiveItemSlot()

            FortCharacter := RefPlayer.GetFortCharacter[]
            PlayerTransform :=  FortCharacter.GetTransform() 
            SpawnPosition := PlayerTransform.Translation
            LocalForward := PlayerTransform.Rotation.GetLocalForward()
            Impulse := vector2{X := LocalForward.X, Y := LocalForward.Y} * 256.0 # * 256.0
        then:            
            if (FortCharacter.IsCrouching[]):
                NewItem := item_instance:
                    __Class := Item.__Class
                    __Quantity := Item.__Quantity
                NewItem.Spawn(SpawnPosition, ?Impulse := Impulse)
                HotbarSlot.SetItem(false)
            else:
                DropAmount := 1
                NewItem := item_instance:
                    __Class := Item.__Class
                    __Quantity := DropAmount
                NewItem.Spawn(SpawnPosition, ?Impulse := Impulse)
                HotbarSlot.DecreaseItem(DropAmount)    
            UpdateItemInHand()

            

    Redrop<public>(Item : item_instance) : void =
        #############################################################
        #       Only used for specific Function inside Inventory    #
        #############################################################
        if:
            FortCharacter := RefPlayer.GetFortCharacter[]
            PlayerTransform :=  FortCharacter.GetTransform() 
            SpawnPosition := PlayerTransform.Translation
            LocalForward := PlayerTransform.Rotation.GetLocalForward()
            Impulse := vector2{X := LocalForward.X, Y := LocalForward.Y} * 256.0
        then:
            NewItem := item_instance:
                __Class := Item.__Class
                __Quantity := Item.__Quantity
            NewItem.Spawn(SpawnPosition, ?Impulse := Impulse)
            


    ######################################
    #               Items                #
    ######################################
    CanPickup<public>(InItem : item_instance)<decides><transacts> : int = Inventory.CanPickup[InItem]
    
    Pickup<public>(InItem : item_instance) : void = 
        PickUpItemEvent.Signal(increase_event_data{Agent:=RefPlayer, Amount:=InItem.GetQuantity(), Value:=InItem.GetName(), Type:=quest_type.Pickup})
        Inventory.Pickup(InItem)
        UpdateItemInHand()
        
        
    ####################################
    #           BLOCK UTILITY          #
    ####################################
    StartBlockUtilityUpdate<public>() : void =
        spawn. UpdateBlockUtility()
            
    UpdateBlockUtility<private>()<suspends> : void = 
        loop:
            if (__HasLeft?):
                BlockUtility.BlockHighlightCreativeProp.Dispose()
                BlockUtility.InteractHighlightCreativeProp.Dispose()
                break
            BlockUtility.Update(Self)
            Sleep(0.0)
        

    ######################################
    #           RESSOURCE POPUP          #
    ######################################
    # var RessourcePopupZOrder : int = 399
    
    var WidgetPosition : vector2 = vector2{X:=0.0, Y:=70.0}
    var PopupHeight : float = -50.0
    FixedRessourcePopup : fixed_ressource_popup_wrapper = fixed_ressource_popup_wrapper{}
    var CurrentDynamicResourcePopupZOrder<public> : int = 335
    DynamicResourcePopups<public> : []dynamic_ressource_popup_wrapper = array:
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, 
        dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}, dynamic_ressource_popup_wrapper{}


    # var FixedRessourcePopupHeight : float = 80.0


    InitiateRessourcePopup<private>() : void =
        set FixedRessourcePopup.Canvas = Canvas
        set FixedRessourcePopup.Position = WidgetPosition + vector2{}
        FixedRessourcePopup.Initiate()

        for (Index->DynamicResourePopup : DynamicResourcePopups):
            DynamicResourePopup.Initiate(RefPlayer, WidgetPosition + vector2{X:=0.0, Y:=PopupHeight})

    AddRessource<public>(ItemType : item_type, Amount : int) : void =
        if:
            ItemClass := RefItemManager.GetItemClass[ItemType]
            ItemTexture := ItemClass.GetTexture()
        then:           
            FixedRessourcePopup.Popup(ItemType, Amount, ItemTexture)
            var FoundPopup : logic = false
            for (Index->DynamicResourePopup : DynamicResourcePopups, not DynamicResourePopup.IsOpen?, not FoundPopup?):
                DynamicResourePopup.Popup(ItemType, CurrentDynamicResourcePopupZOrder, Amount, ItemTexture)
                set CurrentDynamicResourcePopupZOrder += 1
                set FoundPopup = true
                return


    # InitiateRessourcePopup() : void =
    #     set FixedRessourcePopup.Canvas = Canvas
    #     set FixedRessourcePopup.Position = WidgetPosition + vector2{}
    #     set FixedRessourcePopup.PopupLength = RessourcePopupLength
    #     FixedRessourcePopup.Initiate()

    # AddRessource(ItemType : item_type, Amount : int) : void =
    #     if:
    #         ItemClass := RefItemManager.GetItemClass[ItemType]
    #         ItemTexture := ItemClass.GetTexture()
    #     then:           
    #         set RessourcePopupZOrder += 1
    #         FixedRessourcePopup.Popup(ItemType, Amount, ItemTexture)


            # DynamicRessourcePopup := dynamic_ressource_popup_wrapper {
            #     Canvas := Canvas
            #     Position := WidgetPosition + vector2{X:=0.0, Y:=PopupHeight}
            #     ZOrder := RessourcePopupZOrder
            # }
            # DynamicRessourcePopup.Popup(ItemType, Amount, ItemTexture)




    OpenCraftingTable() : void =
        if(CrafingBenchInterface := MaybeCraftingBenchInterface?):
            CrafingBenchInterface.Open()

    OpenFurnace(FurnaceId : int) : void =
        Print("trying to open furnace custom player")
        if(FurnaceInterface := MaybeFurnaceInterface?):
            Print("Opened furnace custom player")
            FurnaceInterface.Open(FurnaceId)
    
    OpenShop() : void =
        if(VillagerInterface := MaybeVillagerInterface?):
            VillagerInterface.Open()

    ######################################
    #                 UI                 #
    ######################################
    var Canvas : canvas = canvas{}
    var MaybeCraftingBenchInterface : ?crafting_manager_wrapper = false
    var MaybeFurnaceInterface : ?furnace_manager_wrapper = false
    var MaybeVillagerInterface : ?villager_manager_wrapper = false


    InitiateUI<private>() : void =       #Initalizes and adds the players UI
        if:
            PlayerObj := RefPlayer
            PlayerUI := GetPlayerUI[PlayerObj]
        then:
            set Canvas = CreateMyUI()
            PlayerUI.AddWidget(Canvas)
            InitiateRessourcePopup()
            InitiateInventory()
            InitiateHungerBar()
            InitiateExperienceBar()

    UpdateUI() : void =        #Updates the players UI to new values
        block:
    

    
    var IsCrosshairOnScreen<private> : logic = false
    ShowCrosshair<public>() : void =
        if (not IsCrosshairOnScreen?):
            CrosshairTextureBlock.SetVisibility(widget_visibility.Visible)
            set IsCrosshairOnScreen = true
    HideCrosshair<public>() : void = 
        if (IsCrosshairOnScreen?):
            CrosshairTextureBlock.SetVisibility(widget_visibility.Hidden)
            set IsCrosshairOnScreen = false
    

    CrosshairTextureBlock<private> : texture_block = texture_block{DefaultImage := VerseAssets.Crosshair}

    CreateMyUI<private>() : canvas =   #Creates the Main Hud UI
        MyCanvas: canvas = canvas:
            Slots := array:
                canvas_slot:
                    Anchors := anchors{Minimum := vector2{X := 0.5, Y := 0.5}, Maximum := vector2{X := 0.5, Y := 0.5}}
                    Offsets := margin{Left := 0.0, Top := 0.0, Right := 50.0, Bottom := 50.0}
                    Alignment := vector2{X := 0.5, Y := 0.5}
                    SizeToContent := false
                    Widget := CrosshairTextureBlock       



player_spawner_disabler := class():
    PlayerSpawner : player_spawner_device

    SpawnedEvent(Agent : agent) : void = 
        Print("\n[START] PLAYER SPAWNED\n")
        PlayerSpawner.Disable() 

############################################
#           CUSTOM PLAYER MANAGER          #
############################################
custom_player_manager := class(creative_device):
    @editable GameManager : game_manager_device = game_manager_device{}
    @editable RaycastManager : raycast_manager_device = raycast_manager_device{}
    @editable BlockManager : block_manager_device = block_manager_device{}
    @editable ItemManager : item_manager_device = item_manager_device{}
    @editable AudioManager : audio_manager_device = audio_manager_device{}
    @editable CraftingManager : crafting_manager_device = crafting_manager_device{}
    @editable FurnaceManager : furnace_manager_device = furnace_manager_device{}
    @editable VillagerManager : villager_manager_device = villager_manager_device{}

    @editable TestButton : button_device = button_device{}

    @editable StartGameItemGranters : []item_granter_device = array{}
    @editable StartGameInputTriggers : []input_trigger_device = array{}
    
    @editable InputTriggerInteract : input_trigger_device = input_trigger_device{}
    @editable InputTriggerLeftClick : input_trigger_device = input_trigger_device{}
    @editable InputTriggerRightClick : input_trigger_device = input_trigger_device{} 

    @editable InputTriggerPreviousItem : input_trigger_device = input_trigger_device{}
    @editable InputTriggerNextItem : input_trigger_device = input_trigger_device{}

    @editable InputTriggerInventory : input_trigger_device = input_trigger_device{}
    @editable InputTriggerDropItem : input_trigger_device = input_trigger_device{}

    PlacedBlockEvent : event(increase_event_data) = event(increase_event_data){}
    PickUpItemEvent : event(increase_event_data) = event(increase_event_data){}
    LevelUpEvent : event(increase_event_data) = event(increase_event_data){}


    
    OnBegin<override>()<suspends> : void =
        spawn. GameManager.Tick()
        spawn. GameManager.QuickTick()
        spawn. HandePlayers()
        spawn. HandleHunger()
        # spawn. GameManager.RealTimeClock()


        for(PlayerSpawner : GameManager.GameStartPlayerSpawners):     
            PlayerSpawner.SpawnedEvent.Subscribe(OnPlayerSpawned)
            Print("Spawning Player")
            PlayerSpawnerDisabler := player_spawner_disabler{ PlayerSpawner := PlayerSpawner }
            PlayerSpawner.SpawnedEvent.Subscribe(PlayerSpawnerDisabler.SpawnedEvent)
        for(PlayerSpawner : GameManager.GameplayPlayerSpawners):
            Print("Spawning Player")
            PlayerSpawner.SpawnedEvent.Subscribe(OnPlayerSpawned)
            



        # for(PlayerSpawner : GameManager.SpawnPlayerSpawners):     
        #     PlayerSpawner.SpawnedEvent.Subscribe(OnPlayerSpawned)

    OnPlayerSpawned(Agent : agent) : void = if (Player := player[Agent]). spawn { InitiatePlayer(Player) }

    InitiatePlayer(Player : player)<suspends> : void =
        Print("SUPER SPAWNING Spawning Player")
        Print("SUPER SPAWNING Spawning Player")
        Print("SUPER SPAWNING Spawning Player")
        Print("SUPER SPAWNING Spawning Player")
        Print("SUPER SPAWNING Spawning Player")
        Print("SUPER SPAWNING Spawning Player")
        Print("SUPER SPAWNING Spawning Player")
        Print("SUPER SPAWNING Spawning Player")

        loop:
            Sleep(0.1)
            if(PlayerExists := GameManager.CustomPlayerMap[Player]):
                break
            else:
                for (StartGameInputTrigger : StartGameInputTriggers):
                    StartGameInputTrigger.Register(Player)
                for (StartGameItemGranter : StartGameItemGranters): 
                    StartGameItemGranter.GrantItem(Player)
                    
                GameManager.MusicPlayerDevice.Register(Player)
                GameManager.MusicPlayerDevice.Play(Player)

                BlockHighlightCreativeProp := SpawnProp(BlockManager.BlockHighlightCreativePropAsset, OUT_OF_BOUNDS, ?Scale := vector3{X:=0.9925, Y:=0.9925, Z:=0.9925})
                InteractHighlightCreativeProp := SpawnProp(BlockManager.InteractHighlightCreativePropAsset, OUT_OF_BOUNDS)

                BlockUtility := block_utility_wrapper{
                    BlockHighlightCreativeProp := BlockHighlightCreativeProp,
                    InteractHighlightCreativeProp := InteractHighlightCreativeProp,
                    RefRaycastManager := RaycastManager,
                    RefBlockManager := BlockManager
                }

                CustomPlayer := custom_player:
                    RefPlayer := Player
                    RefGameManager := GameManager 
                    RefBlockManager := BlockManager
                    RefItemManager := ItemManager
                    RefRaycastManager := RaycastManager
                    RefAudioManager := AudioManager
                    RefCraftingManager := CraftingManager
                    BlockUtility := BlockUtility

                    InputTriggerDropItem := InputTriggerDropItem
                    InputTriggerInventory := InputTriggerInventory
                    InputTriggerLeftClick := InputTriggerLeftClick
                    InputTriggerRightClick := InputTriggerRightClick

                    PlacedBlockEvent:=PlacedBlockEvent
                    PickUpItemEvent:=PickUpItemEvent
                    LevelUpEvent:=LevelUpEvent


                    RefFurnaceManager:=FurnaceManager
                    RefVillagerManager:=VillagerManager

                set GameManager.CustomPlayerArray += array{CustomPlayer}
                if (set GameManager.CustomPlayerMap[Player] = CustomPlayer) {}
                if (CheckCustomPlayer := GameManager.CustomPlayerMap[Player]):
                    CustomPlayer.Initiate()

                CustomPlayer.FirstPerson()
                CustomPlayer.StartBlockUtilityUpdate()
                RaycastManager.InitiatePlayer(Player)

                InputTriggerLeftClick.Register(Player)
                InputTriggerRightClick.Register(Player)

                TestButton.InteractedWithEvent.Subscribe(CustomPlayer.TestButtonFunction)
                InputTriggerPreviousItem.PressedEvent.Subscribe(CustomPlayer.PreviousItem)
                InputTriggerNextItem.PressedEvent.Subscribe(CustomPlayer.NextItem)    
                InputTriggerInventory.PressedEvent.Subscribe(CustomPlayer.OpenInventoryByInput)

                InputTriggerInteract.PressedEvent.Subscribe(CustomPlayer.Interact)
                InputTriggerLeftClick.PressedEvent.Subscribe(CustomPlayer.LeftClick)
                InputTriggerRightClick.PressedEvent.Subscribe(CustomPlayer.RightClick)
                InputTriggerDropItem.PressedEvent.Subscribe(CustomPlayer.DropActiveItem)
                # for(PlayerSpawner : GameManager.SpawnPlayerSpawners). PlayerSpawner.SpawnedEvent.Subscribe(CustomPlayer.SpawnedEvent)
                for(PlayerSpawner : GameManager.GameplayPlayerSpawners). PlayerSpawner.SpawnedEvent.Subscribe(CustomPlayer.SpawnedEvent)

                Print("Created Custom Player")
                if(Agent := agent[Player], PlayerExists := GameManager.CustomPlayerMap[Agent]):
                    Print("Found Custom Player in CustomPlayerMap")



    HandePlayers()<suspends> : void =
        # FrameTime := 0.0
        # var Cycles : int = 0
        # var StartTime : float = GetSecondsSinceEpoch()
        # var PrintCycle : logic = true

        # loop:
        #     if (PROFILE_PERFORMANCE?):
        #         if (PrintCycle?):
        #             set Cycles += 1
        #             if (GetSecondsSinceEpoch() - StartTime > 30.0):
        #                 Print("Did {Cycles} Cycles in 30 Seconds. HandleHunger()")
        #                 set PrintCycle = false
        #     for (CustomPlayer : GameManager.CustomPlayerArray):
        #         block{}
        #     Sleep(FrameTime)

        FrameTime := 0.0
        var LastTime : float = GetSecondsSinceEpoch()
        loop:
            Sleep(FrameTime)
            DeltaTime := GetSecondsSinceEpoch() - LastTime
            set LastTime = GetSecondsSinceEpoch() 
            # Print("DeltaTime: {DeltaTime}")

            for (CustomPlayer : GameManager.CustomPlayerArray):
                set CustomPlayer.FixedRessourcePopup.CurrentTimer -= DeltaTime
                # if (CustomPlayer.FixedRessourcePopup.IsOpen?):
                #     Print("Is Open")
                # if (CustomPlayer.FixedRessourcePopup.CurrentTimer <= 0.0):
                #     Print("Smaller then 0")
                # Print("CurrentTimer: {CustomPlayer.FixedRessourcePopup.CurrentTimer}")
    
                
                if:
                    CustomPlayer.FixedRessourcePopup.CurrentTimer <= 0.0
                    CustomPlayer.FixedRessourcePopup.IsOpen?
                then:
                    set CustomPlayer.CurrentDynamicResourcePopupZOrder = 335
                    CustomPlayer.FixedRessourcePopup.Close()

                var AtLeastOneDynamicResourcePopIsOpen : logic = false
                for (DynamicResourcePopup : CustomPlayer.DynamicResourcePopups, DynamicResourcePopup.IsOpen?):
                    set AtLeastOneDynamicResourcePopIsOpen = true
                    DynamicResourcePopup.Move()
       


    HandleHunger()<suspends> : void =
        FrameTime := 4.0
        loop:
            for (CustomPlayer : GameManager.CustomPlayerArray):
                CurrentHunger := CustomPlayer.GetHunger()
                if:
                    FortCharacter := CustomPlayer.RefPlayer.GetFortCharacter[]
                then:
                    if:
                        CurrentHunger > 0.0
                    then:
                        if (CustomPlayer.IsSprinting?):
                            CustomPlayer.DecreaseHungerBar(SPRINT_HUNGER_CONSUMPTION)
                        else:
                            CurrentHealth := FortCharacter.GetHealth()
                            MaxHealth := FortCharacter.GetMaxHealth()
    
                            if (CurrentHealth < MaxHealth):
                                HealAmount := HEALTH_REGEN_AMOUNT
                                NewHealth := CurrentHealth + HealAmount
                                ActualNewHealth := if (NewHealth > MaxHealth) then MaxHealth else NewHealth    
                                FortCharacter.SetHealth(ActualNewHealth)
    
                                CustomPlayer.DecreaseHungerBar(HEALTH_REGEN_HUNGER_CONSUMPTION)
                            else:
                                CustomPlayer.DecreaseHungerBar(BASE_HUNGER_CONSUMPTION)
    
                    else if:
                        CurrentHunger = 0.0
                    then:
                        CustomPlayer.Damage(0.5)
            Sleep(FrameTime)
--- </custom_player_device.verse> ---

--- <entity_base_behaviour.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Fortnite.com/Characters }
using { /Verse.org/SpatialMath }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /Fortnite.com/AI }
using { /Verse.org/Simulation/Tags }

knockback_type := enum{
    Little
    Medium
    High
}

entity_base_class_tag := class(tag){}

entity_base_behaviour := class(creative_device):


    @editable KnockbackSmallMM : movement_modulator_device = movement_modulator_device{}

    FindNearestTarget(FC : fort_character)<decides><transacts> : fort_character =
        var MaybeTarget : ?fort_character = false
        var CheckRange : float = 5000.0

        for(Player : GetPlayspace().GetPlayers(), PlayerFC := Player.GetFortCharacter[]):
            if:
                DistanceDifference := Distance(PlayerFC.GetTransform().Translation, FC.GetTransform().Translation) < CheckRange
                not PlayerFC = FC
            then:
                set MaybeTarget = option{PlayerFC}
                set CheckRange = DistanceDifference

        return MaybeTarget?
    

    Attack(PlayerAgent : agent, NPCFC : fort_character, DamageAmount : float, ?KnockbackStrength : knockback_type = knockback_type.Little) : void =
        if(PlayerFC := PlayerAgent.GetFortCharacter[]):
            PlayerFC.Damage(DamageAmount)
            if(KnockbackStrength = knockback_type.Little):
                if(KnockbackSmallMM.TeleportTo[KnockbackSmallMM.GetTransform().Translation, NPCFC.GetTransform().Rotation]):
                    KnockbackSmallMM.Activate(PlayerAgent)
--- </entity_base_behaviour.verse> ---

--- <entity_manager_device.verse> ---
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /Fortnite.com/Characters }
using { /Fortnite.com/AI }

item_drops_wrapper := class<concrete>:
    @editable ItemType : item_type = item_type.None
    @editable DropChance : float = 1.0
    @editable MinDropAmount : int = 1
    @editable MaxDropAmount : int = 1

    Calculate<public>()<transacts> : ?int =
        RandomChance := GetRandomFloat(0.0, 1.0)
        if (RandomChance > Self.DropChance):
            return false
        var AmountToDrop : int = 0
        if (Self.MaxDropAmount > Self.MinDropAmount):
            set AmountToDrop = GetRandomInt(Self.MinDropAmount, Self.MaxDropAmount)
        else if (Self.MinDropAmount >= 1):
            set AmountToDrop = Self.MinDropAmount

        if (AmountToDrop > 0):
            return option. AmountToDrop
        else:
            return false

creature_spawner_wrapper := class():
    var RefEntityManager<private> : entity_manager_device = entity_manager_device{}

    @editable CreatureSpawner<private> : creature_spawner_device = creature_spawner_device{}
    @editable ItemsToDrop<private> : []item_drops_wrapper = array{}

    Initialize<public>(InEntityManager : entity_manager_device) : void =
        set RefEntityManager = InEntityManager
        CreatureSpawner.EliminatedEvent.Subscribe(HandleElimination)

    HandleElimination<private>(Result : device_ai_interaction_result) : void =
        MaybeEliminatedAgent := Result.Target
        if:
            EliminatedAgent := MaybeEliminatedAgent?
            FortCharacter := EliminatedAgent.GetFortCharacter[]
            DeathTransform := FortCharacter.GetTransform()
            DeathPosition := DeathTransform.Translation
        then:
            ItemManager := RefEntityManager.GetItemManager()
            for (ItemToDrop : ItemsToDrop):
                RandomChance := GetRandomFloat(0.0, 1.0)
                if:
                    AmountToDrop := ItemToDrop.Calculate()?
                then:
                    MaxOffsetXY := 50.0
                    OffsetX := GetRandomFloat(-MaxOffsetXY, MaxOffsetXY)
                    OffsetY := GetRandomFloat(-MaxOffsetXY, MaxOffsetXY)
                    Offset := vector3{X:=OffsetX, Y:=OffsetY, Z:=20.0}
                    SpawnPosition := DeathPosition + Offset
                    ItemManager.SpawnItem(SpawnPosition, ItemToDrop.ItemType, ?Amount := AmountToDrop)
                else:
                    PrintError("Item failed drop chance.")
        else:
            PrintError("Could not get FortCharacter/Transform for eliminated agent in specific handler.")


entity_manager_device := class(creative_device):
    @editable ItemManager : item_manager_device = item_manager_device{}
    @editable CreatureSpawners : []creature_spawner_wrapper = array{}

    var SpawnerHandlers<private> : []creature_spawner_wrapper = array{}

    OnBegin<override>()<suspends>:void=
        var TempHandlers : []creature_spawner_wrapper = array{}
        for (Index -> CreatureSpawner : CreatureSpawners). CreatureSpawner.Initialize(Self)
    
    GetItemManager<public>()<transacts> : item_manager_device = ItemManager--- </entity_manager_device.verse> ---

--- <furnace_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }

# See https://dev.epicgames.com/documentation/en-us/uefn/create-your-own-device-in-verse for how to create a verse device.


furnace_recipe_wrapper := class<unique>():
    var RefItemManager<private> : item_manager_device = item_manager_device{}
    @editable InputItemType<private> : item_type = item_type.None
    @editable CookedItemType<public> : item_type = item_type.None
    
    GetCookedItemType()<transacts> : item_type = CookedItemType
    GetCookedItemName() : string = RefItemManager.GetItemName(CookedItemType)
    GetNeededItemType()<transacts> : item_type = InputItemType


furnace_manager_wrapper := class():
    RefFurnaceManager : furnace_manager_device
    RefPlayer : player

    

    Initialize()<suspends> : void =
        block:
        # set MaybeCraftingBenchInterface = option{
        #     furnace_interface:
        #         RefItemManager := RefFurnaceManager.ItemManager
        #         CookItemFunction:=RefFurnaceManager.CookItem
        #         GetRecipesFunction:=RefFurnaceManager.GetCraftableRecipes
        #         CollectItemFunction:=RefFurnaceManager.CollectItem
        #         TimeToCook := RefFurnaceManager.TIME_TO_COOK
        # }
        
        # if(CraftingBenchInterface := MaybeCraftingBenchInterface?):
        #     CraftingBenchInterface.Initialize()
        
    Open(FurnaceId : int) : void =
        Print("Furnace interfaces: {RefFurnaceManager.FurnaceInterfaces.Length}")
        Print("Recipes legnth: {RefFurnaceManager.Recipes.Length}")
        if(FurnaceInterface := RefFurnaceManager.GetFurnaceInterface(FurnaceId)?):
            Print("Got correct furnace")
            FurnaceInterface.Open(RefPlayer)

furnace_manager_device := class(creative_device):
    @editable GameManager : game_manager_device = game_manager_device{}
    @editable ItemManager : item_manager_device = item_manager_device{}

    @editable TIME_TO_COOK : float = 5.0

    @editable Recipes : []furnace_recipe_wrapper = array{}
    @editable FurnaceButton : button_device = button_device{}
    CookedItemEvent : event(increase_event_data) = event(increase_event_data){}

    var FurnaceInterfaces : []furnace_interface = array{}

    GetFurnaceInterface(FurnaceId : int)<transacts> : ?furnace_interface = 
        if(FurnaceInterface := FurnaceInterfaces[FurnaceId]):
            return option{FurnaceInterface}
        
        return false

    CookItem(Player : player, Recipe : furnace_recipe_wrapper)<suspends> : void =
        if(CustomPlayer := GameManager.GetCustomPlayer[Player]):
            ItemType := Recipe.GetNeededItemType()
            if(CustomPlayer.GetItemAmount(ItemType) < 1):
                return

            CustomPlayer.ConsumeItem(ItemType, 1)
            CookedItemEvent.Signal(increase_event_data{Agent:=Player, Value:=Recipe.GetCookedItemName(), Type:=quest_type.Cook, Amount:=1})
            


    CollectItem(Player : player, Recipe : furnace_recipe_wrapper) : void =
        if(CustomPlayer := GameManager.GetCustomPlayer[Player]):
            ItemType := Recipe.GetCookedItemType()

            ItemManager.GrantItem(Player, ItemType, ?Amount:=1)
        

    GetCraftableRecipes(Player : player) : []furnace_recipe_wrapper =
        var CraftableRecipes : []furnace_recipe_wrapper = array{}
        for(Recipe : Recipes):

            if(NeededItem := Recipe.GetNeededItemType(), CustomPlayer:=GameManager.GetCustomPlayer[Player]):
                if(CustomPlayer.GetItemAmount(NeededItem) >= 1):
                    if(not CraftableRecipes.Find[Recipe]):
                        set CraftableRecipes += array{Recipe}
        return CraftableRecipes
    
    AddFurnace(InFurnaceInterface : furnace_interface) : int =
        set FurnaceInterfaces += array{InFurnaceInterface}
        return FurnaceInterfaces.Length - 1
--- </furnace_manager_device.verse> ---

--- <game_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Fortnite.com/Characters }
using { /UnrealEngine.com/Temporary/UI }
using { /Verse.org/Assets}
using { /Fortnite.com/UI }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /Verse.org/Colors/NamedColors }
using { /Verse.org/Random }
using { /Verse.org/Colors }

DEBUG : logic = false
PROFILE_PERFORMANCE : logic = false

GRID_SIZE : float = 100.0
GRID_SIZE_INT : int = 100


BLOCK_SIZE : float = GRID_SIZE
TICK_RATE : int = 20
NORMAL_SCALE : vector3 = vector3{X:=1.0, Y:=1.0, Z:=1.0}
OUT_OF_BOUNDS : vector3 = vector3{X:=-65556.0, Y:=-65556.0, Z:=-65556.0}

HEIGHT_LIMIT : int = 512 # 256 # Blocks Height
VOID : int = -64 # Blocks Deep
ITEM_VOID : int = -96

DESPAWN_TIME : float = 45.0
PICKUP_RANGE : float = 128.0 + 16.0

HOTBAR_SLOT_SWITCH_DELAY : float = 0.05

HEALTH_REGEN_AMOUNT : float = 5.0
HEALTH_REGEN_HUNGER_CONSUMPTION : float = 0.5
START_HUNGER_AMOUNT : float = 16.0
MAX_HUNGER_AMOUNT : float = 13.0 

BASE_HUNGER_CONSUMPTION : float = 0.008 *(4.0/3.0)
SPRINT_HUNGER_CONSUMPTION : float = 0.1 *(4.0/3.0)
DESTROY_HUNGER_CONSUMPTION : float = 0.01 *(4.0/3.0)
PLACE_HUNGER_CONSUMPTION : float = 0.01 *(4.0/3.0)
JUMP_HUNGER_CONSUMPTION : float = 0.075 *(4.0/3.0)

BRIDGE_FORWARD_HIGHER_ANGLE : float = -50.0
BRIDGE_FORWARD_LOWER_ANGLE : float = -85.0

RESOURCE_POPUP_DURATION : float = 2.4

RANDOM_CREATION_TIME_OFFSET_LOWER : float = 1.0 
RANDOM_CREATION_TIME_OFFSET_HIGHER : float = 15.0 

Assets := module:
    Minecraft<public> := module:
        Breaking<public> := module{}
    Materials<public> := module {}
    UI<public> := module:
        Inventory<public> := module{}
        CraftingTable<public> := module{}
        Furnace<public> := module{}
        HUD<public> := module{}
    Models<public> := module:
        WitherSkeleton<public> := module{}

VerseAssets := module:
    Icons<public> := module{}
    Items<public> := module{}
    Rarities<public> := module{}
    
decides_result := class() {}

editable_categories := module:
    AdvancedCategory<public><localizes>:message = "Advanced"

game_manager_device := class(creative_device):
    @editable GameplayPlayerSpawners : []player_spawner_device = array{}
    @editable GameStartPlayerSpawners : []player_spawner_device = array{}

    @editable StartGameMutatorZone : mutator_zone_device = mutator_zone_device{}
    @editable StartGameTeleporter : teleporter_device = teleporter_device{}

    @editable MusicPlayerDevice : audio_player_device = audio_player_device{}
    @editable MusicPlayerSwitch : switch_device = switch_device{}
    
    var CustomPlayerMap : [player]custom_player = map{}
    var CustomPlayerArray : []custom_player = array{}

    @editable FirstPersonCamera : gameplay_camera_first_person_device = gameplay_camera_first_person_device{}
    @editable DeactivateFirstPersonButton : button_device = button_device{}
    @editable ActivateFirstPersonButton : button_device = button_device{}

    OnBegin<override>()<suspends> : void =
        MusicPlayerSwitch.TurnedOnEvent.Subscribe(TurnOnMusic) 
        MusicPlayerSwitch.TurnedOffEvent.Subscribe(TurnOffMusic)
                
        ActivateFirstPersonButton.InteractedWithEvent.Subscribe(ActivateFirstPerson)
        DeactivateFirstPersonButton.InteractedWithEvent.Subscribe(DeactivateFirstPerson)
        if (PROFILE_PERFORMANCE?). HandlePerformance()

        StartGameMutatorZone.AgentEntersEvent.Subscribe(StartGame)

    StartGame(Agent : agent) : void = 
        Print("Start Game Function fired. (Currently Unused)")
        # StartGameTeleporter.Teleport(Agent)

    HandlePerformance()<suspends> : void = 
        FrameTime := 0.0
        MinAge := 0.6
        var Cycles : int = 0
        var StartTime : float = GetSecondsSinceEpoch()
        var PrintCycle : logic = true
        loop:
            if (PrintCycle?):
                set Cycles += 1
                if (GetSecondsSinceEpoch() - StartTime > 30.0):
                    Print("Did {Cycles} Cycles in 30 Seconds. HandlePerformance()")
                    set PrintCycle = false
                    break
                # Print("Time: {GetSecondsSinceEpoch() - StartTime}")
            Sleep(FrameTime)



    TurnOnMusic(Agent : agent) : void = 
        MusicPlayerDevice.Register(Agent)
        MusicPlayerDevice.Play(Agent)

    TurnOffMusic(Agent : agent) : void = 
        MusicPlayerDevice.Unregister(Agent)
        MusicPlayerDevice.Stop(Agent)

        
    ActivateFirstPerson(Agent : agent) : void = 
        if (CustomPlayer := GetCustomPlayer[Agent]):
            CustomPlayer.FirstPerson()

    DeactivateFirstPerson(Agent : agent) : void = 
        if (CustomPlayer := GetCustomPlayer[Agent]):
            CustomPlayer.ThirdPerson()




    GetCustomPlayer<public>(Agent : agent)<decides><transacts> : custom_player =
        var MaybeCustomPlayer : ?custom_player = false
        if (Player : player = player[Agent], CustomPlayer : custom_player = CustomPlayerMap[Player]):
            set MaybeCustomPlayer = option{CustomPlayer}        
        else:
            Print("[!] Could not return custom player")
        return MaybeCustomPlayer?

    GetMaybeCustomPlayer<public>(Agent : agent)<transacts> : ?custom_player =
        var MaybeCustomPlayer : ?custom_player = false
        if (Player := player[Agent], CustomPlayer : custom_player = CustomPlayerMap[Player]):
            set MaybeCustomPlayer = option{CustomPlayer}        
        else:
            Print("[!] Could not return custom player")
        return MaybeCustomPlayer


    Tick()<suspends> : void = 
        loop:
            Sleep(1.0/(TICK_RATE*1.0))


            for (
                CustomPlayer : CustomPlayerArray
            ) {
                if (not CustomPlayer.AllowHotBarSwitch?):
                    Print("Allowing Hot Bar Switch again")
                    set CustomPlayer.AllowHotBarSwitch = true

                # if (CustomPlayer.IsDead?):
                #     Print("Is Dead")
                # else:
                #     Print("Is Alive")

                # Spawn one loop for every Custom Player
            }



            
    QuickTick()<suspends> : void = 
        loop:
            Sleep(0.0)
            for (
                CustomPlayer : CustomPlayerArray
            ) {
                # if (CustomPlayer.IsDead?):
                #     Print("Is Dead")
                # else:
                #     Print("Is Alive")

                # Spawn one loop for every Custom Player
            }


    var DeltaTime : float = 0.0
    var Realtime : float = 0.0
    var Frame : int = 0

    RealTimeClock()<suspends> : void = 
        var NewTime : float = GetSecondsSinceEpoch()
        var OldTime : float = NewTime
        loop:
            Sleep(0.0)
            set DeltaTime = NewTime-OldTime
            set OldTime = NewTime
            set NewTime = GetSecondsSinceEpoch() 
            set Realtime += DeltaTime 
            set Frame += 1
            Print("Slept for {DeltaTime}s")


#####################################
#           CUSTOM METHODS          #
#####################################
SpawnProp(CreativePropAsset : creative_prop_asset, Position : vector3, ?Rotation : rotation = IdentityRotation(), ?Scale : vector3 = vector3{X:=1.0, Y:=1.0, Z:=1.0}) : creative_prop =
    Transform : transform = transform:
        Translation := Position
        Rotation := Rotation
        Scale := Scale
    SpawnPropResult := SpawnProp(CreativePropAsset, Transform)
    if (SpawnPropResult(1) = spawn_prop_result.TooManyProps):
        Assert("Could not spawn Creative Prop because there are too many Props")
    else if (SpawnPropResult(1) = spawn_prop_result.SpawnPointOutOfBounds):
        Assert("Could not spawn Creative Prop because Spawn Point is out of Bounds")
    else if (SpawnPropResult(1) = spawn_prop_result.InvalidSpawnPoint):
        Assert("Could not spawn Creative Prop because Spawn Point is invalid")
    else if (SpawnPropResult(1) = spawn_prop_result.UnknownError):
        Assert("Could not spawn Creative Prop because of unknown error")
    else if:
        SpawnPropResult(1) = spawn_prop_result.Ok
        CreativeProp := SpawnPropResult(0)?
    then:
        return CreativeProp
    Assert("Could not spawn Creative Prop")
    return creative_prop{}
     # SpawnPropResult := SpawnProp(CreativePropAsset, Position, rotation{})
    # if (CreativeProp := SpawnPropResult(0)?):
    #     return CreativeProp
    # else:
    #     Assert("Could not spawn CreativePropAsset")
    #     return creative_prop{}

SpawnParticleSystem(CreativePropAsset : creative_prop_asset, Position : vector3, ?Delay : float = 3.0) : void = 
    SpawnPropResult := SpawnProp(CreativePropAsset, Position, rotation{})
    if (ParticleSystem := SpawnPropResult(0)?):
        if (DEBUG?). Print("Disposing Particle System in {Delay} Seconds")
        spawn. DisposeParticleSystem(ParticleSystem, ?Delay := Delay)

DisposeParticleSystem(ParticleSystem : creative_prop, ?Delay : float = 3.0)<suspends> : void = 
    Sleep(Delay)
    ParticleSystem.Dispose() 

                

###################################
#          GLOBAL METHODS         #
###################################
Modular<public>(Number : int, Modulator : int)<transacts> : int = 
    if (Div := Number / Modulator):
        return Number - Floor(Div)*Modulator
    Assert("Could not get modulo of {Number}")
    return Number 

Fraction<public>(Number : float)<transacts> : float = 
    if (Integer := Floor[Number]):
        return Number - Integer*1.0
    Assert("Could not get Fraction of {Number}")
    return Number

# Abs(X : float)<transacts> : float = 
#     if (X > 0.0): 
#         return X
#     else:
#         return -X
        
#####################################
#          LOCALIZE METHODS         #
#####################################
PlayerName<localizes>(Agent:agent)<transacts> : message = "{Agent}"

PlayerNameToString(Agent:agent):string = Localize(PlayerName(Agent))

StringToMessage<localizes>(String:string) : message = "{String}"
IntToMessage<localizes>(Integer : int) : message = "{Integer}"
FloatToMessage<localizes>(Float:float) : message = "{Float}"
FloatToMessageSuffix<localizes>(Float:float, Suffix:string) : message = "{Float}{Suffix}"

#####################################
#          PRINT METHODS         #
#####################################
PrintLine(?MiddleString : string = "", ?Duration:float = 2.0)<transacts>:void =
    String : string = "=================================================="
    if (MiddleString.Length = 0):
        Print("==================================================", ?Duration := Duration)
    else:
        var NewString : string = ""
        if (HalfCharacters := Floor[((50-MiddleString.Length-1)*1.0)/2.0]):
            for (X:=0..HalfCharacters). set NewString += "="
            set NewString += " {MiddleString} "
            for (X:=0..HalfCharacters). set NewString += "="
            Print(NewString, ?Duration := Duration)

Assert(Msg : string)<transacts> : void =
    Print("[SUPER ERROR] {Msg}", ?Color := Red)
    # Err("{Msg}")

# InitializedWrong(Msg:string)<transacts> : void = 
#     Print("[ERROR] {Msg} could not initialize or already initialized")

PrintError(Msg:string, ?Duration:float = 2.0)<transacts>:void =
    Print("[ERROR] {Msg}", ?Color := NamedColors.Red, ?Duration := Duration)

PrintStart(Msg:string, ?Duration:float = 2.0)<transacts>:void =
    Print("[START] {Msg}", ?Color := NamedColors.GreenYellow, ?Duration := Duration)

PrintInfo(Msg:string, ?Duration:float = 2.0)<transacts>:void =
    Print("[INFO] {Msg}", ?Color := NamedColors.Blue, ?Duration := Duration)
    
PrintSuccess(Msg:string, ?Duration:float = 2.0)<transacts>:void =
    Print("[SUCCESS] {Msg}", ?Color := NamedColors.Green, ?Duration := Duration)
    
Suspend(Function() : void, Delay : float) : void =
    spawn. SuspendSuspended(Function, Delay)

SuspendSuspended(Function() : void, Delay : float)<suspends> : void =
    Sleep(Delay)
    Function()

ToVector2(Vector3 : vector3)<transacts> : vector2 = 
    return vector2{X:=Vector3.X, Y:=Vector3.Y}--- </game_manager_device.verse> ---

--- <item_manager_device.verse> ---

using { /Fortnite.com/UI }
using { /Verse.org/Random }
using { /Verse.org/Assets }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Fortnite.com/Characters }
using { /UnrealEngine.com/Temporary/UI }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /Fortnite.com/Devices/CreativeAnimation }
using { /Fortnite.com/Devices/CreativeAnimation/InterpolationTypes }


item_type := enum{
    None
    GrassBlock
    Dirt
    Cobblestone
    

    OakLog
    OakPlanks
    OakLeaves
    OakSapling
    

    FactoryBlock
    Barrier


    Stick


    
    WoodenPickaxe
    WoodenAxe
    WoodenShovel
    WoodenSword

    StonePickaxe
    StoneAxe
    StoneShovel
    StoneSword

    IronPickaxe
    IronAxe
    IronShovel
    IronSword

    GoldenPickaxe
    GoldenAxe
    GoldenShovel
    GoldenSword

    DiamondPickaxe
    DiamondAxe
    DiamondShovel
    DiamondSword

    NetheritePickaxe
    NetheriteAxe
    NetheriteShovel
    NetheriteSword

    CobblestoneGenerator

    Shears

    CoalIngot
    IronIngot
    GoldIngot
    Diamond

    Sand
    Sandstone
    Stone
    Diorite
    GrayConcrete

    CoalOre
    IronOre
    GoldOre
    DiamondOre   

    IronOreGenerator
    GoldOreGenerator
    DiamondOreGenerator

    Furnace
    CraftingTable

    Netherrack
    Netherbrick
    Obsidian

    Farmland
    Hayball

    Wheat
    Bread

    GrapplingHook

    GrassyCobblestone
    GrassyStone
    NuggetsCowboy
    Gunpowder
    RottenFlesh
    CookedFlesh
    RottenFleshBlock
    LightAmmunition
    MediumAmmunition
    HeavyAmmunition
    ShellAmmunition
    RocketAmmunition
    WeaponTable
    IronBlock
    DiamondBlock
    GoldBlock
    CoalBlock


    L1_SemiAutoPistol
    L2_SemiAutoPistol
    L3_SemiAutoPistol
    L4_SemiAutoPistol
    L5_SemiAutoPistol

    # 1. Assault Rifle (Standard / SCAR)
    L1_AssaultRifle
    L2_AssaultRifle
    L3_AssaultRifle
    L4_AssaultRifle
    L5_AssaultRifle

    # 2. Pump Shotgun (Classic)
    L1_PumpShotgun
    L2_PumpShotgun
    L3_PumpShotgun
    L4_PumpShotgun
    L5_PumpShotgun

    # 3. Tactical Shotgun
    L1_TacticalShotgun
    L2_TacticalShotgun
    L3_TacticalShotgun
    L4_TacticalShotgun
    L5_TacticalShotgun

    # 4. Submachine Gun (Standard / P90 Style)
    L1_SubmachineGun
    L2_SubmachineGun
    L3_SubmachineGun
    L4_SubmachineGun
    L5_SubmachineGun


    L1_RocketLauncher
    L2_RocketLauncher
    L3_RocketLauncher
    L4_RocketLauncher
    L5_RocketLauncher

    # 8. Grenade Launcher
    L3_GrenadeLauncher # Classic started at Rare
    L4_GrenadeLauncher
    L5_GrenadeLauncher

    # 10. Burst Assault Rifle (Classic Burst)
    L1_BurstRifle
    L2_BurstRifle
    L3_BurstRifle
    L4_BurstRifle
    L5_BurstRifle

    # 11. Heavy Sniper Rifle
    L3_HeavySniperRifle # Classic started at Rare
    L4_HeavySniperRifle
    L5_HeavySniperRifle

    # 12. Hand Cannon (Deagle)
    L3_HandCannon # Classic started at Rare
    L4_HandCannon
    L5_HandCannon

    # 14. Suppressed SMG (P90 Style)
    L1_SuppressedSubmachineGun
    L2_SuppressedSubmachineGun
    L3_SuppressedSubmachineGun
    L4_SuppressedSubmachineGun
    L5_SuppressedSubmachineGun

    # 15. Suppressed Pistol
    L1_SuppressedPistol # Using stats from current section
    L2_SuppressedPistol
    L3_SuppressedPistol
    L4_SuppressedPistol
    L5_SuppressedPistol

    # 16. Minigun
    L3_Minigun # Classic started at Rare
    L4_Minigun
    L5_Minigun

    # 17. Drum Gun
    L2_DrumGun # Classic started at Uncommon
    L3_DrumGun
    L4_DrumGun
    L5_DrumGun

    # 19. Hunting Rifle
    L2_HuntingRifle # Classic started at Uncommon
    L3_HuntingRifle
    L4_HuntingRifle
    L5_HuntingRifle

    L4_Scar
    L5_Scar

    SpruceLog
    SpruceLeaves
    SpruceSapling

    WhiteWool
    Emerald
    Carrot
    GoldenCarrot

    StoneBrick
    EmeraldBlock
}


SwitchItemSlotContent(CustomPlayer : custom_player, ItemSlot1 : item_slot_wrapper, ItemSlot2 : item_slot_wrapper) : void =     
    if:
        Item1 := ItemSlot1.GetMaybeItem()?
        Item2 := ItemSlot2.GetMaybeItem()?
        Item1.GetItemType() = Item2.GetItemType()
    then:
        StackSize := Item2.GetStackSize()    
        MissingQuantity := StackSize - Item2.GetQuantity()
        if (MissingQuantity = 0):
            return
        if:
            Item1.GetQuantity() > MissingQuantity 
        then:
            ItemSlot1.SetQuantity(Item1.GetQuantity()-MissingQuantity)
            ItemSlot2.SetQuantity(StackSize)
        else:
            ItemSlot2.SetQuantity(Item2.GetQuantity() + Item1.GetQuantity())
            ItemSlot1.SetItem(false)
    else:
        var ItemCopy: ?item_instance = ItemSlot2.GetMaybeItem()
        ItemSlot2.SetItem(ItemSlot1.GetMaybeItem())
        ItemSlot1.SetItem(ItemCopy)

        

        # if:
        #     ItemSlot2.IsActiveHotbarSlot()? or ItemSlot1.IsActiveHotbarSlot()?
        # then:
        #     CustomPlayer.UpdateItemInHand()

    # if:
    #     # Item1 := ItemSlot1.GetItem[]
    #     # Count1 := ItemSlot1.GetCount[]
    #     Item2 := ItemSlot2.GetItem[]
    #     Count2 := ItemSlot2.GetCount[]
    # then:
    #     set ItemCopy2 = option. Item2
    #     set CountCopy2 = option. Count2
    #     # Print("{Item1.GetName()}: {Count1}")
    #     # Print("{Item2.GetName()}: {Count2}")

    # if:
    #     Item1 := ItemSlot1.GetItem[]
    #     Count1 := ItemSlot1.GetCount[]
    # then:
    #     ItemSlot2.SetItem(Item1, Count1) 

    # if:
    #     Item2 := ItemCopy2? # ItemSlot2Copy.GetItem[]
    #     Count2 := CountCopy2? # ItemSlot2Copy.GetCount[]
    # then:
    #     ItemSlot1.SetItem(Item2, Count2)
    # # else:
    #     # ItemSlot1.RemoveItem(Item2, Count2)






################################
#           INVENTORY          #
################################
inventory_wrapper := class():
    ##### CONSTRUCT #####

    ##### INITIALIZE #####
    var RefGameManager<private> : game_manager_device = game_manager_device{}
    # var RefItemManager<private> : item_manager_device = 
    var MaybePlayer<private> : ?player = false
    var MainCanvas<private> : canvas = canvas{}

    ##### VARIABLES #####
    var ItemSlots<private> : []item_slot_wrapper = array{}
    
    Initiate<public>(InPlayer : player, InMainCanvas : canvas, InGameManager : game_manager_device) : void = 
        set MaybePlayer = option. InPlayer
        set RefGameManager = InGameManager
        set MainCanvas = InMainCanvas
        InitiateUI(InPlayer, InGameManager)

    ##### FUNCTIONS #####

    ######################################################################
    ######################################################################
    ######################################################################
    ######################################################################

    Pickup<public>(InItem : item_instance) : void =
        # if:
        #     not CanPickup[InItem]
        # then:
        #     Print("cannot pickup and return")
        #     return
        
        if:
            not CanPickup[InItem]
            Player := MaybePlayer?
            CustomPlayer := RefGameManager.GetCustomPlayer[Player]
        then:
            CustomPlayer.Redrop(InItem)

            return
    
        var PickedUpAmount : int = 0
        if:
            ItemSlotSpaceResult := FindItemSlot(InItem)
            ItemSlotSpaceResult(1) >= InItem.GetQuantity()
            ItemSlotIndex := ItemSlotSpaceResult(0)
            ItemSlotIndex <> -1
            ItemSlot := ItemSlots[ItemSlotIndex]
        then:
            # Print("Normal Picking up {InItem.GetName()} x{InItem.GetQuantity()}")
            Print("Place in first inventory")
            ItemSlot.AddItem(InItem)
            set PickedUpAmount = InItem.GetQuantity()




        else:
            DividedItemSlotsSpaceResults := FindItemSlots(InItem)
            var TotalSpaceNeeded : int = InItem.GetQuantity()
    
            for (ItemSlotSpaceResult : DividedItemSlotsSpaceResults, TotalSpaceNeeded > 0):
                ItemSlotIndex := ItemSlotSpaceResult(0)
                AvailableSpaceInThisSlot := ItemSlotSpaceResult(1)
                if (ItemSlotIndex >= 0 and AvailableSpaceInThisSlot > 0, ItemSlot := ItemSlots[ItemSlotIndex]):
                    AmountToAddToThisSlot : int = Min(AvailableSpaceInThisSlot, TotalSpaceNeeded)
                    ItemPortion := item_instance:
                        __Class := InItem.__Class
                        __Quantity := AmountToAddToThisSlot
                    ItemSlot.AddItem(ItemPortion)
                    set TotalSpaceNeeded -= AmountToAddToThisSlot
                    set PickedUpAmount  += AmountToAddToThisSlot
            if:
                TotalSpaceNeeded > 0
                Player := MaybePlayer?
                CustomPlayer := RefGameManager.GetCustomPlayer[Player]
            then:
                PartialStackItem := item_instance:
                    __Class := InItem.__Class
                    __Quantity := TotalSpaceNeeded
                # Print("Dropped \"{InItem.GetName()}\" again: {TotalSpaceNeeded}")
                CustomPlayer.Redrop(PartialStackItem)
            else:
                block{}
                # PrintError("Not enough Space in Inventory for \"{InItem.GetName()}\". Filled up as much as possible. Dropping {TotalSpaceNeeded} again")



        if:
            RefPlayer := MaybePlayer?
            CustomPlayer := RefGameManager.GetCustomPlayer[RefPlayer]
        then:
            CustomPlayer.AddRessource(InItem.GetItemType(), PickedUpAmount)


    ClearAll() : void = 
        for (ItemSlot : ItemSlots):
            ItemSlot.SetItem(false)

    DropAll() : void = 
        for:
            ItemSlot : ItemSlots
            RefPlayer := MaybePlayer?
            Item := ItemSlot.GetItem[]
            FortCharacter := RefPlayer.GetFortCharacter[]
            PlayerTransform := FortCharacter.GetTransform().Translation
            RandomAngleRad := GetRandomFloat(0.0, 6.2831853)
            RandomDirectionX := Cos(RandomAngleRad)
            RandomDirectionY := Sin(RandomAngleRad)
            Impulse := vector2{X := RandomDirectionX, Y := RandomDirectionY} * GetRandomFloat(-32.0, 196.0) # 128.0
        do:
            NewItem := item_instance:
                __Class := Item.__Class
                __Quantity := Item.__Quantity
            NewItem.Spawn(PlayerTransform , ?Impulse := Impulse)
            ItemSlot.SetItem(false)
            
    Consume<public>(Index : int, Amount : int) : void =
        if:
            ItemSlot := ItemSlots[Index]
        then:
            ItemSlot.DecreaseItem(Amount)

    Consume<public>(ItemType : item_type, Amount : int) : logic =
        for:
            Index->ItemSlot : ItemSlots
            SlotItemType := ItemSlot.GetItem[].GetItemType()
            SlotAmount := ItemSlot.GetItem[].GetQuantity()
            SlotItemType = ItemType
            SlotAmount >= Amount
        do:
            Self.Consume(Index, Amount)
            return true
        return false






    SwitchHotBarSlot<public>(NewActiveHotBarIndex : int) : void =
        for (Index->ItemSlot : ItemSlots, ItemSlot.GetHotBarSlot[]):
            if (Index <> NewActiveHotBarIndex):
                ItemSlot.MakeInactive()
            else:
                ItemSlot.MakeActive()

    GetItemSlot<public>(Index : int)<transacts><decides> : item_slot_wrapper =
        var MaybeItemSlot : ?item_slot_wrapper = false
        if (ItemSlot := ItemSlots[Index]):
            set MaybeItemSlot = option. ItemSlot
        return MaybeItemSlot? 
        
    GetItemSlots<public>()<transacts> : []item_slot_wrapper = ItemSlots

    FindEmptyItemSlot<private>()<transacts> : int = 
        for (Index->ItemSlot : ItemSlots, ItemSlot.IsEmpty[]):
            return Index
        # PrintError("Could not find Empty Item Slot")
        return -1

    FindItemSlots<private>(InItem : item_instance)<transacts> : []tuple(int, int) =
        if (InItem.GetItemType() = item_type.None):
            Assert("{InItem.GetName()} has no ItemType")
            return array{}
        
        var PossibleItemSlots : []tuple(int, int) = array{}
        for (Index->ItemSlot : ItemSlots):
            if:
                Space := ItemSlot.HasSpace[InItem]
            then:
                set PossibleItemSlots += array. (Index, Space)
        return PossibleItemSlots

    FindItemSlot<private>(InItem : item_instance)<transacts>: tuple(int, int) = 
        # if (InItem.GetItemType() = item_type.None):
        #     Assert("{InItem.GetName()} has no ItemType")
        #     return (-1, 0)
        # for:
        #     Index->ItemSlot : ItemSlots
        #     ItemSlot.GetItem[].GetItemType() = InItem.GetItemType()
        #     Space : int = ItemSlot.HasSpace[InItem]
        # do:
        #     return (Index, Space) 

        var BestFit : tuple(int, int) = (-1, -1)
        var SecondBestFit : tuple(int, int) = (-1, -1)
        var FoundBestFit : logic = false

        for:
            Index->ItemSlot : ItemSlots
            Space : int = ItemSlot.HasSpace[InItem]
            not FoundBestFit?
        do:
            if:
                ItemSlot.GetItem[].GetItemType() = InItem.GetItemType()
                ItemSlot.GetItem[].GetQuantity() + InItem.GetQuantity() < ItemSlot.GetItem[].GetStackSize()+1
            then:
                set BestFit = (Index, Space)
                set FoundBestFit = true
            if:
                SecondBestFit(0) = -1
                SecondBestFit(1) = -1
            then:
                set SecondBestFit = (Index, Space)

        

        if:
            not FoundBestFit?
        then:
            if:
                SecondBestFit(0) = -1
                SecondBestFit(1) = -1
            then:
                set BestFit = SecondBestFit
            else:
                set BestFit = (FindEmptyItemSlot(), InItem.GetStackSize())
        

        return BestFit

        # return (Index, Space) 

        # for (Index->ItemSlot : ItemSlots):
        #     if:
        #         Space : int = ItemSlot.HasSpace[InItem]
        #     then:
        #         return (Index, Space) 
        # return (FindEmptyItemSlot(), 0)


    CanPickup<public>(InItem : item_instance)<decides><transacts> : int =
        var SpaceInInventory : ?int = false
        ItemSlotSpaceResults := FindItemSlots(InItem)
        if (ItemSlotSpaceResults.Length > 0):
            var TotalSpace : int = 0
            for (ItemSlotSpaceResult : ItemSlotSpaceResults):
                set TotalSpace += ItemSlotSpaceResult(1)
            set SpaceInInventory = option. TotalSpace
            # Print("Inventory has Space for {TotalSpace} \"{InItem.GetName()}\"")
        return SpaceInInventory?

    ##### UI #####
    UI<private> : ui_inventory_wrapper = ui_inventory_wrapper{}
    AccessCloseButton<public>()<transacts> : button_loud = UI.CloseButton

    InitiateUI<private>(InPlayer : player, InGameManager : game_manager_device) : void = 
        UI.Initiate(RefGameManager)
        SlotSize := 75.0
        ContainerSize := 60.0

        var TempId : int = 0
        for (X := 0..8):
            HotBarPosition := vector2{ X := -4.0*HOT_BAR_SLOT_SIZE + ((X*1.0)*HOT_BAR_SLOT_SIZE), Y := 0.0 }
            Position := vector2{X := -1920.0/2.0 + 591.0 + SlotSize/2.0 + (X*83.0), Y := -1080.0/2.0 + 690.0 + SlotSize/2.0}
            
            HotBarSlot := ui_hotbar_slot_wrapper{}
            InventorySlot := item_slot_wrapper{ __HotBarSlot := option. HotBarSlot}
            InventorySlot.Initiate(TempId, Position, option. HotBarPosition, SlotSize, ContainerSize, UI.GetCanvas(), InGameManager, option. MainCanvas)
            set ItemSlots += array{InventorySlot}
            set TempId += 1
        for (Y := 0..2):
            for (X := 0..8):
                Position := vector2{X := -1920.0/2.0 + 591.0 + SlotSize/2.0 + (X*83.0), Y := -1080.0/2.0 + 432.0 + SlotSize/2.0 + (Y*83.0)}
                InventorySlot := item_slot_wrapper{}
                InventorySlot.Initiate(TempId, Position, false, SlotSize, ContainerSize, UI.GetCanvas(), InGameManager, false)
                set ItemSlots += array{InventorySlot}
                set TempId += 1
        if:
            CustomPlayer := RefGameManager.GetCustomPlayer[InPlayer]
            ItemSlot := ItemSlots[CustomPlayer.ActiveHotBarIndex]
        then:
            ItemSlot.MakeActive()

    Open<public>() : void =
        if (P := MaybePlayer?). UI.Open(P)
        for (ItemSlot : ItemSlots). ItemSlot.Open()

    Update<public>() : void =
        Assert("Update for Inventory is not yet implemented")
        # if (IsOpen()?). UI.Update()
        # for (ItemSlot : ItemSlots). ItemSlot.Update()
    
    Close<public>() : void = 
        if (P := MaybePlayer?). UI.Close(P)
        for (ItemSlot : ItemSlots). ItemSlot.Close()

    IsOpen<public>()<transacts> : logic = UI.IsOpen

    ShowHotBar<public>() : void = 
        for:
            ItemSlot : ItemSlots
            HotbarSlot := ItemSlot.GetHotBarSlot[]
        do:
            HotbarSlot.Show()  

    HideHotBar<public>() : void = 
        for:
            ItemSlot : ItemSlots
            HotbarSlot := ItemSlot.GetHotBarSlot[]
        do:
            HotbarSlot.Hide()  
    


    
################################
#           ITEM SLOT          #
################################
item_slot_wrapper := class():
    ##### CONSTRUCT #####
    
    ##### INITIALIZE #####
    var RefGameManager<private> : game_manager_device = game_manager_device{}
    var Id<private> : int = -1
    var MainCanvas<private> : canvas = canvas{}

    ##### VARIABLES #####
    var MaybeItem<private> : ?item_instance = false
    var IsActive<private> : logic = false

    GetMaybeItem<public>()<transacts> : ?item_instance = MaybeItem
    GetItem<public>()<transacts><decides> : item_instance = MaybeItem? 
    GetQuantity<public>()<transacts><decides> : int = MaybeItem?.GetQuantity() 
    IsEmpty<public>()<decides><transacts> : decides_result = { var D : ?decides_result = option. decides_result{}; if (MaybeItem?). set D = false; return D? }
    IsActiveHotbarSlot<public>()<transacts> : logic = IsActive


    HasSpace<public>(CheckForSpaceItem : item_instance)<decides><transacts> : int = 
        var SpaceForItem : ?int = false
        if:
            Item := MaybeItem?
        then:
            if:
                CheckForSpaceItem.GetItemType() = Item.GetItemType()
                SpaceLeft := Item.GetStackSize() - Item.GetQuantity()
                SpaceLeft > 0
            then:
                set SpaceForItem = option. SpaceLeft 
        else:
            set SpaceForItem = option. CheckForSpaceItem.GetStackSize()
        return SpaceForItem?

    var Initialized<private> : logic = false
    Initiate<public>(InId : int, InPosition : vector2, InHotbarPosition : ?vector2, SlotSize : float, ContainerSize : float, InCanvas : canvas, InGameManager : game_manager_device, InMainCanvas : ?canvas) : void = 
        if (Initialized?). Assert("Item Slot is already initialized")
        set Initialized = true
        
        set RefGameManager = InGameManager
        if (RealInMainCanvas := InMainCanvas?). set MainCanvas = RealInMainCanvas
        set Id = InId
        InitiateUI(InPosition, InHotbarPosition, SlotSize, ContainerSize, InCanvas)

    ##### FUNCTIONS #####
    MakeActive<public>() : void =
        if (HotBarSlot := __HotBarSlot?):
            set IsActive = true
            HotBarSlot.MakeActive()
        else:
            Assert("Tried to make None-HotbarSlot Active")

    MakeInactive<public>() : void =
        if (HotBarSlot := __HotBarSlot?):
            set IsActive = false
            HotBarSlot.MakeInactive()
        else:
            Assert("Tried to make None-HotbarSlot Inactive")

    SetItem<public>(InMaybeItem : ?item_instance) : void = 
        if:
            InItem := InMaybeItem?
            InItem.GetItemType() <> item_type.None
        then:
            set MaybeItem = option. InItem
        else:
            set MaybeItem = false
        Update()

    SetQuantity<public>(InQuantity : int) : void = 
        if (Item := MaybeItem?):
            Item.SetQuantity(InQuantity)
            Update()

    AddItem<public>(InItem : item_instance) : void =
        if:
            not MaybeItem?
        then:
            set MaybeItem = option. InItem
        else if:
            Item := MaybeItem?
            Item.GetItemType() <> item_type.None
            Item.GetItemType() = InItem.GetItemType()
        then:
            Item.IncreaseQuantity(InItem.GetQuantity())
        else:
            Assert("Could not add Item to to ItemSlot")
        Update()
            
    DecreaseItem<public>(Amount : int) : void = 
        if:
            Item := MaybeItem?
        then:
            if:
                Item.GetQuantity() > Amount
            then:
                Item.DecreaseQuantity(Amount)
            else if:
                Item.GetQuantity() - Amount = 0
            then:
                # Print("Quantity - Amount = 0")
                set MaybeItem = false
        else:
            Assert("Tried to decrease empty ItemSlot")
        Update()

    ##### UI #####
    UI<private> : ui_item_slot_wrapper = ui_item_slot_wrapper{}
    __HotBarSlot : ?ui_hotbar_slot_wrapper = false

    GetUI<public>()<transacts> : ui_item_slot_wrapper = UI
    GetHotBarSlot<public>()<transacts><decides> : ui_hotbar_slot_wrapper = __HotBarSlot?
   

    InitiateUI<private>(InPosition : vector2, InHotBarPosition : ?vector2, SlotSize : float, ContainerSize : float, InCanvas : canvas) : void = 
        UI.Initiate(InPosition, SlotSize, ContainerSize, InCanvas, RefGameManager)
        UI.Button.OnClick().Subscribe(DragItem)
        
        if:
            HotBarSlot := __HotBarSlot?
            HotBarPosition := InHotBarPosition? # vector2{ X := InPosition.X, Y := 0.0}
        then:
            HotBarSlot.Initiate(HotBarPosition, MainCanvas)

    Open<public>() : void = UI.Open(Self)
    Update<public>() : void = { if (HotBarSlot := __HotBarSlot?). HotBarSlot.Update(Self); if (IsOpen()?). UI.Update(Self); }
    Close<public>() : void = UI.Close()
    IsOpen<public>()<transacts> : logic = UI.IsOpen

    DragItem(WidgetMessage : widget_message) : void = 
        if:
            CustomPlayer := RefGameManager.GetCustomPlayer[WidgetMessage.Player] 
        then:
            if (ItemSlot := CustomPlayer.SelectedItemSlot?):
                ItemSlot.GetUI().Unhighlight()
                SwitchItemSlotContent(CustomPlayer, ItemSlot, Self)
                set CustomPlayer.SelectedItemSlot = false
            else if (MaybeItem?.GetItemType() <> item_type.None and MaybeItem?.GetQuantity() > 0):
                UI.Highlight()
                set CustomPlayer.SelectedItemSlot = option. Self
            # else:
            #     set CustomPlayer.SelectedItemSlot = false
            #     UI.Unhighlight()











##############################################
#           ITEM ASSET & PROPERTIES          #
##############################################


item_asset_wrapper := class<concrete>():
    @editable CreativePropAsset : ?creative_prop_asset = false
    @editable VFXPowerup : ?visual_effect_powerup_device = false

efficiency_type := enum{
    None
    Pickaxe
    Axe
    Shovel
    Shears
    Sword
}

rarity_type := enum{
    None,
    Common,
    Uncommon,
    Rare,
    Epic,
    Legendary
}

rarity_texture_map : [rarity_type]texture = map{
    (rarity_type.None=>VerseAssets.TransparentTexture)
    (rarity_type.Common=>VerseAssets.TransparentTexture)
    (rarity_type.Uncommon=>VerseAssets.Rarities.T_L2_Rarity)
    (rarity_type.Rare=>VerseAssets.Rarities.T_L3_Rarity)
    (rarity_type.Epic=>VerseAssets.Rarities.T_L4_Rarity)
    (rarity_type.Legendary=>VerseAssets.Rarities.T_L5_Rarity)
}

item_properties_wrapper := class<concrete>():
    @editable ActionType : action_type = action_type.None
    @editable StackSize : int = 64

    @editable Rarity : rarity_type = rarity_type.None
    
    @editable MaybeItemGranter : ?item_granter_device = false
    @editable MaybeDamagePowerup : ?damage_amplifier_powerup_device = false

    # @editable ToolProperties : tool_properties_wrapper = tool_properties_wrapper{} 
    @editable IsTool : logic = false
    @editable EfficiencyType : efficiency_type = efficiency_type.None
    @editable Durability : ?int = false
    @editable Strength : ?int = false
    @editable MiningEfficiency : ?float = false

    @editable Nutrition : ?float = false

    @editable IsBurnable : logic = false

action_type := enum{
    None
    IsPlaceable
    IsUseable
    IsEatable
    IsFortnite
    IsAmmunition
}

#################################
#           ITEM CLASS          #
#################################
item_class := class<concrete>():
    var RefItemManager<private> : item_manager_device = item_manager_device{}
    var RefGameManager<private> : game_manager_device = game_manager_device{}
    var RefRaycastManager<private> : raycast_manager_device = raycast_manager_device{}
    var RefAudioManager<private> : audio_manager_device = audio_manager_device{}

    @editable ItemTexture<private> : texture = VerseAssets.MissingTexture
    @editable ItemName<private> : string = ""
    @editable ItemType<private> : item_type = item_type.None
    @editable BlockType : block_type = block_type.None

    @editable ItemProperties<private> : item_properties_wrapper = item_properties_wrapper{}
    @editable ItemAssets<private> : item_asset_wrapper = item_asset_wrapper{}

    var Initialized<private> : logic = false
    Initiate<public>(InItemManagager : item_manager_device, InGameManager : game_manager_device, InRaycastManager : raycast_manager_device, InAudioManager : audio_manager_device) : void = 
        if (Initialized?). Assert("{ItemName} is already initialized")
        set RefGameManager = InGameManager
        set RefItemManager = InItemManagager
        set RefRaycastManager = InRaycastManager
        set RefAudioManager = InAudioManager

    AccessGameManager<public>()<transacts> : game_manager_device = RefGameManager
    AccessItemManager<public>()<transacts> : item_manager_device = RefItemManager
    AccessAudioManager<public>()<transacts> : audio_manager_device = RefAudioManager
    AccessRaycastManager<public>()<transacts> : raycast_manager_device = RefRaycastManager
    GetName<public>()<transacts> : string = ItemName
    GetItemType<public>()<transacts> : item_type = ItemType
    GetItemProperties<public>()<transacts> : item_properties_wrapper = ItemProperties
    GetTexture<public>()<transacts> : texture = ItemTexture
    GetBlockType<public>()<transacts> : block_type = BlockType
    GetStackSize<public>()<transacts> : int = ItemProperties.StackSize
    GetItemAssets<public>()<transacts> : item_asset_wrapper = ItemAssets
    GetCreativePropAsset<public>()<transacts> : ?creative_prop_asset = ItemAssets.CreativePropAsset
    GetVFXPowerup<public>()<decides><transacts> : visual_effect_powerup_device = ItemAssets.VFXPowerup?
    IsTool<public>()<transacts><decides> : item_properties_wrapper = { var DecidesResult : ?item_properties_wrapper = false; if (ItemProperties.IsTool?). set DecidesResult = option. ItemProperties; return DecidesResult? }
    GetRarityTexture<public>()<transacts> : texture = { if (Texture := rarity_texture_map[ItemProperties.Rarity]) { return Texture }; return VerseAssets.TransparentTexture; } 
    
    IsPlaceable<public>()<decides><transacts> : decides_result =  { var D : ?decides_result = false; if (ItemProperties.ActionType = action_type.IsPlaceable). set D = option. decides_result{}; return D? }
    IsUseable<public>()<decides><transacts> : decides_result = { var D : ?decides_result = false; if (ItemProperties.ActionType = action_type.IsUseable). set D = option. decides_result{}; return D? }
    IsEatable<public>()<decides><transacts> : decides_result =  { var D : ?decides_result = false; if (ItemProperties.ActionType = action_type.IsEatable). set D = option. decides_result{}; return D? }
    IsFortnite<public>()<decides><transacts>  : decides_result =  { var D : ?decides_result = false; if (ItemProperties.ActionType = action_type.IsFortnite). set D = option. decides_result{}; return D? }
    IsAmmunition<public>()<decides><transacts> : item_granter_device = { var MaybeGranter : ?item_granter_device = false; if (ItemProperties.ActionType = action_type.IsAmmunition, Granter := ItemProperties.MaybeItemGranter?) then { set MaybeGranter = option. Granter }; return MaybeGranter? }
    
    IsFortniteItem<public>()<decides><transacts> : tuple(item_granter_device, damage_amplifier_powerup_device) =  
        var MaybeTuple : ?tuple(item_granter_device, damage_amplifier_powerup_device) = false; 
        if:
            ItemProperties.ActionType = action_type.IsFortnite
            Granter := ItemProperties.MaybeItemGranter?
        then:
            if:
                Powerup := ItemProperties.MaybeDamagePowerup?
            then:
                set MaybeTuple = option. (Granter, Powerup) 
            else:
                set MaybeTuple = option. (Granter, AccessItemManager().EmptyDMGPowerup) 
        return MaybeTuple?

    IsBurnable<public>()<decides><transacts> : decides_result = { var D : ?decides_result = false; if (ItemProperties.IsBurnable?). set D = option. decides_result{}; return D? }
    GetStrength<public>()<decides><transacts> : int = ItemProperties.Strength?
    GetDurability<public>()<decides><transacts> : int = ItemProperties.Durability?
    GetNutrition<public>()<decides><transacts> : float = ItemProperties.Nutrition?
    GetEfficientType<public>()<transacts> : efficiency_type = ItemProperties.EfficiencyType

####################################
#           ITEM INSTANCE          #
####################################
__Count : int = 0


item_instance := class():
    ##### CONSTRUCT #####
    __Class : item_class
    var __Quantity : int
    
    ##### FUNCTIONS  #####
    GetClass<public>() : item_class = __Class
    GetQuantity<public>()<transacts> : int = __Quantity
    GetTexture<public>()<transacts> : texture = __Class.GetTexture()
    GetItemType<public>()<transacts> : item_type = __Class.GetItemType()
    GetStackSize<public>()<transacts> : int = __Class.GetStackSize()
    GetName<public>()<transacts> : string = __Class.GetName()
    GetBlockType<public>()<transacts> : block_type = __Class.GetBlockType()
    
    GetItemProperties<public>()<transacts> : item_properties_wrapper = __Class.GetItemProperties()
    IsTool<public>()<decides><transacts> : item_properties_wrapper = __Class.IsTool[]
    GetEfficiencyType<public>()<transacts> : efficiency_type = __Class.GetEfficientType()

    IsPlaceable<public>()<decides><transacts> : decides_result = __Class.IsPlaceable[]
    IsUseable<public>()<decides><transacts> : decides_result = __Class.IsUseable[] 
    IsEatable<public>()<decides><transacts> : decides_result = __Class.IsEatable[]
    IsFortnite<public>()<decides><transacts> : decides_result = __Class.IsFortnite[]
    IsAmmunition<public>()<decides><transacts> : item_granter_device = __Class.IsAmmunition[]
    GetStrength<public>()<decides><transacts> : int = __Class.GetStrength[]
    GetDurability<public>()<decides><transacts> : int = __Class.GetDurability[]
    GetNutrition<public>()<decides><transacts> : float = __Class.GetNutrition[]
    CheckReference<public>() : void = __Class.AccessItemManager().CheckReference()
    IsFortniteItem<public>()<decides><transacts> : tuple(item_granter_device, damage_amplifier_powerup_device) = __Class.IsFortniteItem[]
    GetRarityTexture<public>()<transacts> : texture = __Class.GetRarityTexture()

    #### QUANTITY ####
    SetQuantity<public>(NewQuantity : int) : void = set __Quantity = NewQuantity
    
    IncreaseQuantity<public>(AddQuantity : int) : void =
        if (__Quantity + AddQuantity > GetStackSize()): 
            Assert("Quantity of \"{GetName()}\" was increased over \"{GetStackSize()}\"")
        set __Quantity = __Quantity + AddQuantity
        
    DecreaseQuantity<public>(RemoveQuantity : int) : void =
        if (__Quantity - RemoveQuantity < 1):
            Assert("Quantity of \"{GetName()}\" was decreased under \"0\"") 
        set __Quantity = __Quantity - RemoveQuantity



    #### 3D MODEL ####
    var MaybeCreativeProp<private> : ?creative_prop = false
    var MaybeCreationTime<private> : ?float = false

    GetCreativeProp<public>()<decides><transacts> : creative_prop = MaybeCreativeProp?
    GetCreationTime<public>()<decides><transacts> : float = MaybeCreationTime?
    IsPickupable<public>()<decides><transacts> : creative_prop = MaybeCreativeProp?
    
    Spawn<public>(Position : vector3, ?Impulse : vector2 = vector2{X:=0.0, Y:=0.0}, ?MaybeApexHeightOffsetMultiplier : ?float = false) : void =
        spawn. SpawnSuspended(Position, ?Impulse := Impulse, ?MaybeApexHeightOffsetMultiplier := MaybeApexHeightOffsetMultiplier)
        
    Select(Agent : agent) : void = 
        if (VFXPowerup := __Class.GetVFXPowerup[]):
            VFXPowerup.Pickup(Agent)
        else:
            PrintError("{__Class.GetName()} has no VFX Powerup")
            __Class.AccessItemManager().EmptyVFXPowerup.Pickup(Agent)

            
    CalculateSpawnAnimationKeyframes<private>(StartPos : vector3, EndPos : vector3, TotalScaleMultiplier : float, IsFallingIntoVoid : logic, ?ApexHeightOffsetMultiplier : float = 1.0/2.1) : tuple([]keyframe_delta, float) =
        HorizontalDistance := Distance(ToVector2(StartPos), ToVector2(EndPos))
        BaseJumpTime := Clamp(0.3 + HorizontalDistance / (GRID_SIZE * 2.0), 0.2, 1.0)
    
        ApexHeightOffset : float = GRID_SIZE * ApexHeightOffsetMultiplier
        var ApexPos : vector3 = vector3:
            X := (StartPos.X + EndPos.X) / 2.0
            Y := (StartPos.Y + EndPos.Y) / 2.0
            Z := Max(StartPos.Z, EndPos.Z) + ApexHeightOffset
    
        IntermediateTargetZ : float = StartPos.Z - (GRID_SIZE / 2.0) + (GRID_SIZE * 0.334)
    
        TotalTargetYawRotation := PiFloat
    
        var AnimationKeyframes : []keyframe_delta = array{}
        var TotalAnimationTime : float = 0.0
    
        if (HorizontalDistance > GRID_SIZE/2.0):
            ThrowHeightMultiplier := 0.65
            ThrowTime := BaseJumpTime * 0.58 # Base estimated time for rotation calculation
            ThrowApexHeightOffset : float = (GRID_SIZE * 0.85) * ThrowHeightMultiplier
    
            HorizontalPercents := array{0.15, 0.30, 0.45, 0.55, 0.70, 0.85, 0.95}
            VerticalPercentsUp := array{0.40, 0.75, 0.95, 1.0}
            VerticalPercentsDown := array{0.95, 0.75, 0.40}
    
            ApexZ := Max(StartPos.Z, EndPos.Z) + ThrowApexHeightOffset
            VerticalRise := ApexZ - StartPos.Z
            VerticalFall := ApexZ - EndPos.Z
    
            var IntermediatePoints : []vector3 = array{}
    
            for (i := 0..3, HPercent := HorizontalPercents[i], VPercent := VerticalPercentsUp[i]):
                PointPos := vector3:
                    X := StartPos.X + (EndPos.X - StartPos.X) * HPercent
                    Y := StartPos.Y + (EndPos.Y - StartPos.Y) * HPercent
                    Z := StartPos.Z + VerticalRise * VPercent
                set IntermediatePoints += array{PointPos}
    
            for (i := 0..2, HPercent := HorizontalPercents[i+4], VPercent := VerticalPercentsDown[i]):
                PointPos := vector3:
                    X := StartPos.X + (EndPos.X - StartPos.X) * HPercent
                    Y := StartPos.Y + (EndPos.Y - StartPos.Y) * HPercent
                    Z := EndPos.Z + VerticalFall * VPercent
                set IntermediatePoints += array{PointPos}
    

            OriginalTimeSegments := array{
                ThrowTime * 0.12, ThrowTime * 0.13, ThrowTime * 0.13, ThrowTime * 0.10,
                ThrowTime * 0.10, ThrowTime * 0.13, ThrowTime * 0.13, ThrowTime * 0.15
            }
    
            ScalePerSegment16 := Pow(TotalScaleMultiplier, 1.0 / 16.0)
            ScaleVecSegment16 := vector3{X:=ScalePerSegment16, Y:=ScalePerSegment16, Z:=ScalePerSegment16}
    
            var CurrentPos : vector3 = StartPos
            for (i := 0..7, BaseOriginalTimeSegment := OriginalTimeSegments[i]):
                var OriginalTargetPos : vector3 = vector3{}
                if:
                    i < 7
                    EndPoint := IntermediatePoints[i]
                then:
                    set OriginalTargetPos = EndPoint
                else:
                    set OriginalTargetPos = EndPos
    
                OriginalDeltaLocation := OriginalTargetPos - CurrentPos
                var ActualOriginalTimeSegment : float = BaseOriginalTimeSegment
    
                if (OriginalDeltaLocation.Z < -GRID_SIZE):
                    VerticalDrop : float = Abs(OriginalDeltaLocation.Z)
                    set ActualOriginalTimeSegment = Max(0.01, (VerticalDrop / GRID_SIZE) * 0.3)
    
                DeltaLocationHalf := OriginalDeltaLocation / 2.0
                TimeHalf := ActualOriginalTimeSegment / 2.0

                YawAngleSegment := TotalTargetYawRotation * (ActualOriginalTimeSegment / ThrowTime)
                RotationHalf := rotation{}.ApplyYaw(YawAngleSegment / 2.0)
    
    
                var Interpolation1 : cubic_bezier_parameters = InterpolationTypes.Linear
                if (i = 0). set Interpolation1 = InterpolationTypes.EaseOut
    
                Keyframe1 : keyframe_delta = keyframe_delta {
                    DeltaLocation := DeltaLocationHalf
                    DeltaRotation := RotationHalf
                    DeltaScale := ScaleVecSegment16
                    Time := TimeHalf
                    Interpolation := Interpolation1
                }
                set AnimationKeyframes += array{Keyframe1}
    
                var Interpolation2 : cubic_bezier_parameters = InterpolationTypes.Linear
                if (i = 7). set Interpolation2 = InterpolationTypes.EaseIn
    
                Keyframe2 : keyframe_delta = keyframe_delta {
                    DeltaLocation := DeltaLocationHalf
                    DeltaRotation := RotationHalf
                    DeltaScale := ScaleVecSegment16
                    Time := TimeHalf
                    Interpolation := Interpolation2
                }
                set AnimationKeyframes += array{Keyframe2}
                set CurrentPos = OriginalTargetPos
    
        else if (EndPos.Z < IntermediateTargetZ):
            StartPosXY := ToVector2(StartPos)
            EndPosXY := ToVector2(EndPos)
            PreDropPosXY := StartPosXY + (EndPosXY - StartPosXY) * 0.75
            PreDropPos := vector3{X:=PreDropPosXY.X, Y:=PreDropPosXY.Y, Z:=IntermediateTargetZ}
    
            TimeSegment1 := BaseJumpTime * 0.5
            TimeSegment2 := BaseJumpTime * 0.5
            HeightDifference := PreDropPos.Z - EndPos.Z
            TimeSegment3 := Max(0.01, HeightDifference / GRID_SIZE * 0.3)
    
            ScalePerSegment := Pow(TotalScaleMultiplier, 1.0 / 3.0)
            ScaleVecSegment := vector3{X:=ScalePerSegment, Y:=ScalePerSegment, Z:=ScalePerSegment}
    
            RotationSegment1 := rotation{}.ApplyYaw(TotalTargetYawRotation * (TimeSegment1 / TotalAnimationTime))
            RotationSegment2 := rotation{}.ApplyYaw(TotalTargetYawRotation * (TimeSegment2 / TotalAnimationTime))
            RotationSegment3 := rotation{}.ApplyYaw(TotalTargetYawRotation * (TimeSegment3 / TotalAnimationTime))
    
            Keyframe1 : keyframe_delta = keyframe_delta {
                DeltaLocation := ApexPos - StartPos
                DeltaRotation := RotationSegment1
                DeltaScale := ScaleVecSegment
                Time := TimeSegment1
                Interpolation := InterpolationTypes.EaseOut
            }
            Keyframe2 : keyframe_delta = keyframe_delta {
                DeltaLocation := PreDropPos - ApexPos
                DeltaRotation := RotationSegment2
                DeltaScale := ScaleVecSegment
                Time := TimeSegment2
                Interpolation := InterpolationTypes.EaseIn
            }
            Keyframe3 : keyframe_delta = keyframe_delta {
                DeltaLocation := EndPos - PreDropPos
                DeltaRotation := RotationSegment3
                DeltaScale := ScaleVecSegment
                Time := TimeSegment3
                Interpolation := InterpolationTypes.Linear
            }
            set AnimationKeyframes = array{Keyframe1, Keyframe2, Keyframe3}

        else:
            # set ApexPos.Z = Max(StartPos.Z, EndPos.Z) + GRID_SIZE / 2.5
            
            SlowdownFactor : float = 1.1
            AdjustedTotalTime := BaseJumpTime * SlowdownFactor
            TimePerSegment := AdjustedTotalTime / 8.0

            ScalePerSegment8 := Pow(TotalScaleMultiplier, 1.0 / 8.0)
            ScaleVecSegment8 := vector3{X:=ScalePerSegment8, Y:=ScalePerSegment8, Z:=ScalePerSegment8}

            TotalLocationDeltaUp := ApexPos - StartPos
            TotalLocationDeltaDown := EndPos - ApexPos

            TotalVerticalRise := TotalLocationDeltaUp.Z
            TotalVerticalFall := TotalLocationDeltaDown.Z

            HorizontalDeltaUpSegment := vector2{X := TotalLocationDeltaUp.X / 4.0, Y := TotalLocationDeltaUp.Y / 4.0}
            HorizontalDeltaDownSegment := vector2{X := TotalLocationDeltaDown.X / 4.0, Y := TotalLocationDeltaDown.Y / 4.0}

            VerticalPercentagesUp := array{0.40, 0.30, 0.20, 0.10}
            VerticalPercentagesDown := array{0.10, 0.20, 0.30, 0.40}

            RotationPerSegment := rotation{}.ApplyYaw(TotalTargetYawRotation / 8.0)

            var Keyframe1 : keyframe_delta = keyframe_delta{ DeltaLocation := vector3{}, DeltaRotation := rotation{}, DeltaScale := vector3{}, Time := 0.0}
            if (VertPercent0 := VerticalPercentagesUp[0]):
                set Keyframe1 = keyframe_delta {
                    DeltaLocation := vector3{X := HorizontalDeltaUpSegment.X, Y := HorizontalDeltaUpSegment.Y, Z := TotalVerticalRise * VertPercent0}
                    DeltaRotation := RotationPerSegment
                    DeltaScale := ScaleVecSegment8
                    Time := TimePerSegment
                    Interpolation := InterpolationTypes.EaseOut
                }

            var Keyframe2 : keyframe_delta = keyframe_delta{ DeltaLocation := vector3{}, DeltaRotation := rotation{}, DeltaScale := vector3{}, Time := 0.0}
            if (VertPercent1 := VerticalPercentagesUp[1]):
                set Keyframe2 = keyframe_delta {
                    DeltaLocation := vector3{X := HorizontalDeltaUpSegment.X, Y := HorizontalDeltaUpSegment.Y, Z := TotalVerticalRise * VertPercent1}
                    DeltaRotation := RotationPerSegment
                    DeltaScale := ScaleVecSegment8
                    Time := TimePerSegment
                    Interpolation := InterpolationTypes.Linear
                }

            var Keyframe3 : keyframe_delta = keyframe_delta{ DeltaLocation := vector3{}, DeltaRotation := rotation{}, DeltaScale := vector3{}, Time := 0.0}
            if (VertPercent2 := VerticalPercentagesUp[2]):
                set Keyframe3 = keyframe_delta {
                    DeltaLocation := vector3{X := HorizontalDeltaUpSegment.X, Y := HorizontalDeltaUpSegment.Y, Z := TotalVerticalRise * VertPercent2}
                    DeltaRotation := RotationPerSegment
                    DeltaScale := ScaleVecSegment8
                    Time := TimePerSegment
                    Interpolation := InterpolationTypes.Linear
                }

            var Keyframe4 : keyframe_delta = keyframe_delta{ DeltaLocation := vector3{}, DeltaRotation := rotation{}, DeltaScale := vector3{}, Time := 0.0}
            if (VertPercent3 := VerticalPercentagesUp[3]):
                set Keyframe4 = keyframe_delta {
                    DeltaLocation := vector3{X := HorizontalDeltaUpSegment.X, Y := HorizontalDeltaUpSegment.Y, Z := TotalVerticalRise * VertPercent3}
                    DeltaRotation := RotationPerSegment
                    DeltaScale := ScaleVecSegment8
                    Time := TimePerSegment
                    Interpolation := InterpolationTypes.Linear
                }

            var Keyframe5 : keyframe_delta = keyframe_delta{ DeltaLocation := vector3{}, DeltaRotation := rotation{}, DeltaScale := vector3{}, Time := 0.0}
            if (VertPercentDown0 := VerticalPercentagesDown[0]):
                set Keyframe5 = keyframe_delta {
                    DeltaLocation := vector3{X := HorizontalDeltaDownSegment.X, Y := HorizontalDeltaDownSegment.Y, Z := TotalVerticalFall * VertPercentDown0}
                    DeltaRotation := RotationPerSegment
                    DeltaScale := ScaleVecSegment8
                    Time := TimePerSegment
                    Interpolation := InterpolationTypes.Linear
                }

            var Keyframe6 : keyframe_delta = keyframe_delta{ DeltaLocation := vector3{}, DeltaRotation := rotation{}, DeltaScale := vector3{}, Time := 0.0}
            if (VertPercentDown1 := VerticalPercentagesDown[1]):
                set Keyframe6 = keyframe_delta {
                    DeltaLocation := vector3{X := HorizontalDeltaDownSegment.X, Y := HorizontalDeltaDownSegment.Y, Z := TotalVerticalFall * VertPercentDown1}
                    DeltaRotation := RotationPerSegment
                    DeltaScale := ScaleVecSegment8
                    Time := TimePerSegment
                    Interpolation := InterpolationTypes.Linear
                }

            var Keyframe7 : keyframe_delta = keyframe_delta{ DeltaLocation := vector3{}, DeltaRotation := rotation{}, DeltaScale := vector3{}, Time := 0.0}
            if (VertPercentDown2 := VerticalPercentagesDown[2]):
                set Keyframe7 = keyframe_delta {
                    DeltaLocation := vector3{X := HorizontalDeltaDownSegment.X, Y := HorizontalDeltaDownSegment.Y, Z := TotalVerticalFall * VertPercentDown2}
                    DeltaRotation := RotationPerSegment
                    DeltaScale := ScaleVecSegment8
                    Time := TimePerSegment
                    Interpolation := InterpolationTypes.Linear
                }

            var Keyframe8 : keyframe_delta = keyframe_delta{ DeltaLocation := vector3{}, DeltaRotation := rotation{}, DeltaScale := vector3{}, Time := 0.0}
            if (VertPercentDown3 := VerticalPercentagesDown[3]):
                set Keyframe8 = keyframe_delta {
                    DeltaLocation := vector3{X := HorizontalDeltaDownSegment.X, Y := HorizontalDeltaDownSegment.Y, Z := TotalVerticalFall * VertPercentDown3}
                    DeltaRotation := RotationPerSegment
                    DeltaScale := ScaleVecSegment8
                    Time := TimePerSegment
                    Interpolation := InterpolationTypes.EaseIn
                }

            set AnimationKeyframes = array{
                Keyframe1, Keyframe2, Keyframe3, Keyframe4,
                Keyframe5, Keyframe6, Keyframe7, Keyframe8
            }

        if (IsFallingIntoVoid?):
            FallDistance := GRID_SIZE * 2.0
            FallTime := Max(0.01, (FallDistance / GRID_SIZE) * 0.3)
            FallDeltaLocation := vector3{X:=0.0, Y:=0.0, Z:=-FallDistance}
    
            KeyframeFall : keyframe_delta = keyframe_delta {
                DeltaLocation := FallDeltaLocation
                DeltaRotation := rotation{}
                DeltaScale := vector3{X:=1.0, Y:=1.0, Z:=1.0}
                Time := FallTime
                Interpolation := InterpolationTypes.Linear
            }
            set AnimationKeyframes += array{ KeyframeFall }
    
        for (KeyFrame : AnimationKeyframes). set TotalAnimationTime += KeyFrame.Time
        return (AnimationKeyframes, TotalAnimationTime)

    SpawnSuspended<private>(Position : vector3, ?Impulse : vector2 = vector2{X:=0.0, Y:=0.0}, ?MaybeApexHeightOffsetMultiplier : ?float = false)<suspends> : void =
        DistanceFromGround : float = GRID_SIZE * 0.334
        var ItemSize : float = 1.0
        if (__Class.GetBlockType() <> block_type.None):
            set ItemSize = 0.3
        
        MaxOffset : float = GRID_SIZE / 2.1
    
        var ActualPosition : vector3 = vector3{}
        var IsFallingIntoVoid : logic = false
        
        var OffsetX : float = Impulse.X
        var OffsetY : float = Impulse.Y
        if (OffsetX = 0.0 and OffsetY = 0.0):
            set OffsetX = GetRandomFloat(-MaxOffset, MaxOffset)
            set OffsetY = GetRandomFloat(-MaxOffset, MaxOffset)
        OffsetXY := vector3{X := OffsetX, Y := OffsetY, Z := 0.0}


        RayStart := Position + vector3{X:=OffsetX, Y:=OffsetY, Z:=GRID_SIZE*0.49}
        HitResult := __Class.AccessRaycastManager().Raycast(RayStart, direction.Down, raycast_type.Extended)

        var BaseGroundPosition : vector3 = vector3{}
        if (HitResult.HasHit?):
            set BaseGroundPosition = vector3{X:=Position.X + OffsetX, Y:=Position.Y + OffsetY, Z:=HitResult.HitPosition.Z}
        else:
            set BaseGroundPosition = vector3{X:=Position.X + OffsetX, Y:=Position.Y + OffsetY, Z:=G2W(ITEM_VOID)}
            set IsFallingIntoVoid = true

        set ActualPosition = BaseGroundPosition + vector3{X:=0.0, Y:=0.0, Z:=DistanceFromGround}
    
        RandomYawDegrees := GetRandomFloat(0.0, 360.0)
        InitialRotation := MakeRotation(vector3{Z:=1.0}, RandomYawDegrees)
    
        InitialScaleFactor := 1.0 / 1.5
        InitialTransform := transform:
            Translation := Position
            Rotation := InitialRotation
            Scale := vector3{X:=ItemSize, Y:=ItemSize, Z:=ItemSize} * InitialScaleFactor

        var CreativePropAsset : creative_prop_asset = __Class.AccessItemManager().MissingItemCreativePropAsset
        if (ActualCreativePropAsset := __Class.GetCreativePropAsset()?):
            set CreativePropAsset = ActualCreativePropAsset

            # VerseAssets.TestBlueprint

        SpawnPropResult := SpawnProp(CreativePropAsset, InitialTransform)    
        if (SpawnPropResult(1) = spawn_prop_result.TooManyProps):
            Assert("Could not spawn Item because there are too many Props")
        else if (SpawnPropResult(1) = spawn_prop_result.SpawnPointOutOfBounds):
            Assert("Could not spawn Item because Spawn Point is out of Bounds")
        else if (SpawnPropResult(1) = spawn_prop_result.InvalidSpawnPoint):
            Assert("Could not spawn Item because Spawn Point is invalid")
        else if (SpawnPropResult(1) = spawn_prop_result.UnknownError):
            Assert("Could not spawn Item because of unknown error")
        else if (SpawnPropResult(1) = spawn_prop_result.Ok, SpawnedCreativeProp := SpawnPropResult(0)?):
            var SpawnAnimation : tuple([]keyframe_delta,float) = (array{}, 0.0)
            if(ApexHeightOffsetMultiplier := MaybeApexHeightOffsetMultiplier?):
                set SpawnAnimation = CalculateSpawnAnimationKeyframes(Position, ActualPosition, 1.0/InitialScaleFactor, IsFallingIntoVoid, ?ApexHeightOffsetMultiplier:=ApexHeightOffsetMultiplier)
            else:
                set SpawnAnimation = CalculateSpawnAnimationKeyframes(Position, ActualPosition, 1.0/InitialScaleFactor, IsFallingIntoVoid)
            AnimationKeyframes := SpawnAnimation(0)
            SpawnAnimationDuration := SpawnAnimation(1) 
            if (AnimationController := SpawnedCreativeProp.GetAnimationController[]):
                AnimationController.SetAnimation(AnimationKeyframes, ?Mode := animation_mode.OneShot)
                AnimationController.Play()
    
            __Class.AccessItemManager().__AddItemOnGround(Self)
            set MaybeCreativeProp = option{SpawnedCreativeProp}
            set MaybeCreationTime = option{GetSecondsSinceEpoch()}
            Suspend(Spin, SpawnAnimationDuration)
            
    Pickup<public>(Player : player) : void =
        spawn. PickupSuspended(Player)

    PickupSuspended<private>(Player : player)<suspends> : void =
        __Class.AccessAudioManager().PlayPickupSound(Player) 
        if (ItemGranter := IsAmmunition[]) then ItemGranter.GrantItem(Player)
        else if (P := __Class.AccessGameManager().GetCustomPlayer[Player]) then P.Pickup(Self)
            
        if:
            CreativeProp := MaybeCreativeProp?
            FortCharacter := Player.GetFortCharacter[]
        then:
            var TimeToRemove : float = 0.0
            var Transform : transform = transform:
                Rotation := CreativeProp.GetTransform().Rotation
                Scale := CreativeProp.GetTransform().Scale
            loop:
                PlayerPosition := FortCharacter.GetTransform().Translation
                ItemPosition := CreativeProp.GetTransform().Translation
                if:
                    Distance(PlayerPosition, ItemPosition) < 32.0 or 
                    not FortCharacter.IsActive[]
                then:
                    break
                else:
                    set Transform.Translation = PlayerPosition
                    if (TimeToRemove > 0.0425*3):
                        CreativeProp.MoveTo(Transform, 0.05)
                        break
                    CreativeProp.MoveTo(Transform, 0.17 - TimeToRemove)
                    set TimeToRemove += 0.0425
            if:
                AnimationController := CreativeProp.GetAnimationController[]
                AnimationState := AnimationController.GetState()
                AnimationState = animation_controller_state.Playing
            then:
                AnimationController.Stop()

            set MaybeCreativeProp = false
            set MaybeCreationTime = false
            CreativeProp.Dispose()





    Despawn() : void = 
        if (CreativeProp := MaybeCreativeProp?): 
            set MaybeCreativeProp = false
            set MaybeCreationTime = false
            
            if:
                AnimationController := CreativeProp.GetAnimationController[]
                AnimationState := AnimationController.GetState()
                AnimationState = animation_controller_state.Playing
            then:
                AnimationController.Stop()
            CreativeProp.Dispose()


    Spin() : void =
        if (not GetCreativeProp[].IsValid[]):
            return

        OscillateHeight := 15.0 
        Time := 0.8

        MovementKeyFrame: keyframe_delta = keyframe_delta {
            DeltaLocation := vector3{X:=0.0, Y:=0.0, Z:=OscillateHeight}
            DeltaRotation := rotation{}.ApplyYaw(PiFloat-0.00001)
            DeltaScale := vector3{X:=1.0, Y:=1.0, Z:=1.0}
            Time := Time
            Interpolation := InterpolationTypes.Linear
        }

        MovementKeyFrame2: keyframe_delta = keyframe_delta {
            DeltaLocation := vector3{X:=0.0, Y:=0.0, Z:=-OscillateHeight}
            DeltaRotation := DeltaRotation := rotation{}.ApplyYaw(PiFloat-0.00001)
            DeltaScale := vector3{X:=1.0, Y:=1.0, Z:=1.0}

            Time := Time
            Interpolation := InterpolationTypes.Linear
        }

        if:
            AnimationController := GetCreativeProp[].GetAnimationController[]
            AnimationState := AnimationController.GetState()
        then:
            if (AnimationState = animation_controller_state.Playing):
                AnimationController.Stop()
            FortVaderKeyFrames : []keyframe_delta = array{MovementKeyFrame, MovementKeyFrame2}
            AnimationController.SetAnimation(FortVaderKeyFrames, ?Mode:=animation_mode.Loop)
            AnimationController.Play()
        else:
            PrintError("Could not get AnimationController of Creative Prop")








    ##### VARIABLES #####
    var Durability : ?int = false

    
    

    
    
###################################
#           ITEM MANAGER          #
###################################
item_manager_device := class(creative_device):
    @editable GameManager : game_manager_device = game_manager_device{}
    @editable RaycastManager : raycast_manager_device = raycast_manager_device{}
    @editable AudioManager : audio_manager_device = audio_manager_device{}

    @editable TestInputTrigger : input_trigger_device = input_trigger_device{}
    @editable TestButton : button_device = button_device{}

    @editable MissingItemCreativePropAsset : creative_prop_asset = DefaultCreativePropAsset
    @editable EmptyVFXPowerup : visual_effect_powerup_device = visual_effect_powerup_device{}
    @editable EmptyDMGPowerup : damage_amplifier_powerup_device = damage_amplifier_powerup_device{}
    @editable ItemRemover : item_remover_device = item_remover_device{}


    InitializedEvent<public> : event() = event(){}
    var IsInitialized<public> : logic = false
    
    OnBegin<override>()<suspends> : void =
        set __ItemClasses += BlockItems
        set __ItemClasses += ToolItemClasses
        set __ItemClasses += MiscellaneousItemClasses
        set __ItemClasses += FoodItemClasses
        set __ItemClasses += CropsItemClasses
        set __ItemClasses += FortniteItemClasses
        set __ItemClasses += ResourceItemClasses
        var ErrorAppeared : logic = false

        for (I->ItemClass : __ItemClasses):
            if (ItemClass.GetItemType() = item_type.None):
                # Assert("ItemClasses are not set up correctly. ItemClass with ItemType \"None\" found")
                PrintError("ItemClasses are not set up correctly. ItemClass with ItemType \"None\" found")
                set ErrorAppeared = true
            for (J->OtherItemClass : __ItemClasses, I <> J, ItemClass.GetItemType() = OtherItemClass.GetItemType()):
                # Assert("ItemClasses are not set up correctly. Two ItemClasses share the same ItemType \"{ItemClass.GetName()}\"")
                PrintError("ItemClasses are not set up correctly. ItemClass with ItemType \"None\" found")
                set ErrorAppeared = true
                
            ItemClass.Initiate(Self, GameManager, RaycastManager, AudioManager)

        if (ErrorAppeared?):
            # Print("ErrorAppeared")
            Assert("ItemClasses are not set up correctly. ItemClass with wrong ItemType found")

        spawn. HandleItems()
        TestButton.InteractedWithEvent.Subscribe(TestButtonFunction)
        TestInputTrigger.PressedEvent.Subscribe(TestButtonFunction)

        InitializedEvent.Signal()
        set IsInitialized = true

    TestButtonFunction(Agent : agent) : void = 
        if (CustomPlayer := GameManager.GetCustomPlayer[Agent]):
            CustomPlayer.DecreaseHungerBar(10.0)

            
        GrantItem(Agent, item_type.Carrot, ?Amount := 10)
        GrantItem(Agent, item_type.GoldenCarrot, ?Amount := 10)


        GrantItem(Agent, item_type.L1_SemiAutoPistol)
        GrantItem(Agent, item_type.L1_AssaultRifle)
        GrantItem(Agent, item_type.L1_BurstRifle)
        GrantItem(Agent, item_type.L1_RocketLauncher)
        GrantItem(Agent, item_type.L4_Scar)
        GrantItem(Agent, item_type.GrapplingHook)


        GrantItem(Agent, item_type.SpruceSapling, ?Amount := 25)
        GrantItem(Agent, item_type.SpruceLog, ?Amount := 25)
        GrantItem(Agent, item_type.SpruceLeaves, ?Amount := 25)

        GrantItem(Agent, item_type.Gunpowder)
        GrantItem(Agent, item_type.RottenFlesh, ?Amount := 25)
        GrantItem(Agent, item_type.CookedFlesh, ?Amount := 50)
        GrantItem(Agent, item_type.LightAmmunition, ?Amount := 1)
        GrantItem(Agent, item_type.RocketAmmunition, ?Amount := 5)
        
        GrantItem(Agent, item_type.IronIngot, ?Amount := 30)
        GrantItem(Agent, item_type.NuggetsCowboy, ?Amount := 5)
        GrantItem(Agent, item_type.Netherbrick, ?Amount := 10)

        
        # GrantItem(Agent, item_type.Hayball, ?Amount := 3)
        # GrantItem(Agent, item_type.Netherrack, ?Amount := 64)
        # GrantItem(Agent, item_type.GrassBlock, ?Amount := 64)
        # GrantItem(Agent, item_type.OakSapling, ?Amount := 53)

        GrantItem(Agent, item_type.Sand, ?Amount := 64)
        GrantItem(Agent, item_type.Sandstone, ?Amount := 53)
        GrantItem(Agent, item_type.Diamond, ?Amount := 53)
        GrantItem(Agent, item_type.IronIngot, ?Amount := 53)
        GrantItem(Agent, item_type.GoldIngot, ?Amount := 53)

        # GrantItem(Agent, item_type.Diorite, ?Amount := 34)
        # GrantItem(Agent, item_type.GrayConcrete, ?Amount := 34)
        GrantItem(Agent, item_type.Furnace, ?Amount := 20)
        GrantItem(Agent, item_type.CraftingTable, ?Amount := 20)
        # GrantItem(Agent, item_type.CraftingTable)
        # GrantItem(Agent, item_type.StoneSword)
        # GrantItem(Agent, item_type.StonePickaxe)
        # GrantItem(Agent, item_type.StoneAxe)
        # GrantItem(Agent, item_type.StoneShovel)

        # GrantItem(Agent, item_type.IronSword)
        # GrantItem(Agent, item_type.IronPickaxe)
        # GrantItem(Agent, item_type.IronAxe)
        # GrantItem(Agent, item_type.IronShovel)

        # GrantItem(Agent, item_type.GoldenSword)
        # GrantItem(Agent, item_type.GoldenPickaxe)
        # GrantItem(Agent, item_type.GoldenAxe)
        # GrantItem(Agent, item_type.GoldenShovel)
        
        # GrantItem(Agent, item_type.DiamondSword)
        # GrantItem(Agent, item_type.DiamondPickaxe)
        # GrantItem(Agent, item_type.DiamondAxe)
        # GrantItem(Agent, item_type.DiamondShovel)

        spawn. TestButtonFunctionSuspended(Agent)        
        
    TestButtonFunctionSuspended(Agent : agent)<suspends> : void =
        RaycastHit := RaycastManager.Raycast(Agent, false)

        if (not RaycastHit.HasHit?):
            return

        SpawnItem(RaycastHit.HitPosition, item_type.GrassBlock, ?Amount := 64)
        SpawnItem(RaycastHit.HitPosition, item_type.GrassBlock, ?Amount := 42)
        SpawnItem(RaycastHit.HitPosition, item_type.GrassBlock, ?Amount := 35)
        SpawnItem(RaycastHit.HitPosition, item_type.GrassBlock, ?Amount := 57)
        SpawnItem(RaycastHit.HitPosition, item_type.GrassBlock, ?Amount := 27)
        SpawnItem(RaycastHit.HitPosition, item_type.GrassBlock, ?Amount := 13)
        SpawnItem(RaycastHit.HitPosition, item_type.GrassBlock, ?Amount := 63)
        
        SpawnItem(RaycastHit.HitPosition, item_type.Sand, ?Amount := 33)
        SpawnItem(RaycastHit.HitPosition, item_type.Sand, ?Amount := 64)
        SpawnItem(RaycastHit.HitPosition, item_type.Sand, ?Amount := 45)
        SpawnItem(RaycastHit.HitPosition, item_type.Sand, ?Amount := 11)

        SpawnItem(RaycastHit.HitPosition, item_type.DiamondSword, ?Amount := 1)
        SpawnItem(RaycastHit.HitPosition, item_type.DiamondPickaxe, ?Amount := 1)
        
        SpawnItem(RaycastHit.HitPosition, item_type.DiamondAxe, ?Amount := 1)

        SpawnItem(RaycastHit.HitPosition, item_type.DiamondShovel, ?Amount := 1)

    CheckReference<public>() : void = { if (__ItemClasses.Length < 1). Assert("Reference to ItemManager is not set up properly"); }


    var __ItemClasses : []item_class = array{}
    @editable BlockItems : []item_class = array{}
    @editable ToolItemClasses : []item_class = array{}
    @editable MiscellaneousItemClasses : []item_class = array{}
    @editable CropsItemClasses : []item_class = array{}
    @editable FoodItemClasses : []item_class = array{}
    @editable FortniteItemClasses : []item_class = array{}
    @editable ResourceItemClasses : []item_class = array{}

    GetItemClass(ItemType : item_type)<decides><transacts> : item_class =
        var MaybeItemClass : ?item_class = false
        var Break : logic = false
        for (ItemClass : __ItemClasses, not Break?, ItemClass.GetItemType() = ItemType):
            set Break = true
            set MaybeItemClass = option. ItemClass 
        # if (not Break?). Assert("Could not find ItemClass")
        return MaybeItemClass?
    
    GetItemName(ItemType : item_type)<transacts> : string =
        if:
            ItemClass := GetItemClass[ItemType]
        then:
            # Print("{ItemClass.GetName()}")
            return ItemClass.GetName() 
        return ""
        
    


    CreateItem(ItemType : item_type, Quantity : int)<decides><transacts> : item_instance =
        var MaybeItem : ?item_instance = false
        if:
            Class := GetItemClass[ItemType] 
            Quantity > 0
            Quantity <= Class.GetStackSize()
        then:
            Item := item_instance:
                __Class := Class
                __Quantity := Quantity
            set MaybeItem = option. Item 
        # PrintError("")
        return MaybeItem?

    GrantItem(Agent : agent, ItemType : item_type, ?Amount : int = 1) : void = 
        if:
            Item := CreateItem[ItemType, Amount]
            Player := player[Agent]
        then:
            Item.Pickup(Player)
        else:
            PrintError("Could not grant Item to Player") 

    SpawnItem(WorldPosition : vector3, ItemType : item_type, ?Amount : int = 1, ?Impulse : vector2 = vector2{X:=0.0, Y:=0.0}, ?MaybeApexHeightOffsetMultiplier : ?float = false) : void = 
        if:
            Item : item_instance = CreateItem[ItemType, Amount] 
        then:
            Item.Spawn(WorldPosition, ?MaybeApexHeightOffsetMultiplier := MaybeApexHeightOffsetMultiplier, ?Impulse:=Impulse)
        else:
            PrintError("Could not spawn Item in World") 
    
    # GrantItems(Agent : agent, ItemType : item_type, Amount : int) : void = 
    #     if:
    #         CustomPlayer := GameManager.GetCustomPlayer[Agent]
    #         Item := CreateItem[ItemType]
    #     then:
    #         CustomPlayer.Pickup(Item)
    #     else:
    #         PrintError("Could not grant Item to Player") 





    var __ItemsOnGround : []item_instance = array{}
    __AddItemOnGround(Item : item_instance) : void = set __ItemsOnGround += array. Item;
    __RemoveItemFromGround(Index : int) : void = if (UpdatedArray := __ItemsOnGround.RemoveElement[Index]). set __ItemsOnGround = UpdatedArray

    HandleItems()<suspends> : void = 
        FrameTime := 0.0
        MinAge := 0.85
        
        # var Cycles : int = 0
        # var StartTime : float = GetSecondsSinceEpoch()
        # var PrintCycle : logic = true
        loop:
            # if (PROFILE_PERFORMANCE?):
            #     if (PrintCycle?):
            #         set Cycles += 1
            #         if (GetSecondsSinceEpoch() - StartTime > 30.0):
            #             Print("Did {Cycles} Cycles in 30 Seconds. HandleItems()")
            #             set PrintCycle = false   

            var ItemIndexesToRemove : []int = array{}
            for (Index->Item : __ItemsOnGround, CreativeProp := Item.GetCreativeProp[], CreationTime := Item.GetCreationTime[]):
                Age := GetSecondsSinceEpoch() - CreationTime
                if:
                    Age < DESPAWN_TIME
                    ItemPosition := CreativeProp.GetTransform().Translation
                    ItemPosition.Z > G2W(ITEM_VOID+1)
                then:
                    if (Age > MinAge and Item.GetCreativeProp[].IsValid[]):
                        for:
                            CustomPlayer : GameManager.CustomPlayerArray
                            FortCharacter := CustomPlayer.RefPlayer.GetFortCharacter[]
                            CustomPlayer.IsAlive[]
                        do:
                            var VerticalOffset : float = 0.0
                            if:
                                not FortCharacter.IsCrouching[]
                            then:
                                set VerticalOffset = GRID_SIZE * 0.25

                            # PlayerPosition2 := FortCharacter.GetTransform().Translation
                            # Print("Distance: {Abs(PlayerPosition2.Z - ItemPosition.Z)}")

                            if:
                                CustomPlayer.CanPickup[Item]
                                Item.IsPickupable[]
                                PlayerPosition := FortCharacter.GetTransform().Translation
                                HorizontalDistance := Distance(ToVector2(PlayerPosition), ToVector2(ItemPosition)) 
                                HorizontalDistance < PICKUP_RANGE
                                Abs(PlayerPosition.Z - ItemPosition.Z) < GRID_SIZE + VerticalOffset
                            then:
                                set ItemIndexesToRemove += array. Index
                                Item.Pickup(CustomPlayer.RefPlayer)
                else:
                    # Print("Despawning {Item.GetName()} after {Age} seconds")
                    set ItemIndexesToRemove += array. Index
                    Item.Despawn()

            for (I := 0..ItemIndexesToRemove.Length-1, Index := ItemIndexesToRemove[ItemIndexesToRemove.Length-1-I]):
                __RemoveItemFromGround(Index)
            Sleep(FrameTime)--- </item_manager_device.verse> ---

--- <quest_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /Fortnite.com/Characters }

quest_type := enum{
    None
    Craft
    Destroy
    Pickup
    Grow
    Place
    Cook
    Custom
    Buy
    LevelUp
}
    

increase_event_data := struct:
    Agent : agent
    Type : quest_type
    Value : string
    Amount : int

completed_event_wrapper := class():
    QuestWrappers : []quest_wrapper

    DeactivateIndicatorAfter(MapIndicator : map_indicator_device, Agent : agent, DeactivateTime : float)<suspends> : void = 
        Sleep(DeactivateTime)
        MapIndicator.DeactivateObjectivePulse(Agent)

    HandleCompleteEventSuspends(Agent : agent, QuestIndex : int)<suspends> : void =
        var NextQuestIsNewQuest : logic = false 
        


        if(QuestWrapper := QuestWrappers[QuestIndex+1]):
            Sleep(1.5)
            QuestWrapper.Tracker.Assign(Agent)
            Sleep(0.5)
            QuestWrapper.InitializeTracker(Agent)
            if(MapIndicator := QuestWrapper.MaybeMapIndicator?):
                for(X := 0..20):
                    MapIndicator.ActivateObjectivePulse(Agent)
                
                if(IndicatorDeactivateTime := QuestWrapper.MaybeDeactivateIndicatorAfter?):
                    spawn . DeactivateIndicatorAfter(MapIndicator, Agent, IndicatorDeactivateTime)


quest_wrapper := class():
    var RefQuestManager : quest_manager_device = quest_manager_device{}

    @editable Tracker : tracker_device = tracker_device{}
    @editable MaybeMapIndicator : ?map_indicator_device = false
    @editable EventValue : string = ""
    @editable QuestType : quest_type = quest_type.None
    @editable DeactivateIndicatorOnDistance : logic = false
    @editable MaybeDeactivateIndicatorAfter : ?float = false

    var IncreaseEvent : event(increase_event_data) = event(increase_event_data){}
    var ActivatedPlayers : []agent = array{}
    var Index : int = 0
    var MaybeCompletedEventHandler : ?type {HandleCompleteEventSuspends(Agent : agent, QuestIndex : int)<suspends> : void} = false

    var CurValue<private> : int = 0

    Initialize(InQuestManager : quest_manager_device) : void =
        set RefQuestManager = InQuestManager
        spawn . CheckIncreaseEvent()
        if(DeactivateIndicatorOnDistance = true):
            spawn . CheckIndicatorDistance()
    
    CheckIndicatorDistance()<suspends> : void =
        loop:
            for(Player : RefQuestManager.GetPlayspace().GetPlayers()):
                if(MapIndicator := MaybeMapIndicator?, FC := Player.GetFortCharacter[]):
                    if(Distance(MapIndicator.GetTransform().Translation, FC.GetTransform().Translation) < 50.0):
                        MapIndicator.DeactivateObjectivePulse(Player)
                Sleep(0.5)

    CheckIncreaseEvent()<suspends> : void =
        loop:
            IncreaseEventData := IncreaseEvent.Await()
            #Add following to the if statement for quests to be completly sync so if player crafted pickaxe before the quest to craft pickaxe it will NOT count and the player will need to craft again: Tracker.IsActive[IncreaseEventData.Agent] and 
            if (EventValue = IncreaseEventData.Value and IncreaseEventData.Type = QuestType):
                set CurValue += IncreaseEventData.Amount
                Tracker.SetValue(IncreaseEventData.Agent, CurValue)
    
    HandleCompletedEventWrapper(Agent : agent) : void =
          
        if (CompletedEventHandler := MaybeCompletedEventHandler?):
            spawn . CompletedEventHandler(Agent, Index)
    
    InitializeTracker(Agent : agent) : void =
        Print("Cur value: {CurValue}")
        Tracker.SetValue(Agent, CurValue)

quest_manager_device := class(creative_device):

    @editable GameManager : game_manager_device = game_manager_device{}
    @editable BlockManager : block_manager_device = block_manager_device{}
    @editable CraftingManager : crafting_manager_device = crafting_manager_device{}
    @editable CustomPlayerManager : custom_player_manager = custom_player_manager{}
    @editable FurnaceManager : furnace_manager_device = furnace_manager_device{}
    @editable VillagerManager : villager_manager_device = villager_manager_device{}
    @editable AudioManager : audio_manager_device = audio_manager_device{}

    @editable var QuestWrappers : []quest_wrapper = array{}

    @editable Island1QuestWrappers : []quest_wrapper = array{}
    @editable PostIsland1MiscQuestWrappers : []quest_wrapper = array{}

    @editable Island2EnterZone : mutator_zone_device = mutator_zone_device{}
    @editable VillagerIslandEnterZone : mutator_zone_device = mutator_zone_device{}
    @editable ZombieSpawners : []creature_spawner_device = array{}
    @editable StartQuestIndex : int = 0

    var Events : []event(increase_event_data) = array{}
   
    CustomEvent : event(increase_event_data) = event(increase_event_data){}


    SignalCustomEvent(Agent : agent, Amount : int, Value : string) : void =
        CustomEvent.Signal(increase_event_data{Agent:=Agent, Type:=quest_type.Custom, Value:=Value, Amount:=Amount})

    BroadcastIncreaseEvent(Data : increase_event_data) : void =
        for (QuestWrapper : QuestWrappers):
            QuestWrapper.IncreaseEvent.Signal(Data)

    ListenToEvent(SourceEvent : event(increase_event_data))<suspends> : void =
        loop:
            EventData := SourceEvent.Await()
            # Print("Multiplexer received event signal from one source: {EventData.Value}")
            BroadcastIncreaseEvent(EventData)

    EventSignalMultiplexer()<suspends> : void =
        for (SourceEvent : Events):
            spawn . ListenToEvent(SourceEvent)


    EnterIsland2Event(Agent : agent) : void =
        SignalCustomEvent(Agent, 1, "Enter Island2")

    EnterVillagerIsland(Agent : agent) : void =
        SignalCustomEvent(Agent, 1, "Enter Villager Island")    
    
    KillZombieEvent(ElimResult : device_ai_interaction_result) : void =
        if(SourceAgent := ElimResult.Source?):
            SignalCustomEvent(SourceAgent, 1, "Kill Zombie")
            if(TargetAgent := ElimResult.Target?, FC:=TargetAgent.GetFortCharacter[]):
                spawn . AudioManager.PlayKilledSound(FC.GetTransform().Translation)
    


    OnBegin<override>()<suspends>:void=

        set Events = array{BlockManager.DestroyedBlockEvent, CraftingManager.CraftedItemEvent, CustomPlayerManager.PlacedBlockEvent, CustomPlayerManager.PickUpItemEvent, FurnaceManager.CookedItemEvent, CustomEvent, VillagerManager.BoughtItemEvent}
        set QuestWrappers = array{}
        set QuestWrappers += Island1QuestWrappers
        set QuestWrappers += PostIsland1MiscQuestWrappers

        var QuestIndex : int = 0

        spawn . EventSignalMultiplexer()

        CompleteEventHandler := completed_event_wrapper{QuestWrappers:=QuestWrappers}

        Island2EnterZone.AgentEntersEvent.Subscribe(EnterIsland2Event)
        VillagerIslandEnterZone.AgentEntersEvent.Subscribe(EnterVillagerIsland)
        
        for(ZombieSpawner : ZombieSpawners):
            ZombieSpawner.EliminatedEvent.Subscribe(KillZombieEvent)

        for (QuestWrapper : QuestWrappers):
            QuestWrapper.Initialize(Self)
            set QuestWrapper.Index = QuestIndex
            set QuestWrapper.MaybeCompletedEventHandler = option{CompleteEventHandler.HandleCompleteEventSuspends} 
            QuestWrapper.Tracker.CompleteEvent.Subscribe(QuestWrapper.HandleCompletedEventWrapper)
            set QuestIndex += 1

        
        if(StartQuestIndex <> 1, QuestWrapper := QuestWrappers[StartQuestIndex]):
            for(Player : GetPlayspace().GetPlayers()):
                QuestWrapper.Tracker.Assign(Player)
--- </quest_manager_device.verse> ---

--- <raycast_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Fortnite.com/Characters }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Verse.org/Colors }

vector3i := class():
    @editable X : int = 0
    @editable Y : int = 0
    @editable Z : int = 0
    
    operator'+'<public>(Left:vector3i, Right:vector3i) : vector3i = vector3i{X:=Left.X+Right.X, Y:=Left.Y+Right.Y, Z:=Left.Z+Right.Z}
    operator'-'<public>(Left:vector3i, Right:vector3i) : vector3i = vector3i{X:=Left.X-Right.X, Y:=Left.Y-Right.Y, Z:=Left.Z-Right.Z}


(V:vector3i).ToVector3()<transacts> : vector3 = vector3{X:=V.X*1.0, Y:=V.Y*1.0, Z:=V.Z*1.0}
(V1:vector3i).Add(V2 : vector3i)<transacts> : vector3i = vector3i{X:=V1.X+V2.X, Y:=V1.Y+V2.Y, Z:=V1.Z+V2.Z}
(V1:vector3i).Sub(V2 : vector3i)<transacts> : vector3i = vector3i{X:=V1.X-V2.X, Y:=V1.Y-V2.Y, Z:=V1.Z-V2.Z}
(V1:vector3i).Add(V2 : vector3)<transacts> : vector3i = 
    if:
        IntX := Floor[V2.X]
        IntY := Floor[V2.Y]
        IntZ := Floor[V2.Z]
    then:
        Print("Adding: [{IntX}, {IntY}, {IntZ}] to [{V1.X}, {V1.Y}, {V1.Z}]")
        Vector3i := vector3i{X:=V1.X+IntX, Y:=V1.Y+IntY, Z:=V1.Z+IntZ}
        Print("Result: [{Vector3i.X}, {Vector3i.Y}, {Vector3i.Z}]")
        return vector3i{X:=V1.X+IntX, Y:=V1.Y+IntY, Z:=V1.Z+IntZ}
    PrintError("Could not add vector3 to vector3i")
    return V1

(V1:vector3i).Below()<transacts> : vector3i =
     return vector3i{X:=V1.X, Y:=V1.Y, Z:=V1.Z-1}

(V1:vector3i).Above()<transacts> : vector3i =
    return vector3i{X:=V1.X, Y:=V1.Y, Z:=V1.Z+1}


ToVector3i(V : vector3)<transacts> : vector3i =
    if:
        IntX := Round[V.X]
        IntY := Round[V.Y]
        IntZ := Round[V.Z]
    then:
        return vector3i{X:=IntX, Y:=IntY, Z:=IntZ}
    return vector3i{}

raycast_hit_result := class():
    HitPosition : vector3 = vector3{}
    HitNormal : vector3 = vector3{}
    HitRotation : rotation = rotation{}
    HasHit : logic = false

    Print() : void = 
        PrintLine(?MiddleString := "HitResult")
        Print("HitPosition: {HitPosition}")
        if (IntX := Round[HitPosition.X/GRID_SIZE], IntY := Round[HitPosition.Y/GRID_SIZE], IntZ := Round[HitPosition.Z/GRID_SIZE]):
            Print("GridPosition: {\\{IntX}, {IntY}, {IntZ}\\}")
        Print("HitNormal: {HitNormal}")
        if (HasHit?). Print("HasHit: True", ?Color := NamedColors.Green)
        else. Print("HasHit: False", ?Color := NamedColors.Red)
        PrintLine()

direction := enum {
    None
    Up
    Forward
    Right
    Down
    Backward
    Left
}

raycast_props := class<concrete>():
    @editable RaycastProp : creative_prop = creative_prop{}
    @editable RaycastHit : creative_prop = creative_prop{}

raycast_type := enum:
    FirstPerson
    ThirdPerson
    Extended
    FirstPersonAlternative
    ThirdPersonAlternative

raycast_manager_device := class(creative_device):
    # @editable RaycastProp : creative_prop = creative_prop{}
    # @editable RaycastHit : creative_prop = creative_prop{}

    @editable DefaultRaycastProps : []raycast_props = array{}
    @editable ThirdPersonRaycastProps : []raycast_props = array{}
    @editable ExtendedRaycastProps : []raycast_props = array{}

    @editable AlternativeDefaultRaycastProps : []raycast_props = array{}
    @editable AlternativeThirdPersonRaycastProps : []raycast_props = array{}

    var FirstPersonRaycastCounter : int = 0
    var TotalFirstPersonRaycasts : int = 0

    var ThirdPersonRaycastCounter : int = 0
    var TotalThirdPersonRaycasts : int = 0

    var ExtendedRaycastCounter : int = 0
    var TotalExtendedRaycasts : int = 0

    
    var AlternativeFirstPersonRaycastCounter : int = 0
    var AlternativeTotalFirstPersonRaycasts : int = 0

    var AlternativeThirdPersonRaycastCounter : int = 0
    var AlternativeTotalThirdPersonRaycasts : int = 0

    OnBegin<override>()<suspends> : void =
        if:
            DefaultRaycastProps.Length < 1
        then:
            Assert("RaycastManager is not setup properly")
        else:
            set TotalFirstPersonRaycasts = DefaultRaycastProps.Length       
            
        if:
            ThirdPersonRaycastProps.Length < 1
        then:
            Assert("RaycastManager is not setup properly")
        else:
            set TotalThirdPersonRaycasts = ThirdPersonRaycastProps.Length       

        if:
            ExtendedRaycastProps.Length < 1
        then:
            Assert("RaycastManager is not setup properly")
        else:
            set TotalExtendedRaycasts = ExtendedRaycastProps.Length

        if:
            AlternativeDefaultRaycastProps.Length < 1
        then:
            Assert("RaycastManager is not setup properly")
        else:
            set AlternativeTotalFirstPersonRaycasts = AlternativeDefaultRaycastProps.Length       
            
        if:
            AlternativeThirdPersonRaycastProps.Length < 1
        then:
            Assert("RaycastManager is not setup properly")
        else:
            set AlternativeTotalThirdPersonRaycasts = AlternativeThirdPersonRaycastProps.Length  


        
    

    InitiatePlayer(Agent : agent) : void = 
        PrintStart("Initiating Raycast for Player")
        # spawn. RaycastFollow(Agent)

    #############################
    #           ASYNC           #
    #############################
    # Raycast(FortCharacter : fort_character) : raycast_hit_result =
    #     if (RaycastProp.TeleportTo[FortCharacter.GetViewLocation(), FortCharacter.GetViewRotation()]) {}
    #     return GetRaycastHit()

    GetRaycastProps(RaycastType : raycast_type) : raycast_props =
        if (RaycastType = raycast_type.FirstPersonAlternative):
            if:
                RaycastProp := AlternativeDefaultRaycastProps[AlternativeFirstPersonRaycastCounter]
            then:
                set AlternativeFirstPersonRaycastCounter = Modular(AlternativeFirstPersonRaycastCounter + 1, AlternativeTotalFirstPersonRaycasts)
                return RaycastProp
            else:
                Assert("Could not return Alternative First Person Raycast Prop ({AlternativeFirstPersonRaycastCounter}/{AlternativeTotalFirstPersonRaycasts})")    
           
        
        if (RaycastType = raycast_type.ThirdPersonAlternative):
            if:
                RaycastProp := ThirdPersonRaycastProps[AlternativeThirdPersonRaycastCounter]
            then:
                # Print("Got ThirdPersonRaycast[{ThirdPersonRaycastCounter}]")
                set AlternativeThirdPersonRaycastCounter = Modular(AlternativeThirdPersonRaycastCounter + 1, AlternativeTotalThirdPersonRaycasts)
                return RaycastProp
            else:
                Assert("Could not return Third Person Raycast Prop ({AlternativeThirdPersonRaycastCounter}/{AlternativeTotalThirdPersonRaycasts})")    
                
        
        if (RaycastType = raycast_type.FirstPerson):
            if:
                RaycastProp := DefaultRaycastProps[FirstPersonRaycastCounter]
            then:
                # Print("Got DefaultRaycast[{FirstPersonRaycastCounter}]")
                set FirstPersonRaycastCounter = Modular(FirstPersonRaycastCounter + 1, TotalFirstPersonRaycasts)
                return RaycastProp
            else:
                Assert("Could not return First Person Raycast Prop ({FirstPersonRaycastCounter}/{TotalFirstPersonRaycasts})")    
           
        
        if (RaycastType = raycast_type.ThirdPerson):
            if:
                RaycastProp := ThirdPersonRaycastProps[ThirdPersonRaycastCounter]
            then:
                # Print("Got ThirdPersonRaycast[{ThirdPersonRaycastCounter}]")
                set ThirdPersonRaycastCounter = Modular(ThirdPersonRaycastCounter + 1, TotalThirdPersonRaycasts)
                return RaycastProp
            else:
                Assert("Could not return Third Person Raycast Prop ({ThirdPersonRaycastCounter}/{TotalThirdPersonRaycasts})")    
                

        if (RaycastType = raycast_type.Extended):
            if:
                RaycastProp := ExtendedRaycastProps[ExtendedRaycastCounter]
            then:
                # Print("Got ExtendedRaycast[{ExtendedRaycastCounter}]")
                set ExtendedRaycastCounter = Modular(ExtendedRaycastCounter + 1, TotalExtendedRaycasts)
                return RaycastProp
            else:
                Assert("Could not return Extended Raycast Prop ({ExtendedRaycastCounter}/{TotalExtendedRaycasts})")




        return raycast_props{}


    GetRaycastHitResult(RaycastHit : creative_prop) : raycast_hit_result = 
        RaycastTransform := RaycastHit.GetTransform()
        var HitPosition : vector3 = RaycastTransform.Translation
        var HitNormal : vector3 = RaycastTransform.Rotation.GetLocalForward()
        var HitRotation : rotation = RaycastTransform.Rotation
        var HasHit : logic = false
        if (RaycastTransform.Scale.Length() > 0.5):
            set HasHit = true
        
        return raycast_hit_result{HitPosition := HitPosition, HitNormal := HitNormal, HitRotation := HitRotation, HasHit := HasHit}


    # GetRaycastHit() : raycast_hit_result = 
    #     RaycastTransform := RaycastHit.GetTransform()
    #     var HitPosition : vector3 = RaycastTransform.Translation
    #     var HitNormal : vector3 = RaycastTransform.Rotation.GetLocalForward()
    #     var HitRotation : rotation = RaycastTransform.Rotation
    #     var HasHit : logic = false
    #     if (RaycastTransform.Scale.Length() > 0.5):
    #         set HasHit = true
    #     return raycast_hit_result{HitPosition := HitPosition, HitNormal := HitNormal, HitRotation := HitRotation, HasHit := HasHit}

    # if:
    #     R := Rotation.GetYawPitchRollDegrees()
    #     Yaw := R[0]
    #     Pitch := R[1]
    #     Roll := R[2]
    # then:
    #     Print("Yaw: {Yaw}")
    #     Print("Pitch: {Pitch}")
    #     Print("Roll: {Roll}")




    TeleportRaycast(RaycastProp : creative_prop, Position : vector3, Rotation : rotation) : void =
        if (RaycastProp.TeleportTo[Position, Rotation]) {} else { PrintError("Could not teleport Raycast to Position: {Position}")}

    Raycast(Position : vector3, Rotation : rotation, RaycastType : raycast_type)<suspends> : raycast_hit_result =
        CurrentRaycastProps := GetRaycastProps(RaycastType)
        TeleportRaycast(CurrentRaycastProps.RaycastProp, Position, Rotation)
        Sleep(0.0)
        return GetRaycastHitResult(CurrentRaycastProps.RaycastHit)
    
    Raycast(Agent : agent, RaycastType : raycast_type)<suspends> : raycast_hit_result =
        CurrentRaycastProps := GetRaycastProps(RaycastType)
        if (FortCharacter := Agent.GetFortCharacter[]):
            TeleportRaycast(CurrentRaycastProps.RaycastProp, FortCharacter.GetViewLocation(), FortCharacter.GetViewRotation())
            Sleep(0.0)
            return GetRaycastHitResult(CurrentRaycastProps.RaycastHit)
        PrintError("Could not get FortCharacter from Agent for RaycastSuspended")
        return GetRaycastHitResult(CurrentRaycastProps.RaycastHit)

    Raycast(Agent : agent, IsFirstPerson : logic)<suspends> : raycast_hit_result =
        var RaycastType : raycast_type = raycast_type.ThirdPerson
        if (IsFirstPerson?). set RaycastType = raycast_type.FirstPerson
        CurrentRaycastProps := GetRaycastProps(RaycastType)
        if (FortCharacter := Agent.GetFortCharacter[]):
            TeleportRaycast(CurrentRaycastProps.RaycastProp, FortCharacter.GetViewLocation(), FortCharacter.GetViewRotation())
            Sleep(0.0)
            return GetRaycastHitResult(CurrentRaycastProps.RaycastHit)
        PrintError("Could not get FortCharacter from Agent for RaycastSuspended")
        return GetRaycastHitResult(CurrentRaycastProps.RaycastHit)

    RaycastAlternative(Agent : agent, IsFirstPerson : logic)<suspends> : raycast_hit_result =
        var RaycastType : raycast_type = raycast_type.ThirdPersonAlternative
        if (IsFirstPerson?). set RaycastType = raycast_type.FirstPersonAlternative
        CurrentRaycastProps := GetRaycastProps(RaycastType)
        if (FortCharacter := Agent.GetFortCharacter[]):
            TeleportRaycast(CurrentRaycastProps.RaycastProp, FortCharacter.GetViewLocation(), FortCharacter.GetViewRotation())
            Sleep(0.0)
            return GetRaycastHitResult(CurrentRaycastProps.RaycastHit)
        PrintError("Could not get FortCharacter from Agent for RaycastSuspended")
        return GetRaycastHitResult(CurrentRaycastProps.RaycastHit)
    


    Raycast(Position : vector3, Direction : direction, RaycastType : raycast_type)<suspends> : raycast_hit_result = 
        CurrentRaycastProps := GetRaycastProps(RaycastType)
        if (Direction = direction.Up). TeleportRaycast(CurrentRaycastProps.RaycastProp, Position, MakeRotationFromYawPitchRollDegrees(0.0, 90.0, 0.0))
        else if (Direction = direction.Down). TeleportRaycast(CurrentRaycastProps.RaycastProp, Position, MakeRotationFromYawPitchRollDegrees(0.0, -90.0, 0.0))
        Sleep(0.0)
        return GetRaycastHitResult(CurrentRaycastProps.RaycastHit)

































    ##############################
    #          TRACKING          #
    ##############################
    # RaycastFollow(Agent : agent)<suspends> : void = 
    #     if:
    #         FortCharacter := Agent.GetFortCharacter[]
    #     then:
    #         loop {
    #             if (FortCharacter.IsActive[]):
    #                 # Print("Nrml-Position: {FortCharacter.GetTransform().Translation}")
    #                 # Print("View-Position: {FortCharacter.GetViewLocation()}")
    #                 Transform := FortCharacter.GetTransform()
                    
    #                 #############################
    #                 #           MOVE TO         #
    #                 #############################
    #                 # RaycastProp.MoveTo(FortCharacter.GetTransform().Translation+vector3{X:=0.0, Y:=-2.0, Z:=78.0}, FortCharacter.GetViewRotation(), 0.001)
                    
    #                 #############################################
    #                 #           MOVE TO VIEW LOCATION           #
    #                 #############################################
    #                 # RaycastProp.MoveTo(FortCharacter.GetViewLocation(), FortCharacter.GetViewRotation(), 0.001) # use view location

    #                 #################################
    #                 #           TELEPORT TO         #
    #                 #################################
    #                 # if (RaycastProp.TeleportTo[FortCharacter.GetTransform().Translation+vector3{X:=0.0, Y:=-2.0, Z:=78.0}, FortCharacter.GetViewRotation()]) {}
    #                 # Sleep(0.0)

    #                 ###############################################
    #                 #           TELEPORT TO VIEW LOCATION         #
    #                 ###############################################
    #                 if (RaycastProp.TeleportTo[FortCharacter.GetViewLocation(), FortCharacter.GetViewRotation()]) {}
    #                 Sleep(0.0)

    #                 # RaycastProp.MoveTo(FortCharacter.GetViewLocation(), FortCharacter.GetViewRotation(), 0.01)
    #         }



            
    # var HitPosition : vector3 = vector3{}
    # var HasHit : logic = false
    # if (RaycastProp.TeleportTo[FortCharacter.GetTransform().Translation+vector3{X:=0.0, Y:=-2.0, Z:=78.0}, FortCharacter.GetViewRotation()]) {}
    # set HitPosition = RaycastHit.GetTransform().Translation
    # if (RaycastHit.GetTransform().Scale.X = 1.0). set HasHit = true
    # return raycast_hit_result{HitPosition := HitPosition, HasHit := HasHit}--- </raycast_manager_device.verse> ---

--- <reference_manager_device.verse> ---

using { /Fortnite.com/AI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Simulation/Tags }
using { /UnrealEngine.com/Temporary/Diagnostics }

reference_manager_tag := class(tag){}
var WorkaroundForTaggedObjects : weak_map(session, creative_device) = map{}

FindObjectsWithTag(search_tag:tag)<transacts>:[]creative_object_interface=
    var ObjectsArray : []creative_object_interface = array{}

    if:
        Session := GetSession()
        CreativeDevice := WorkaroundForTaggedObjects[Session]
    then:
        TaggedObjects := CreativeDevice.FindCreativeObjectsWithTag(search_tag)

        for(Object:TaggedObjects):
            set ObjectsArray += array{Object}

    return ObjectsArray


reference_manager_device := class(creative_device):

    # put here all editables for other devices:
    # @editable EntityManager 

    TestInt<public> : int = 5

    OnBegin<override>()<suspends> : void =
        Sleep(3.0)
        Session := GetSession()
        if:
            set WorkaroundForTaggedObjects[Session] = Self

GetReferenceManager(InCreativeDevice : creative_device)<decides><transacts> : reference_manager_device = 
    var MaybeReferenceManager : ?reference_manager_device = false
    TaggedActors := InCreativeDevice.FindCreativeObjectsWithTag(reference_manager_tag{})
    
    var Count : int = 0
    var MaybeCreativeObject : ?creative_object_interface = false

    for (TaggedActor : TaggedActors):
        set MaybeCreativeObject = option. TaggedActor
        set Count += 1
    if (Count <> 1):
        Assert("Multiple Actors with \"reference_manager_tag\" in Project")

    if:
        CreativeObject := MaybeCreativeObject?
        ReferenceManager := reference_manager_device[CreativeObject]
    then:
        set MaybeReferenceManager = option. ReferenceManager
    return MaybeReferenceManager?

GetReferenceManager(InNPCBehavior : npc_behavior)<decides><transacts> : reference_manager_device = 
    var MaybeReferenceManager : ?reference_manager_device = false
    TaggedActors := InNPCBehavior.FindCreativeObjectsWithTag(reference_manager_tag{})
    
    var Count : int = 0
    var MaybeCreativeObject : ?creative_object_interface = false

    for (TaggedActor : TaggedActors):
        set MaybeCreativeObject = option. TaggedActor
        set Count += 1
    if (Count <> 1):
        Assert("Multiple Actors with \"reference_manager_tag\" in Project")

    if:
        CreativeObject := MaybeCreativeObject?
        ReferenceManager := reference_manager_device[CreativeObject]
    then:
        set MaybeReferenceManager = option. ReferenceManager
    return MaybeReferenceManager?--- </reference_manager_device.verse> ---

--- <structure_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }

structure_block_wrapper := class<concrete>():
    @editable BlockTypes<public> : block_type = block_type.None
    @editable BlockPositions<public> : []vector3i = array{}

structure_wrapper := class<concrete>():
    @editable StructureName : string = ""
    @editable StructureBlocks : []structure_block_wrapper = array{}

    Build(BlockManager : block_manager_device, GridPosition : vector3i) : void =
        Print("StructureBlocks.Length: {StructureBlocks.Length}")
        for:
            StructureBlock : StructureBlocks
        do:
            Print("StructureBlock.BlockPositions.Length: {StructureBlock.BlockPositions.Length}")
            for:
                RelativePosition : StructureBlock.BlockPositions
            do:
                PlacePosition := GridPosition.Add(RelativePosition)
                if:
                    OverlappingBlock := BlockManager.GetBlockFromMap[PlacePosition]
                then:
                    block{}
                    Print("Cannot build block")
                    # PrintError("Block is overlapping with Structure. Destroying Block")
                    # OverlappingBlock.Destroy(?Drop := false)
                else:
                    BlockManager.SpawnBlock(StructureBlock.BlockTypes, PlacePosition, rotation{})


structure_manager_device := class(creative_device):


    SpruceTree : structure_wrapper = structure_wrapper:
        StructureName := "Spruce Tree",
        StructureBlocks := array:
            structure_block_wrapper{
                BlockTypes := block_type.SpruceLeaves,
                BlockPositions := array{
                    vector3i{X:=0, Z:=2, Y:=0},
                    vector3i{X:=1, Z:=2, Y:=0}, vector3i{X:=-1, Z:=2, Y:=0}, vector3i{X:=0, Z:=2, Y:=1}, vector3i{X:=0, Z:=2, Y:=-1},
                    vector3i{X:=2, Z:=2, Y:=0}, vector3i{X:=-2, Z:=2, Y:=0}, vector3i{X:=0, Z:=2, Y:=2}, vector3i{X:=0, Z:=2, Y:=-2},
    
                    vector3i{X:=0, Z:=3, Y:=0},
                    vector3i{X:=1, Z:=3, Y:=0}, vector3i{X:=-1, Z:=3, Y:=0}, vector3i{X:=0, Z:=3, Y:=1}, vector3i{X:=0, Z:=3, Y:=-1},
                    vector3i{X:=1, Z:=3, Y:=1}, vector3i{X:=1, Z:=3, Y:=-1}, vector3i{X:=-1, Z:=3, Y:=1}, vector3i{X:=-1, Z:=3, Y:=-1},
                    vector3i{X:=2, Z:=3, Y:=0}, vector3i{X:=-2, Z:=3, Y:=0}, vector3i{X:=0, Z:=3, Y:=2}, vector3i{X:=0, Z:=3, Y:=-2},

                    vector3i{X:=0, Z:=4, Y:=0},
                    vector3i{X:=1, Z:=4, Y:=0}, vector3i{X:=-1, Z:=4, Y:=0}, vector3i{X:=0, Z:=4, Y:=1}, vector3i{X:=0, Z:=4, Y:=-1},
                    vector3i{X:=1, Z:=4, Y:=1}, vector3i{X:=1, Z:=4, Y:=-1}, vector3i{X:=-1, Z:=4, Y:=1}, vector3i{X:=-1, Z:=4, Y:=-1},
                    vector3i{X:=2, Z:=4, Y:=0}, vector3i{X:=-2, Z:=4, Y:=0}, vector3i{X:=0, Z:=4, Y:=2}, vector3i{X:=0, Z:=4, Y:=-2},
    
                    vector3i{X:=0, Z:=5, Y:=0},
                    vector3i{X:=1, Z:=5, Y:=0}, vector3i{X:=-1, Z:=5, Y:=0}, vector3i{X:=0, Z:=5, Y:=1}, vector3i{X:=0, Z:=5, Y:=-1},
                    vector3i{X:=1, Z:=5, Y:=1}, vector3i{X:=1, Z:=5, Y:=-1}, vector3i{X:=-1, Z:=5, Y:=1}, vector3i{X:=-1, Z:=5, Y:=-1},
    
                    vector3i{X:=0, Z:=6, Y:=0},
                    vector3i{X:=1, Z:=6, Y:=0}, vector3i{X:=-1, Z:=6, Y:=0}, vector3i{X:=0, Z:=6, Y:=1}, vector3i{X:=0, Z:=6, Y:=-1},
    
                    vector3i{X:=0, Z:=7, Y:=0},
                    vector3i{X:=1, Z:=7, Y:=0}, vector3i{X:=-1, Z:=7, Y:=0}, vector3i{X:=0, Z:=7, Y:=1}, vector3i{X:=0, Z:=7, Y:=-1},
    
                    vector3i{X:=0, Z:=8, Y:=0}
                }
            },
            structure_block_wrapper{
                BlockTypes := block_type.SpruceLog,
                BlockPositions := array{
                    vector3i{X:=0, Z:=0, Y:=0},
                    vector3i{X:=0, Z:=1, Y:=0},
                    vector3i{X:=0, Z:=2, Y:=0},
                    vector3i{X:=0, Z:=3, Y:=0},
                    vector3i{X:=0, Z:=4, Y:=0},
                    vector3i{X:=0, Z:=5, Y:=0},
                    vector3i{X:=0, Z:=6, Y:=0}
                }
            }





    BigSpruceTree : structure_wrapper = structure_wrapper:
        StructureName := "Giant 2x2 Trunk Spruce Tree",
        StructureBlocks := array:
            structure_block_wrapper{
                BlockTypes := block_type.SpruceLeaves,
                BlockPositions := array{
                    vector3i{X:=-5, Z:=5, Y:=-5}, vector3i{X:=-5, Z:=5, Y:=-4}, vector3i{X:=-5, Z:=5, Y:=-3}, vector3i{X:=-5, Z:=5, Y:=-2}, vector3i{X:=-5, Z:=5, Y:=-1}, vector3i{X:=-5, Z:=5, Y:=0}, vector3i{X:=-5, Z:=5, Y:=1}, vector3i{X:=-5, Z:=5, Y:=2}, vector3i{X:=-5, Z:=5, Y:=3}, vector3i{X:=-5, Z:=5, Y:=4}, vector3i{X:=-5, Z:=5, Y:=5}, vector3i{X:=-5, Z:=5, Y:=6},
                    vector3i{X:=-4, Z:=5, Y:=-5}, vector3i{X:=-4, Z:=5, Y:=-4}, vector3i{X:=-4, Z:=5, Y:=-3}, vector3i{X:=-4, Z:=5, Y:=-2}, vector3i{X:=-4, Z:=5, Y:=-1}, vector3i{X:=-4, Z:=5, Y:=0}, vector3i{X:=-4, Z:=5, Y:=1}, vector3i{X:=-4, Z:=5, Y:=2}, vector3i{X:=-4, Z:=5, Y:=3}, vector3i{X:=-4, Z:=5, Y:=4}, vector3i{X:=-4, Z:=5, Y:=5}, vector3i{X:=-4, Z:=5, Y:=6},
                    vector3i{X:=-3, Z:=5, Y:=-5}, vector3i{X:=-3, Z:=5, Y:=-4}, vector3i{X:=-3, Z:=5, Y:=-3}, vector3i{X:=-3, Z:=5, Y:=-2}, vector3i{X:=-3, Z:=5, Y:=-1}, vector3i{X:=-3, Z:=5, Y:=0}, vector3i{X:=-3, Z:=5, Y:=1}, vector3i{X:=-3, Z:=5, Y:=2}, vector3i{X:=-3, Z:=5, Y:=3}, vector3i{X:=-3, Z:=5, Y:=4}, vector3i{X:=-3, Z:=5, Y:=5}, vector3i{X:=-3, Z:=5, Y:=6},
                    vector3i{X:=-2, Z:=5, Y:=-5}, vector3i{X:=-2, Z:=5, Y:=-4}, vector3i{X:=-2, Z:=5, Y:=-3}, vector3i{X:=-2, Z:=5, Y:=-2}, vector3i{X:=-2, Z:=5, Y:=-1}, vector3i{X:=-2, Z:=5, Y:=0}, vector3i{X:=-2, Z:=5, Y:=1}, vector3i{X:=-2, Z:=5, Y:=2}, vector3i{X:=-2, Z:=5, Y:=3}, vector3i{X:=-2, Z:=5, Y:=4}, vector3i{X:=-2, Z:=5, Y:=5}, vector3i{X:=-2, Z:=5, Y:=6},
                    vector3i{X:=-1, Z:=5, Y:=-5}, vector3i{X:=-1, Z:=5, Y:=-4}, vector3i{X:=-1, Z:=5, Y:=-3}, vector3i{X:=-1, Z:=5, Y:=-2}, vector3i{X:=-1, Z:=5, Y:=-1}, vector3i{X:=-1, Z:=5, Y:=0}, vector3i{X:=-1, Z:=5, Y:=1}, vector3i{X:=-1, Z:=5, Y:=2}, vector3i{X:=-1, Z:=5, Y:=3}, vector3i{X:=-1, Z:=5, Y:=4}, vector3i{X:=-1, Z:=5, Y:=5}, vector3i{X:=-1, Z:=5, Y:=6},
                    vector3i{X:=0, Z:=5, Y:=-5}, vector3i{X:=0, Z:=5, Y:=-4}, vector3i{X:=0, Z:=5, Y:=-3}, vector3i{X:=0, Z:=5, Y:=-2}, vector3i{X:=0, Z:=5, Y:=-1}, vector3i{X:=0, Z:=5, Y:=0}, vector3i{X:=0, Z:=5, Y:=1}, vector3i{X:=0, Z:=5, Y:=2}, vector3i{X:=0, Z:=5, Y:=3}, vector3i{X:=0, Z:=5, Y:=4}, vector3i{X:=0, Z:=5, Y:=5}, vector3i{X:=0, Z:=5, Y:=6},
                    vector3i{X:=1, Z:=5, Y:=-5}, vector3i{X:=1, Z:=5, Y:=-4}, vector3i{X:=1, Z:=5, Y:=-3}, vector3i{X:=1, Z:=5, Y:=-2}, vector3i{X:=1, Z:=5, Y:=-1}, vector3i{X:=1, Z:=5, Y:=0}, vector3i{X:=1, Z:=5, Y:=1}, vector3i{X:=1, Z:=5, Y:=2}, vector3i{X:=1, Z:=5, Y:=3}, vector3i{X:=1, Z:=5, Y:=4}, vector3i{X:=1, Z:=5, Y:=5}, vector3i{X:=1, Z:=5, Y:=6},
                    vector3i{X:=2, Z:=5, Y:=-5}, vector3i{X:=2, Z:=5, Y:=-4}, vector3i{X:=2, Z:=5, Y:=-3}, vector3i{X:=2, Z:=5, Y:=-2}, vector3i{X:=2, Z:=5, Y:=-1}, vector3i{X:=2, Z:=5, Y:=0}, vector3i{X:=2, Z:=5, Y:=1}, vector3i{X:=2, Z:=5, Y:=2}, vector3i{X:=2, Z:=5, Y:=3}, vector3i{X:=2, Z:=5, Y:=4}, vector3i{X:=2, Z:=5, Y:=5}, vector3i{X:=2, Z:=5, Y:=6},
                    vector3i{X:=3, Z:=5, Y:=-5}, vector3i{X:=3, Z:=5, Y:=-4}, vector3i{X:=3, Z:=5, Y:=-3}, vector3i{X:=3, Z:=5, Y:=-2}, vector3i{X:=3, Z:=5, Y:=-1}, vector3i{X:=3, Z:=5, Y:=0}, vector3i{X:=3, Z:=5, Y:=1}, vector3i{X:=3, Z:=5, Y:=2}, vector3i{X:=3, Z:=5, Y:=3}, vector3i{X:=3, Z:=5, Y:=4}, vector3i{X:=3, Z:=5, Y:=5}, vector3i{X:=3, Z:=5, Y:=6},
                    vector3i{X:=4, Z:=5, Y:=-5}, vector3i{X:=4, Z:=5, Y:=-4}, vector3i{X:=4, Z:=5, Y:=-3}, vector3i{X:=4, Z:=5, Y:=-2}, vector3i{X:=4, Z:=5, Y:=-1}, vector3i{X:=4, Z:=5, Y:=0}, vector3i{X:=4, Z:=5, Y:=1}, vector3i{X:=4, Z:=5, Y:=2}, vector3i{X:=4, Z:=5, Y:=3}, vector3i{X:=4, Z:=5, Y:=4}, vector3i{X:=4, Z:=5, Y:=5}, vector3i{X:=4, Z:=5, Y:=6},
                    vector3i{X:=5, Z:=5, Y:=-5}, vector3i{X:=5, Z:=5, Y:=-4}, vector3i{X:=5, Z:=5, Y:=-3}, vector3i{X:=5, Z:=5, Y:=-2}, vector3i{X:=5, Z:=5, Y:=-1}, vector3i{X:=5, Z:=5, Y:=0}, vector3i{X:=5, Z:=5, Y:=1}, vector3i{X:=5, Z:=5, Y:=2}, vector3i{X:=5, Z:=5, Y:=3}, vector3i{X:=5, Z:=5, Y:=4}, vector3i{X:=5, Z:=5, Y:=5}, vector3i{X:=5, Z:=5, Y:=6},
                    vector3i{X:=6, Z:=5, Y:=-5}, vector3i{X:=6, Z:=5, Y:=-4}, vector3i{X:=6, Z:=5, Y:=-3}, vector3i{X:=6, Z:=5, Y:=-2}, vector3i{X:=6, Z:=5, Y:=-1}, vector3i{X:=6, Z:=5, Y:=0}, vector3i{X:=6, Z:=5, Y:=1}, vector3i{X:=6, Z:=5, Y:=2}, vector3i{X:=6, Z:=5, Y:=3}, vector3i{X:=6, Z:=5, Y:=4}, vector3i{X:=6, Z:=5, Y:=5}, vector3i{X:=6, Z:=5, Y:=6},
    
                    # // Layer at Z=6 (Height = 6) - 12x12 square = 144 blocks
                    # // X from -5 to 6, Y from -5 to 6
                    vector3i{X:=-5, Z:=6, Y:=-5}, vector3i{X:=-5, Z:=6, Y:=-4}, vector3i{X:=-5, Z:=6, Y:=-3}, vector3i{X:=-5, Z:=6, Y:=-2}, vector3i{X:=-5, Z:=6, Y:=-1}, vector3i{X:=-5, Z:=6, Y:=0}, vector3i{X:=-5, Z:=6, Y:=1}, vector3i{X:=-5, Z:=6, Y:=2}, vector3i{X:=-5, Z:=6, Y:=3}, vector3i{X:=-5, Z:=6, Y:=4}, vector3i{X:=-5, Z:=6, Y:=5}, vector3i{X:=-5, Z:=6, Y:=6},
                    vector3i{X:=-4, Z:=6, Y:=-5}, vector3i{X:=-4, Z:=6, Y:=-4}, vector3i{X:=-4, Z:=6, Y:=-3}, vector3i{X:=-4, Z:=6, Y:=-2}, vector3i{X:=-4, Z:=6, Y:=-1}, vector3i{X:=-4, Z:=6, Y:=0}, vector3i{X:=-4, Z:=6, Y:=1}, vector3i{X:=-4, Z:=6, Y:=2}, vector3i{X:=-4, Z:=6, Y:=3}, vector3i{X:=-4, Z:=6, Y:=4}, vector3i{X:=-4, Z:=6, Y:=5}, vector3i{X:=-4, Z:=6, Y:=6},
                    vector3i{X:=-3, Z:=6, Y:=-5}, vector3i{X:=-3, Z:=6, Y:=-4}, vector3i{X:=-3, Z:=6, Y:=-3}, vector3i{X:=-3, Z:=6, Y:=-2}, vector3i{X:=-3, Z:=6, Y:=-1}, vector3i{X:=-3, Z:=6, Y:=0}, vector3i{X:=-3, Z:=6, Y:=1}, vector3i{X:=-3, Z:=6, Y:=2}, vector3i{X:=-3, Z:=6, Y:=3}, vector3i{X:=-3, Z:=6, Y:=4}, vector3i{X:=-3, Z:=6, Y:=5}, vector3i{X:=-3, Z:=6, Y:=6},
                    vector3i{X:=-2, Z:=6, Y:=-5}, vector3i{X:=-2, Z:=6, Y:=-4}, vector3i{X:=-2, Z:=6, Y:=-3}, vector3i{X:=-2, Z:=6, Y:=-2}, vector3i{X:=-2, Z:=6, Y:=-1}, vector3i{X:=-2, Z:=6, Y:=0}, vector3i{X:=-2, Z:=6, Y:=1}, vector3i{X:=-2, Z:=6, Y:=2}, vector3i{X:=-2, Z:=6, Y:=3}, vector3i{X:=-2, Z:=6, Y:=4}, vector3i{X:=-2, Z:=6, Y:=5}, vector3i{X:=-2, Z:=6, Y:=6},
                    vector3i{X:=-1, Z:=6, Y:=-5}, vector3i{X:=-1, Z:=6, Y:=-4}, vector3i{X:=-1, Z:=6, Y:=-3}, vector3i{X:=-1, Z:=6, Y:=-2}, vector3i{X:=-1, Z:=6, Y:=-1}, vector3i{X:=-1, Z:=6, Y:=0}, vector3i{X:=-1, Z:=6, Y:=1}, vector3i{X:=-1, Z:=6, Y:=2}, vector3i{X:=-1, Z:=6, Y:=3}, vector3i{X:=-1, Z:=6, Y:=4}, vector3i{X:=-1, Z:=6, Y:=5}, vector3i{X:=-1, Z:=6, Y:=6},
                    vector3i{X:=0, Z:=6, Y:=-5}, vector3i{X:=0, Z:=6, Y:=-4}, vector3i{X:=0, Z:=6, Y:=-3}, vector3i{X:=0, Z:=6, Y:=-2}, vector3i{X:=0, Z:=6, Y:=-1}, vector3i{X:=0, Z:=6, Y:=0}, vector3i{X:=0, Z:=6, Y:=1}, vector3i{X:=0, Z:=6, Y:=2}, vector3i{X:=0, Z:=6, Y:=3}, vector3i{X:=0, Z:=6, Y:=4}, vector3i{X:=0, Z:=6, Y:=5}, vector3i{X:=0, Z:=6, Y:=6},
                    vector3i{X:=1, Z:=6, Y:=-5}, vector3i{X:=1, Z:=6, Y:=-4}, vector3i{X:=1, Z:=6, Y:=-3}, vector3i{X:=1, Z:=6, Y:=-2}, vector3i{X:=1, Z:=6, Y:=-1}, vector3i{X:=1, Z:=6, Y:=0}, vector3i{X:=1, Z:=6, Y:=1}, vector3i{X:=1, Z:=6, Y:=2}, vector3i{X:=1, Z:=6, Y:=3}, vector3i{X:=1, Z:=6, Y:=4}, vector3i{X:=1, Z:=6, Y:=5}, vector3i{X:=1, Z:=6, Y:=6},
                    vector3i{X:=2, Z:=6, Y:=-5}, vector3i{X:=2, Z:=6, Y:=-4}, vector3i{X:=2, Z:=6, Y:=-3}, vector3i{X:=2, Z:=6, Y:=-2}, vector3i{X:=2, Z:=6, Y:=-1}, vector3i{X:=2, Z:=6, Y:=0}, vector3i{X:=2, Z:=6, Y:=1}, vector3i{X:=2, Z:=6, Y:=2}, vector3i{X:=2, Z:=6, Y:=3}, vector3i{X:=2, Z:=6, Y:=4}, vector3i{X:=2, Z:=6, Y:=5}, vector3i{X:=2, Z:=6, Y:=6},
                    vector3i{X:=3, Z:=6, Y:=-5}, vector3i{X:=3, Z:=6, Y:=-4}, vector3i{X:=3, Z:=6, Y:=-3}, vector3i{X:=3, Z:=6, Y:=-2}, vector3i{X:=3, Z:=6, Y:=-1}, vector3i{X:=3, Z:=6, Y:=0}, vector3i{X:=3, Z:=6, Y:=1}, vector3i{X:=3, Z:=6, Y:=2}, vector3i{X:=3, Z:=6, Y:=3}, vector3i{X:=3, Z:=6, Y:=4}, vector3i{X:=3, Z:=6, Y:=5}, vector3i{X:=3, Z:=6, Y:=6},
                    vector3i{X:=4, Z:=6, Y:=-5}, vector3i{X:=4, Z:=6, Y:=-4}, vector3i{X:=4, Z:=6, Y:=-3}, vector3i{X:=4, Z:=6, Y:=-2}, vector3i{X:=4, Z:=6, Y:=-1}, vector3i{X:=4, Z:=6, Y:=0}, vector3i{X:=4, Z:=6, Y:=1}, vector3i{X:=4, Z:=6, Y:=2}, vector3i{X:=4, Z:=6, Y:=3}, vector3i{X:=4, Z:=6, Y:=4}, vector3i{X:=4, Z:=6, Y:=5}, vector3i{X:=4, Z:=6, Y:=6},
                    vector3i{X:=5, Z:=6, Y:=-5}, vector3i{X:=5, Z:=6, Y:=-4}, vector3i{X:=5, Z:=6, Y:=-3}, vector3i{X:=5, Z:=6, Y:=-2}, vector3i{X:=5, Z:=6, Y:=-1}, vector3i{X:=5, Z:=6, Y:=0}, vector3i{X:=5, Z:=6, Y:=1}, vector3i{X:=5, Z:=6, Y:=2}, vector3i{X:=5, Z:=6, Y:=3}, vector3i{X:=5, Z:=6, Y:=4}, vector3i{X:=5, Z:=6, Y:=5}, vector3i{X:=5, Z:=6, Y:=6},
                    vector3i{X:=6, Z:=6, Y:=-5}, vector3i{X:=6, Z:=6, Y:=-4}, vector3i{X:=6, Z:=6, Y:=-3}, vector3i{X:=6, Z:=6, Y:=-2}, vector3i{X:=6, Z:=6, Y:=-1}, vector3i{X:=6, Z:=6, Y:=0}, vector3i{X:=6, Z:=6, Y:=1}, vector3i{X:=6, Z:=6, Y:=2}, vector3i{X:=6, Z:=6, Y:=3}, vector3i{X:=6, Z:=6, Y:=4}, vector3i{X:=6, Z:=6, Y:=5}, vector3i{X:=6, Z:=6, Y:=6},
    
                    # // Layer at Z=7 (Height = 7) - 10x10 square = 100 blocks
                    # // X from -4 to 5, Y from -4 to 5
                    vector3i{X:=-4, Z:=7, Y:=-4}, vector3i{X:=-4, Z:=7, Y:=-3}, vector3i{X:=-4, Z:=7, Y:=-2}, vector3i{X:=-4, Z:=7, Y:=-1}, vector3i{X:=-4, Z:=7, Y:=0}, vector3i{X:=-4, Z:=7, Y:=1}, vector3i{X:=-4, Z:=7, Y:=2}, vector3i{X:=-4, Z:=7, Y:=3}, vector3i{X:=-4, Z:=7, Y:=4}, vector3i{X:=-4, Z:=7, Y:=5},
                    vector3i{X:=-3, Z:=7, Y:=-4}, vector3i{X:=-3, Z:=7, Y:=-3}, vector3i{X:=-3, Z:=7, Y:=-2}, vector3i{X:=-3, Z:=7, Y:=-1}, vector3i{X:=-3, Z:=7, Y:=0}, vector3i{X:=-3, Z:=7, Y:=1}, vector3i{X:=-3, Z:=7, Y:=2}, vector3i{X:=-3, Z:=7, Y:=3}, vector3i{X:=-3, Z:=7, Y:=4}, vector3i{X:=-3, Z:=7, Y:=5},
                    vector3i{X:=-2, Z:=7, Y:=-4}, vector3i{X:=-2, Z:=7, Y:=-3}, vector3i{X:=-2, Z:=7, Y:=-2}, vector3i{X:=-2, Z:=7, Y:=-1}, vector3i{X:=-2, Z:=7, Y:=0}, vector3i{X:=-2, Z:=7, Y:=1}, vector3i{X:=-2, Z:=7, Y:=2}, vector3i{X:=-2, Z:=7, Y:=3}, vector3i{X:=-2, Z:=7, Y:=4}, vector3i{X:=-2, Z:=7, Y:=5},
                    vector3i{X:=-1, Z:=7, Y:=-4}, vector3i{X:=-1, Z:=7, Y:=-3}, vector3i{X:=-1, Z:=7, Y:=-2}, vector3i{X:=-1, Z:=7, Y:=-1}, vector3i{X:=-1, Z:=7, Y:=0}, vector3i{X:=-1, Z:=7, Y:=1}, vector3i{X:=-1, Z:=7, Y:=2}, vector3i{X:=-1, Z:=7, Y:=3}, vector3i{X:=-1, Z:=7, Y:=4}, vector3i{X:=-1, Z:=7, Y:=5},
                    vector3i{X:=0, Z:=7, Y:=-4}, vector3i{X:=0, Z:=7, Y:=-3}, vector3i{X:=0, Z:=7, Y:=-2}, vector3i{X:=0, Z:=7, Y:=-1}, vector3i{X:=0, Z:=7, Y:=0}, vector3i{X:=0, Z:=7, Y:=1}, vector3i{X:=0, Z:=7, Y:=2}, vector3i{X:=0, Z:=7, Y:=3}, vector3i{X:=0, Z:=7, Y:=4}, vector3i{X:=0, Z:=7, Y:=5},
                    vector3i{X:=1, Z:=7, Y:=-4}, vector3i{X:=1, Z:=7, Y:=-3}, vector3i{X:=1, Z:=7, Y:=-2}, vector3i{X:=1, Z:=7, Y:=-1}, vector3i{X:=1, Z:=7, Y:=0}, vector3i{X:=1, Z:=7, Y:=1}, vector3i{X:=1, Z:=7, Y:=2}, vector3i{X:=1, Z:=7, Y:=3}, vector3i{X:=1, Z:=7, Y:=4}, vector3i{X:=1, Z:=7, Y:=5},
                    vector3i{X:=2, Z:=7, Y:=-4}, vector3i{X:=2, Z:=7, Y:=-3}, vector3i{X:=2, Z:=7, Y:=-2}, vector3i{X:=2, Z:=7, Y:=-1}, vector3i{X:=2, Z:=7, Y:=0}, vector3i{X:=2, Z:=7, Y:=1}, vector3i{X:=2, Z:=7, Y:=2}, vector3i{X:=2, Z:=7, Y:=3}, vector3i{X:=2, Z:=7, Y:=4}, vector3i{X:=2, Z:=7, Y:=5},
                    vector3i{X:=3, Z:=7, Y:=-4}, vector3i{X:=3, Z:=7, Y:=-3}, vector3i{X:=3, Z:=7, Y:=-2}, vector3i{X:=3, Z:=7, Y:=-1}, vector3i{X:=3, Z:=7, Y:=0}, vector3i{X:=3, Z:=7, Y:=1}, vector3i{X:=3, Z:=7, Y:=2}, vector3i{X:=3, Z:=7, Y:=3}, vector3i{X:=3, Z:=7, Y:=4}, vector3i{X:=3, Z:=7, Y:=5},
                    vector3i{X:=4, Z:=7, Y:=-4}, vector3i{X:=4, Z:=7, Y:=-3}, vector3i{X:=4, Z:=7, Y:=-2}, vector3i{X:=4, Z:=7, Y:=-1}, vector3i{X:=4, Z:=7, Y:=0}, vector3i{X:=4, Z:=7, Y:=1}, vector3i{X:=4, Z:=7, Y:=2}, vector3i{X:=4, Z:=7, Y:=3}, vector3i{X:=4, Z:=7, Y:=4}, vector3i{X:=4, Z:=7, Y:=5},
                    vector3i{X:=5, Z:=7, Y:=-4}, vector3i{X:=5, Z:=7, Y:=-3}, vector3i{X:=5, Z:=7, Y:=-2}, vector3i{X:=5, Z:=7, Y:=-1}, vector3i{X:=5, Z:=7, Y:=0}, vector3i{X:=5, Z:=7, Y:=1}, vector3i{X:=5, Z:=7, Y:=2}, vector3i{X:=5, Z:=7, Y:=3}, vector3i{X:=5, Z:=7, Y:=4}, vector3i{X:=5, Z:=7, Y:=5},
    
                    # // Layer at Z=8 (Height = 8) - 10x10 square = 100 blocks
                    # // X from -4 to 5, Y from -4 to 5
                    vector3i{X:=-4, Z:=8, Y:=-4}, vector3i{X:=-4, Z:=8, Y:=-3}, vector3i{X:=-4, Z:=8, Y:=-2}, vector3i{X:=-4, Z:=8, Y:=-1}, vector3i{X:=-4, Z:=8, Y:=0}, vector3i{X:=-4, Z:=8, Y:=1}, vector3i{X:=-4, Z:=8, Y:=2}, vector3i{X:=-4, Z:=8, Y:=3}, vector3i{X:=-4, Z:=8, Y:=4}, vector3i{X:=-4, Z:=8, Y:=5},
                    vector3i{X:=-3, Z:=8, Y:=-4}, vector3i{X:=-3, Z:=8, Y:=-3}, vector3i{X:=-3, Z:=8, Y:=-2}, vector3i{X:=-3, Z:=8, Y:=-1}, vector3i{X:=-3, Z:=8, Y:=0}, vector3i{X:=-3, Z:=8, Y:=1}, vector3i{X:=-3, Z:=8, Y:=2}, vector3i{X:=-3, Z:=8, Y:=3}, vector3i{X:=-3, Z:=8, Y:=4}, vector3i{X:=-3, Z:=8, Y:=5},
                    vector3i{X:=-2, Z:=8, Y:=-4}, vector3i{X:=-2, Z:=8, Y:=-3}, vector3i{X:=-2, Z:=8, Y:=-2}, vector3i{X:=-2, Z:=8, Y:=-1}, vector3i{X:=-2, Z:=8, Y:=0}, vector3i{X:=-2, Z:=8, Y:=1}, vector3i{X:=-2, Z:=8, Y:=2}, vector3i{X:=-2, Z:=8, Y:=3}, vector3i{X:=-2, Z:=8, Y:=4}, vector3i{X:=-2, Z:=8, Y:=5},
                    vector3i{X:=-1, Z:=8, Y:=-4}, vector3i{X:=-1, Z:=8, Y:=-3}, vector3i{X:=-1, Z:=8, Y:=-2}, vector3i{X:=-1, Z:=8, Y:=-1}, vector3i{X:=-1, Z:=8, Y:=0}, vector3i{X:=-1, Z:=8, Y:=1}, vector3i{X:=-1, Z:=8, Y:=2}, vector3i{X:=-1, Z:=8, Y:=3}, vector3i{X:=-1, Z:=8, Y:=4}, vector3i{X:=-1, Z:=8, Y:=5},
                    vector3i{X:=0, Z:=8, Y:=-4}, vector3i{X:=0, Z:=8, Y:=-3}, vector3i{X:=0, Z:=8, Y:=-2}, vector3i{X:=0, Z:=8, Y:=-1}, vector3i{X:=0, Z:=8, Y:=0}, vector3i{X:=0, Z:=8, Y:=1}, vector3i{X:=0, Z:=8, Y:=2}, vector3i{X:=0, Z:=8, Y:=3}, vector3i{X:=0, Z:=8, Y:=4}, vector3i{X:=0, Z:=8, Y:=5},
                    vector3i{X:=1, Z:=8, Y:=-4}, vector3i{X:=1, Z:=8, Y:=-3}, vector3i{X:=1, Z:=8, Y:=-2}, vector3i{X:=1, Z:=8, Y:=-1}, vector3i{X:=1, Z:=8, Y:=0}, vector3i{X:=1, Z:=8, Y:=1}, vector3i{X:=1, Z:=8, Y:=2}, vector3i{X:=1, Z:=8, Y:=3}, vector3i{X:=1, Z:=8, Y:=4}, vector3i{X:=1, Z:=8, Y:=5},
                    vector3i{X:=2, Z:=8, Y:=-4}, vector3i{X:=2, Z:=8, Y:=-3}, vector3i{X:=2, Z:=8, Y:=-2}, vector3i{X:=2, Z:=8, Y:=-1}, vector3i{X:=2, Z:=8, Y:=0}, vector3i{X:=2, Z:=8, Y:=1}, vector3i{X:=2, Z:=8, Y:=2}, vector3i{X:=2, Z:=8, Y:=3}, vector3i{X:=2, Z:=8, Y:=4}, vector3i{X:=2, Z:=8, Y:=5},
                    vector3i{X:=3, Z:=8, Y:=-4}, vector3i{X:=3, Z:=8, Y:=-3}, vector3i{X:=3, Z:=8, Y:=-2}, vector3i{X:=3, Z:=8, Y:=-1}, vector3i{X:=3, Z:=8, Y:=0}, vector3i{X:=3, Z:=8, Y:=1}, vector3i{X:=3, Z:=8, Y:=2}, vector3i{X:=3, Z:=8, Y:=3}, vector3i{X:=3, Z:=8, Y:=4}, vector3i{X:=3, Z:=8, Y:=5},
                    vector3i{X:=4, Z:=8, Y:=-4}, vector3i{X:=4, Z:=8, Y:=-3}, vector3i{X:=4, Z:=8, Y:=-2}, vector3i{X:=4, Z:=8, Y:=-1}, vector3i{X:=4, Z:=8, Y:=0}, vector3i{X:=4, Z:=8, Y:=1}, vector3i{X:=4, Z:=8, Y:=2}, vector3i{X:=4, Z:=8, Y:=3}, vector3i{X:=4, Z:=8, Y:=4}, vector3i{X:=4, Z:=8, Y:=5},
                    vector3i{X:=5, Z:=8, Y:=-4}, vector3i{X:=5, Z:=8, Y:=-3}, vector3i{X:=5, Z:=8, Y:=-2}, vector3i{X:=5, Z:=8, Y:=-1}, vector3i{X:=5, Z:=8, Y:=0}, vector3i{X:=5, Z:=8, Y:=1}, vector3i{X:=5, Z:=8, Y:=2}, vector3i{X:=5, Z:=8, Y:=3}, vector3i{X:=5, Z:=8, Y:=4}, vector3i{X:=5, Z:=8, Y:=5},
    
                    # // Layer at Z=9 (Height = 9) - 8x8 square = 64 blocks
                    # // X from -3 to 4, Y from -3 to 4
                    vector3i{X:=-3, Z:=9, Y:=-3}, vector3i{X:=-3, Z:=9, Y:=-2}, vector3i{X:=-3, Z:=9, Y:=-1}, vector3i{X:=-3, Z:=9, Y:=0}, vector3i{X:=-3, Z:=9, Y:=1}, vector3i{X:=-3, Z:=9, Y:=2}, vector3i{X:=-3, Z:=9, Y:=3}, vector3i{X:=-3, Z:=9, Y:=4},
                    vector3i{X:=-2, Z:=9, Y:=-3}, vector3i{X:=-2, Z:=9, Y:=-2}, vector3i{X:=-2, Z:=9, Y:=-1}, vector3i{X:=-2, Z:=9, Y:=0}, vector3i{X:=-2, Z:=9, Y:=1}, vector3i{X:=-2, Z:=9, Y:=2}, vector3i{X:=-2, Z:=9, Y:=3}, vector3i{X:=-2, Z:=9, Y:=4},
                    vector3i{X:=-1, Z:=9, Y:=-3}, vector3i{X:=-1, Z:=9, Y:=-2}, vector3i{X:=-1, Z:=9, Y:=-1}, vector3i{X:=-1, Z:=9, Y:=0}, vector3i{X:=-1, Z:=9, Y:=1}, vector3i{X:=-1, Z:=9, Y:=2}, vector3i{X:=-1, Z:=9, Y:=3}, vector3i{X:=-1, Z:=9, Y:=4},
                    vector3i{X:=0, Z:=9, Y:=-3}, vector3i{X:=0, Z:=9, Y:=-2}, vector3i{X:=0, Z:=9, Y:=-1}, vector3i{X:=0, Z:=9, Y:=0}, vector3i{X:=0, Z:=9, Y:=1}, vector3i{X:=0, Z:=9, Y:=2}, vector3i{X:=0, Z:=9, Y:=3}, vector3i{X:=0, Z:=9, Y:=4},
                    vector3i{X:=1, Z:=9, Y:=-3}, vector3i{X:=1, Z:=9, Y:=-2}, vector3i{X:=1, Z:=9, Y:=-1}, vector3i{X:=1, Z:=9, Y:=0}, vector3i{X:=1, Z:=9, Y:=1}, vector3i{X:=1, Z:=9, Y:=2}, vector3i{X:=1, Z:=9, Y:=3}, vector3i{X:=1, Z:=9, Y:=4},
                    vector3i{X:=2, Z:=9, Y:=-3}, vector3i{X:=2, Z:=9, Y:=-2}, vector3i{X:=2, Z:=9, Y:=-1}, vector3i{X:=2, Z:=9, Y:=0}, vector3i{X:=2, Z:=9, Y:=1}, vector3i{X:=2, Z:=9, Y:=2}, vector3i{X:=2, Z:=9, Y:=3}, vector3i{X:=2, Z:=9, Y:=4},
                    vector3i{X:=3, Z:=9, Y:=-3}, vector3i{X:=3, Z:=9, Y:=-2}, vector3i{X:=3, Z:=9, Y:=-1}, vector3i{X:=3, Z:=9, Y:=0}, vector3i{X:=3, Z:=9, Y:=1}, vector3i{X:=3, Z:=9, Y:=2}, vector3i{X:=3, Z:=9, Y:=3}, vector3i{X:=3, Z:=9, Y:=4},
                    vector3i{X:=4, Z:=9, Y:=-3}, vector3i{X:=4, Z:=9, Y:=-2}, vector3i{X:=4, Z:=9, Y:=-1}, vector3i{X:=4, Z:=9, Y:=0}, vector3i{X:=4, Z:=9, Y:=1}, vector3i{X:=4, Z:=9, Y:=2}, vector3i{X:=4, Z:=9, Y:=3}, vector3i{X:=4, Z:=9, Y:=4},
    
                    # // Layer at Z=10 (Height = 10) - 8x8 square = 64 blocks
                    # // X from -3 to 4, Y from -3 to 4
                    vector3i{X:=-3, Z:=10, Y:=-3}, vector3i{X:=-3, Z:=10, Y:=-2}, vector3i{X:=-3, Z:=10, Y:=-1}, vector3i{X:=-3, Z:=10, Y:=0}, vector3i{X:=-3, Z:=10, Y:=1}, vector3i{X:=-3, Z:=10, Y:=2}, vector3i{X:=-3, Z:=10, Y:=3}, vector3i{X:=-3, Z:=10, Y:=4},
                    vector3i{X:=-2, Z:=10, Y:=-3}, vector3i{X:=-2, Z:=10, Y:=-2}, vector3i{X:=-2, Z:=10, Y:=-1}, vector3i{X:=-2, Z:=10, Y:=0}, vector3i{X:=-2, Z:=10, Y:=1}, vector3i{X:=-2, Z:=10, Y:=2}, vector3i{X:=-2, Z:=10, Y:=3}, vector3i{X:=-2, Z:=10, Y:=4},
                    vector3i{X:=-1, Z:=10, Y:=-3}, vector3i{X:=-1, Z:=10, Y:=-2}, vector3i{X:=-1, Z:=10, Y:=-1}, vector3i{X:=-1, Z:=10, Y:=0}, vector3i{X:=-1, Z:=10, Y:=1}, vector3i{X:=-1, Z:=10, Y:=2}, vector3i{X:=-1, Z:=10, Y:=3}, vector3i{X:=-1, Z:=10, Y:=4},
                    vector3i{X:=0, Z:=10, Y:=-3}, vector3i{X:=0, Z:=10, Y:=-2}, vector3i{X:=0, Z:=10, Y:=-1}, vector3i{X:=0, Z:=10, Y:=0}, vector3i{X:=0, Z:=10, Y:=1}, vector3i{X:=0, Z:=10, Y:=2}, vector3i{X:=0, Z:=10, Y:=3}, vector3i{X:=0, Z:=10, Y:=4},
                    vector3i{X:=1, Z:=10, Y:=-3}, vector3i{X:=1, Z:=10, Y:=-2}, vector3i{X:=1, Z:=10, Y:=-1}, vector3i{X:=1, Z:=10, Y:=0}, vector3i{X:=1, Z:=10, Y:=1}, vector3i{X:=1, Z:=10, Y:=2}, vector3i{X:=1, Z:=10, Y:=3}, vector3i{X:=1, Z:=10, Y:=4},
                    vector3i{X:=2, Z:=10, Y:=-3}, vector3i{X:=2, Z:=10, Y:=-2}, vector3i{X:=2, Z:=10, Y:=-1}, vector3i{X:=2, Z:=10, Y:=0}, vector3i{X:=2, Z:=10, Y:=1}, vector3i{X:=2, Z:=10, Y:=2}, vector3i{X:=2, Z:=10, Y:=3}, vector3i{X:=2, Z:=10, Y:=4},
                    vector3i{X:=3, Z:=10, Y:=-3}, vector3i{X:=3, Z:=10, Y:=-2}, vector3i{X:=3, Z:=10, Y:=-1}, vector3i{X:=3, Z:=10, Y:=0}, vector3i{X:=3, Z:=10, Y:=1}, vector3i{X:=3, Z:=10, Y:=2}, vector3i{X:=3, Z:=10, Y:=3}, vector3i{X:=3, Z:=10, Y:=4},
                    vector3i{X:=4, Z:=10, Y:=-3}, vector3i{X:=4, Z:=10, Y:=-2}, vector3i{X:=4, Z:=10, Y:=-1}, vector3i{X:=4, Z:=10, Y:=0}, vector3i{X:=4, Z:=10, Y:=1}, vector3i{X:=4, Z:=10, Y:=2}, vector3i{X:=4, Z:=10, Y:=3}, vector3i{X:=4, Z:=10, Y:=4},
    
                    # // Layer at Z=11 (Height = 11) - 6x6 square = 36 blocks
                    # // X from -2 to 3, Y from -2 to 3
                    vector3i{X:=-2, Z:=11, Y:=-2}, vector3i{X:=-2, Z:=11, Y:=-1}, vector3i{X:=-2, Z:=11, Y:=0}, vector3i{X:=-2, Z:=11, Y:=1}, vector3i{X:=-2, Z:=11, Y:=2}, vector3i{X:=-2, Z:=11, Y:=3},
                    vector3i{X:=-1, Z:=11, Y:=-2}, vector3i{X:=-1, Z:=11, Y:=-1}, vector3i{X:=-1, Z:=11, Y:=0}, vector3i{X:=-1, Z:=11, Y:=1}, vector3i{X:=-1, Z:=11, Y:=2}, vector3i{X:=-1, Z:=11, Y:=3},
                    vector3i{X:=0, Z:=11, Y:=-2}, vector3i{X:=0, Z:=11, Y:=-1}, vector3i{X:=0, Z:=11, Y:=0}, vector3i{X:=0, Z:=11, Y:=1}, vector3i{X:=0, Z:=11, Y:=2}, vector3i{X:=0, Z:=11, Y:=3},
                    vector3i{X:=1, Z:=11, Y:=-2}, vector3i{X:=1, Z:=11, Y:=-1}, vector3i{X:=1, Z:=11, Y:=0}, vector3i{X:=1, Z:=11, Y:=1}, vector3i{X:=1, Z:=11, Y:=2}, vector3i{X:=1, Z:=11, Y:=3},
                    vector3i{X:=2, Z:=11, Y:=-2}, vector3i{X:=2, Z:=11, Y:=-1}, vector3i{X:=2, Z:=11, Y:=0}, vector3i{X:=2, Z:=11, Y:=1}, vector3i{X:=2, Z:=11, Y:=2}, vector3i{X:=2, Z:=11, Y:=3},
                    vector3i{X:=3, Z:=11, Y:=-2}, vector3i{X:=3, Z:=11, Y:=-1}, vector3i{X:=3, Z:=11, Y:=0}, vector3i{X:=3, Z:=11, Y:=1}, vector3i{X:=3, Z:=11, Y:=2}, vector3i{X:=3, Z:=11, Y:=3},
    
                    # // Layer at Z=12 (Height = 12) - 6x6 square = 36 blocks
                    # // X from -2 to 3, Y from -2 to 3
                    vector3i{X:=-2, Z:=12, Y:=-2}, vector3i{X:=-2, Z:=12, Y:=-1}, vector3i{X:=-2, Z:=12, Y:=0}, vector3i{X:=-2, Z:=12, Y:=1}, vector3i{X:=-2, Z:=12, Y:=2}, vector3i{X:=-2, Z:=12, Y:=3},
                    vector3i{X:=-1, Z:=12, Y:=-2}, vector3i{X:=-1, Z:=12, Y:=-1}, vector3i{X:=-1, Z:=12, Y:=0}, vector3i{X:=-1, Z:=12, Y:=1}, vector3i{X:=-1, Z:=12, Y:=2}, vector3i{X:=-1, Z:=12, Y:=3},
                    vector3i{X:=0, Z:=12, Y:=-2}, vector3i{X:=0, Z:=12, Y:=-1}, vector3i{X:=0, Z:=12, Y:=0}, vector3i{X:=0, Z:=12, Y:=1}, vector3i{X:=0, Z:=12, Y:=2}, vector3i{X:=0, Z:=12, Y:=3},
                    vector3i{X:=1, Z:=12, Y:=-2}, vector3i{X:=1, Z:=12, Y:=-1}, vector3i{X:=1, Z:=12, Y:=0}, vector3i{X:=1, Z:=12, Y:=1}, vector3i{X:=1, Z:=12, Y:=2}, vector3i{X:=1, Z:=12, Y:=3},
                    vector3i{X:=2, Z:=12, Y:=-2}, vector3i{X:=2, Z:=12, Y:=-1}, vector3i{X:=2, Z:=12, Y:=0}, vector3i{X:=2, Z:=12, Y:=1}, vector3i{X:=2, Z:=12, Y:=2}, vector3i{X:=2, Z:=12, Y:=3},
                    vector3i{X:=3, Z:=12, Y:=-2}, vector3i{X:=3, Z:=12, Y:=-1}, vector3i{X:=3, Z:=12, Y:=0}, vector3i{X:=3, Z:=12, Y:=1}, vector3i{X:=3, Z:=12, Y:=2}, vector3i{X:=3, Z:=12, Y:=3},
    
                    # // Layer at Z=13 (Height = 13) - 4x4 square = 16 blocks
                    # // X from -1 to 2, Y from -1 to 2
                    vector3i{X:=-1, Z:=13, Y:=-1}, vector3i{X:=-1, Z:=13, Y:=0}, vector3i{X:=-1, Z:=13, Y:=1}, vector3i{X:=-1, Z:=13, Y:=2},
                    vector3i{X:=0, Z:=13, Y:=-1}, vector3i{X:=0, Z:=13, Y:=0}, vector3i{X:=0, Z:=13, Y:=1}, vector3i{X:=0, Z:=13, Y:=2},
                    vector3i{X:=1, Z:=13, Y:=-1}, vector3i{X:=1, Z:=13, Y:=0}, vector3i{X:=1, Z:=13, Y:=1}, vector3i{X:=1, Z:=13, Y:=2},
                    vector3i{X:=2, Z:=13, Y:=-1}, vector3i{X:=2, Z:=13, Y:=0}, vector3i{X:=2, Z:=13, Y:=1}, vector3i{X:=2, Z:=13, Y:=2},
    
                    # // Layer at Z=14 (Height = 14) - 4x4 square = 16 blocks (Trunk Top Level)
                    # // X from -1 to 2, Y from -1 to 2
                    vector3i{X:=-1, Z:=14, Y:=-1}, vector3i{X:=-1, Z:=14, Y:=0}, vector3i{X:=-1, Z:=14, Y:=1}, vector3i{X:=-1, Z:=14, Y:=2},
                    vector3i{X:=0, Z:=14, Y:=-1}, vector3i{X:=0, Z:=14, Y:=0}, vector3i{X:=0, Z:=14, Y:=1}, vector3i{X:=0, Z:=14, Y:=2},
                    vector3i{X:=1, Z:=14, Y:=-1}, vector3i{X:=1, Z:=14, Y:=0}, vector3i{X:=1, Z:=14, Y:=1}, vector3i{X:=1, Z:=14, Y:=2},
                    vector3i{X:=2, Z:=14, Y:=-1}, vector3i{X:=2, Z:=14, Y:=0}, vector3i{X:=2, Z:=14, Y:=1}, vector3i{X:=2, Z:=14, Y:=2},
    
                    # // Layer at Z=15 (Height = 15) - 4x4 square = 16 blocks
                    # // X from -1 to 2, Y from -1 to 2
                    vector3i{X:=-1, Z:=15, Y:=-1}, vector3i{X:=-1, Z:=15, Y:=0}, vector3i{X:=-1, Z:=15, Y:=1}, vector3i{X:=-1, Z:=15, Y:=2},
                    vector3i{X:=0, Z:=15, Y:=-1}, vector3i{X:=0, Z:=15, Y:=0}, vector3i{X:=0, Z:=15, Y:=1}, vector3i{X:=0, Z:=15, Y:=2},
                    vector3i{X:=1, Z:=15, Y:=-1}, vector3i{X:=1, Z:=15, Y:=0}, vector3i{X:=1, Z:=15, Y:=1}, vector3i{X:=1, Z:=15, Y:=2},
                    vector3i{X:=2, Z:=15, Y:=-1}, vector3i{X:=2, Z:=15, Y:=0}, vector3i{X:=2, Z:=15, Y:=1}, vector3i{X:=2, Z:=15, Y:=2},
    
                    # // Layer at Z=16 (Height = 16) - 4x4 square = 16 blocks
                    # // X from -1 to 2, Y from -1 to 2
                    vector3i{X:=-1, Z:=16, Y:=-1}, vector3i{X:=-1, Z:=16, Y:=0}, vector3i{X:=-1, Z:=16, Y:=1}, vector3i{X:=-1, Z:=16, Y:=2},
                    vector3i{X:=0, Z:=16, Y:=-1}, vector3i{X:=0, Z:=16, Y:=0}, vector3i{X:=0, Z:=16, Y:=1}, vector3i{X:=0, Z:=16, Y:=2},
                    vector3i{X:=1, Z:=16, Y:=-1}, vector3i{X:=1, Z:=16, Y:=0}, vector3i{X:=1, Z:=16, Y:=1}, vector3i{X:=1, Z:=16, Y:=2},
                    vector3i{X:=2, Z:=16, Y:=-1}, vector3i{X:=2, Z:=16, Y:=0}, vector3i{X:=2, Z:=16, Y:=1}, vector3i{X:=2, Z:=16, Y:=2},
    
                    # // Layer at Z=17 (Height = 17) - 2x2 square = 4 blocks
                    # // X from 0 to 1, Y from 0 to 1
                    vector3i{X:=0, Z:=17, Y:=0}, vector3i{X:=0, Z:=17, Y:=1},
                    vector3i{X:=1, Z:=17, Y:=0}, vector3i{X:=1, Z:=17, Y:=1},
    
                    # // Layer at Z=18 (Height = 18) - Cross shape = 8 blocks
                    vector3i{X:=0, Z:=18, Y:=-1}, vector3i{X:=1, Z:=18, Y:=-1},
                    vector3i{X:=0, Z:=18, Y:=2}, vector3i{X:=1, Z:=18, Y:=2},
                    vector3i{X:=-1, Z:=18, Y:=0}, vector3i{X:=-1, Z:=18, Y:=1},
                    vector3i{X:=2, Z:=18, Y:=0}, vector3i{X:=2, Z:=18, Y:=1},

                    # // Layer at Z=19 (Height = 19) - Cross shape = 8 blocks
                    vector3i{X:=0, Z:=19, Y:=-1}, vector3i{X:=1, Z:=19, Y:=-1},
                    vector3i{X:=0, Z:=19, Y:=2}, vector3i{X:=1, Z:=19, Y:=2},
                    vector3i{X:=-1, Z:=19, Y:=0}, vector3i{X:=-1, Z:=19, Y:=1},
                    vector3i{X:=2, Z:=19, Y:=0}, vector3i{X:=2, Z:=19, Y:=1},
    
                    # // Layer at Z=20 (Height = 20) - 2x2 square = 4 blocks
                    # // X from 0 to 1, Y from 0 to 1
                    vector3i{X:=0, Z:=20, Y:=0}, vector3i{X:=0, Z:=20, Y:=1},
                    vector3i{X:=1, Z:=20, Y:=0}, vector3i{X:=1, Z:=20, Y:=1},
    
                    # // Layer at Z=21 (Height = 21) - Tip = 1 block
                    vector3i{X:=0, Z:=21, Y:=0}
                }
            },
            structure_block_wrapper{
                BlockTypes := block_type.SpruceLog,
                BlockPositions := array{
                    # // Trunk: Z from 0 to 14. For each Z: (X=0,Y=0), (X=1,Y=0), (X=0,Y=1), (X=1,Y=1)
                    # // Total 15 layers * 4 blocks/layer = 60 blocks
    
                    # // Z=0
                    vector3i{X:=0, Z:=0, Y:=0}, vector3i{X:=1, Z:=0, Y:=0}, vector3i{X:=0, Z:=0, Y:=1}, vector3i{X:=1, Z:=0, Y:=1},
                    vector3i{X:=0, Z:=1, Y:=0}, vector3i{X:=1, Z:=1, Y:=0}, vector3i{X:=0, Z:=1, Y:=1}, vector3i{X:=1, Z:=1, Y:=1},
                    vector3i{X:=0, Z:=2, Y:=0}, vector3i{X:=1, Z:=2, Y:=0}, vector3i{X:=0, Z:=2, Y:=1}, vector3i{X:=1, Z:=2, Y:=1},
                    vector3i{X:=0, Z:=3, Y:=0}, vector3i{X:=1, Z:=3, Y:=0}, vector3i{X:=0, Z:=3, Y:=1}, vector3i{X:=1, Z:=3, Y:=1},
                    vector3i{X:=0, Z:=4, Y:=0}, vector3i{X:=1, Z:=4, Y:=0}, vector3i{X:=0, Z:=4, Y:=1}, vector3i{X:=1, Z:=4, Y:=1},
                    vector3i{X:=0, Z:=5, Y:=0}, vector3i{X:=1, Z:=5, Y:=0}, vector3i{X:=0, Z:=5, Y:=1}, vector3i{X:=1, Z:=5, Y:=1},
                    vector3i{X:=0, Z:=6, Y:=0}, vector3i{X:=1, Z:=6, Y:=0}, vector3i{X:=0, Z:=6, Y:=1}, vector3i{X:=1, Z:=6, Y:=1},
                    vector3i{X:=0, Z:=7, Y:=0}, vector3i{X:=1, Z:=7, Y:=0}, vector3i{X:=0, Z:=7, Y:=1}, vector3i{X:=1, Z:=7, Y:=1},
                    vector3i{X:=0, Z:=8, Y:=0}, vector3i{X:=1, Z:=8, Y:=0}, vector3i{X:=0, Z:=8, Y:=1}, vector3i{X:=1, Z:=8, Y:=1},
                    vector3i{X:=0, Z:=9, Y:=0}, vector3i{X:=1, Z:=9, Y:=0}, vector3i{X:=0, Z:=9, Y:=1}, vector3i{X:=1, Z:=9, Y:=1},
                    vector3i{X:=0, Z:=10, Y:=0}, vector3i{X:=1, Z:=10, Y:=0}, vector3i{X:=0, Z:=10, Y:=1}, vector3i{X:=1, Z:=10, Y:=1},
                    vector3i{X:=0, Z:=11, Y:=0}, vector3i{X:=1, Z:=11, Y:=0}, vector3i{X:=0, Z:=11, Y:=1}, vector3i{X:=1, Z:=11, Y:=1},
                    vector3i{X:=0, Z:=12, Y:=0}, vector3i{X:=1, Z:=12, Y:=0}, vector3i{X:=0, Z:=12, Y:=1}, vector3i{X:=1, Z:=12, Y:=1},
                    vector3i{X:=0, Z:=13, Y:=0}, vector3i{X:=1, Z:=13, Y:=0}, vector3i{X:=0, Z:=13, Y:=1}, vector3i{X:=1, Z:=13, Y:=1},
                    vector3i{X:=0, Z:=14, Y:=0}, vector3i{X:=1, Z:=14, Y:=0}, vector3i{X:=0, Z:=14, Y:=1}, vector3i{X:=1, Z:=14, Y:=1}
                }
            }



    

    # DO NO USE PREBUILT TREE 2
    PrebuiltTree2 : structure_wrapper = structure_wrapper:
        StructureName := "Oak Tree",
        StructureBlocks := array:
            structure_block_wrapper{
                BlockTypes := block_type.OakLeaves,
                BlockPositions := array{
                    # // Layer at Z=4 (Height = 4)
                    # // Leaves start here, after the 4th log block. This layer is 1 block below trunk top.
                    # // Forms a 3x3 square around the trunk (8 leaves).
                    vector3i{X:=-1, Z:=4, Y:=-1}, vector3i{X:=-1, Z:=4, Y:=0}, vector3i{X:=-1, Z:=4, Y:=1},
                    vector3i{X:=0, Z:=4, Y:=-1},                               vector3i{X:=0, Z:=4, Y:=1},
                    vector3i{X:=1, Z:=4, Y:=-1}, vector3i{X:=1, Z:=4, Y:=0}, vector3i{X:=1, Z:=4, Y:=1},
    
                    # // Layer at Z=5 (Height = 5)
                    # // This layer is at the top of the trunk.
                    # // Forms a 5x5 square with center (trunk position) empty (24 leaves).
                    vector3i{X:=-2, Z:=5, Y:=-2}, vector3i{X:=-2, Z:=5, Y:=-1}, vector3i{X:=-2, Z:=5, Y:=0}, vector3i{X:=-2, Z:=5, Y:=1}, vector3i{X:=-2, Z:=5, Y:=2},
                    vector3i{X:=-1, Z:=5, Y:=-2}, vector3i{X:=-1, Z:=5, Y:=-1}, vector3i{X:=-1, Z:=5, Y:=0}, vector3i{X:=-1, Z:=5, Y:=1}, vector3i{X:=-1, Z:=5, Y:=2},
                    vector3i{X:=0, Z:=5, Y:=-2}, vector3i{X:=0, Z:=5, Y:=-1},                               vector3i{X:=0, Z:=5, Y:=1}, vector3i{X:=0, Z:=5, Y:=2},
                    vector3i{X:=1, Z:=5, Y:=-2}, vector3i{X:=1, Z:=5, Y:=-1}, vector3i{X:=1, Z:=5, Y:=0}, vector3i{X:=1, Z:=5, Y:=1}, vector3i{X:=1, Z:=5, Y:=2},
                    vector3i{X:=2, Z:=5, Y:=-2}, vector3i{X:=2, Z:=5, Y:=-1}, vector3i{X:=2, Z:=5, Y:=0}, vector3i{X:=2, Z:=5, Y:=1}, vector3i{X:=2, Z:=5, Y:=2},
    
                    # // Layer at Z=6 (Height = 6)
                    # // This layer is 1 block above the trunk top.
                    # // Forms a 5x5 cross shape (13 leaves).
                    vector3i{X:=-2, Z:=6, Y:=0},
                    vector3i{X:=-1, Z:=6, Y:=-1}, vector3i{X:=-1, Z:=6, Y:=0}, vector3i{X:=-1, Z:=6, Y:=1},
                    vector3i{X:=0, Z:=6, Y:=-2}, vector3i{X:=0, Z:=6, Y:=-1}, vector3i{X:=0, Z:=6, Y:=0}, vector3i{X:=0, Z:=6, Y:=1}, vector3i{X:=0, Z:=6, Y:=2},
                    vector3i{X:=1, Z:=6, Y:=-1}, vector3i{X:=1, Z:=6, Y:=0}, vector3i{X:=1, Z:=6, Y:=1},
                    vector3i{X:=2, Z:=6, Y:=0},
    
                    # // Layer at Z=7 (Height = 7)
                    # // This layer is 2 blocks above the trunk top (topmost leaves).
                    # // Forms a 3x3 cross shape (5 leaves).
                    vector3i{X:=-1, Z:=7, Y:=0},
                    vector3i{X:=0, Z:=7, Y:=-1}, vector3i{X:=0, Z:=7, Y:=0}, vector3i{X:=0, Z:=7, Y:=1},
                    vector3i{X:=1, Z:=7, Y:=0}
                }
            },
            structure_block_wrapper{
                BlockTypes := block_type.OakLog,
                BlockPositions := array{
                    vector3i{X:=0, Z:=0, Y:=0},
                    vector3i{X:=0, Z:=1, Y:=0},
                    vector3i{X:=0, Z:=2, Y:=0},
                    vector3i{X:=0, Z:=3, Y:=0},
                    vector3i{X:=0, Z:=4, Y:=0},
                    vector3i{X:=0, Z:=5, Y:=0}
                }
            }


    OakTree : structure_wrapper = structure_wrapper:
        StructureName := "Oak Tree",
        StructureBlocks := array:
            structure_block_wrapper{
                BlockTypes := block_type.OakLeaves,
                BlockPositions := array{
                    # // Layer at Z=4 (Height = 4)
                    # // Leaves start here, after the 4th log block. This layer is 1 block below trunk top.
                    # // Forms a 3x3 square around the trunk (8 leaves).
                    vector3i{X:=-1, Z:=4, Y:=-1}, vector3i{X:=-1, Z:=4, Y:=0}, vector3i{X:=-1, Z:=4, Y:=1},
                    vector3i{X:=0, Z:=4, Y:=-1},                               vector3i{X:=0, Z:=4, Y:=1},
                    vector3i{X:=1, Z:=4, Y:=-1}, vector3i{X:=1, Z:=4, Y:=0}, vector3i{X:=1, Z:=4, Y:=1},
    
                    # // Layer at Z=5 (Height = 5)
                    # // This layer is at the top of the trunk.
                    # // Forms a 5x5 square with center (trunk position) empty (24 leaves).
                    vector3i{X:=-2, Z:=5, Y:=-2}, vector3i{X:=-2, Z:=5, Y:=-1}, vector3i{X:=-2, Z:=5, Y:=0}, vector3i{X:=-2, Z:=5, Y:=1}, vector3i{X:=-2, Z:=5, Y:=2},
                    vector3i{X:=-1, Z:=5, Y:=-2}, vector3i{X:=-1, Z:=5, Y:=-1}, vector3i{X:=-1, Z:=5, Y:=0}, vector3i{X:=-1, Z:=5, Y:=1}, vector3i{X:=-1, Z:=5, Y:=2},
                    vector3i{X:=0, Z:=5, Y:=-2}, vector3i{X:=0, Z:=5, Y:=-1},                               vector3i{X:=0, Z:=5, Y:=1}, vector3i{X:=0, Z:=5, Y:=2},
                    vector3i{X:=1, Z:=5, Y:=-2}, vector3i{X:=1, Z:=5, Y:=-1}, vector3i{X:=1, Z:=5, Y:=0}, vector3i{X:=1, Z:=5, Y:=1}, vector3i{X:=1, Z:=5, Y:=2},
                    vector3i{X:=2, Z:=5, Y:=-2}, vector3i{X:=2, Z:=5, Y:=-1}, vector3i{X:=2, Z:=5, Y:=0}, vector3i{X:=2, Z:=5, Y:=1}, vector3i{X:=2, Z:=5, Y:=2},
    
                    # // Layer at Z=6 (Height = 6)
                    # // This layer is 1 block above the trunk top.
                    # // Forms a 5x5 cross shape (13 leaves).
                    vector3i{X:=-2, Z:=6, Y:=0},
                    vector3i{X:=-1, Z:=6, Y:=-1}, vector3i{X:=-1, Z:=6, Y:=0}, vector3i{X:=-1, Z:=6, Y:=1},
                    vector3i{X:=0, Z:=6, Y:=-2}, vector3i{X:=0, Z:=6, Y:=-1}, vector3i{X:=0, Z:=6, Y:=0}, vector3i{X:=0, Z:=6, Y:=1}, vector3i{X:=0, Z:=6, Y:=2},
                    vector3i{X:=1, Z:=6, Y:=-1}, vector3i{X:=1, Z:=6, Y:=0}, vector3i{X:=1, Z:=6, Y:=1},
                    vector3i{X:=2, Z:=6, Y:=0},
    
                    # // Layer at Z=7 (Height = 7)
                    # // This layer is 2 blocks above the trunk top (topmost leaves).
                    # // Forms a 3x3 cross shape (5 leaves).
                    vector3i{X:=-1, Z:=7, Y:=0},
                    vector3i{X:=0, Z:=7, Y:=-1}, vector3i{X:=0, Z:=7, Y:=0}, vector3i{X:=0, Z:=7, Y:=1},
                    vector3i{X:=1, Z:=7, Y:=0}
                }
            },
            structure_block_wrapper{
                BlockTypes := block_type.OakLog,
                BlockPositions := array{
                    vector3i{X:=0, Z:=0, Y:=0},
                    vector3i{X:=0, Z:=1, Y:=0},
                    vector3i{X:=0, Z:=2, Y:=0},
                    vector3i{X:=0, Z:=3, Y:=0},
                    vector3i{X:=0, Z:=4, Y:=0},
                    vector3i{X:=0, Z:=5, Y:=0}
                }
            }



    Initialize(BlockManager : block_manager_device) : void = 
        spawn. OnBegin()

    # Initialize(BlockManager : block_manager_device) : void = 
    #     spawn. OnBegin()

    OnBegin<override>()<suspends>:void=
        block{}
--- </structure_manager_device.verse> ---

--- <ui_manager_device.verse> ---

using { /Fortnite.com/UI }
using { /Verse.org/Colors }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/UI }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /Verse.org/Assets }

HUNGER_BAR_SCALE : float = 3.75

BORDER_TO_CONTENT_ITEM_SLOT_FACTOR : float = 0.8108108108
# BORDER_TO_CONTENT_ITEM_SLOT_OFFSET : float =

EXPERIENCE_BAR_SCALE : float = 4.5

HOT_BAR_SLOT_SIZE : float = 93.0






experience_bar_wrapper := class():
    ##### CONSTRUCT #####
    # ExperienceBars : float = 10.0
    # var RequiredExperiencePoints<private> : float = 10.0 # 10.0 * Pow(1.1, Level*1.0)
    var GainFactor<private> : float = 1.0 # 10.0 * Pow(1.1, Level*1.0)
    var ExperiencePoints<private> : float = 0.0
    var Level<private> : int = 0

    ##### INITIALIZE #####
    var Position<private> : vector2 = vector2{}
    var RefCanvas<private> : canvas = canvas{}

    var RefLevelUpEvent<private> : event() = event(){}

    ##### VARIABLES #####
    GetExperiencePoints<public>()<transacts> : float = ExperiencePoints
    SetExperiencePoints<public>(InExperiencePoints : float) : void = { set ExperiencePoints = InExperiencePoints; Update(); }
    
    GetLevel<public>()<transacts> : int = Level
    SetLevel<public>(InLevel : int)<transacts> : void =
        set Level = InLevel
        # set RequiredExperiencePoints = 10.0 * Pow(1.1, Level*1.0) 

        
    GainExperiencePoints<public>(InAmount : float) : void =
        Amount := GainFactor * InAmount
        if (ExperiencePoints + Amount*GainFactor >= ExperienceBarTextureBlocks.Length*1.0):
            LeftOver := Amount - (ExperienceBarTextureBlocks.Length*1.0-ExperiencePoints)
            set ExperiencePoints = LeftOver 
            set Level += 1
            set GainFactor = 1.0 / Pow(1.08, Level*1.0) 
            RefLevelUpEvent.Signal()
            LevelTextBlock.SetText(IntToMessage(Level))
        else:
            set ExperiencePoints += Amount
        Update()


    #### UI ####
    ExperienceBarQuarter : texture = Assets.UI.HUD.T_ExperienceBarQuarter 
    ExperienceBarHalf : texture = Assets.UI.HUD.T_ExperienceBarHalf 
    ExperienceBarThreeFourths : texture = Assets.UI.HUD.T_ExperienceBarThreeFourths 
    ExperienceBarFull : texture = Assets.UI.HUD.T_ExperienceBarFull 

    LevelTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Center
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=1.8, Y:=1.8}
        DefaultShadowOpacity := 1.0
        DefaultShadowColor := NamedColors.Green


    ExperienceBarTextureBlock : texture_block = texture_block:
        DefaultImage := Assets.UI.HUD.T_ExperienceBar 
        DefaultDesiredSize := vector2{X:= 182.0 * EXPERIENCE_BAR_SCALE, Y:= 5.0 * EXPERIENCE_BAR_SCALE}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    ExperienceBarTextureBlocks : []texture_block = array:
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := VerseAssets.TransparentTexture 
            DefaultDesiredSize := vector2{X:= 11.0*EXPERIENCE_BAR_SCALE, Y:= 5.0*EXPERIENCE_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    


    Anchor : anchors = anchors{Minimum := vector2{X := 0.500000, Y := 0.950000}, Maximum := vector2{X := 0.500000, Y := 0.950000}}

    var Initialized : logic = false
    Initiate<public>(LevelUpEvent : event(), InPosition : vector2, InCanvas : canvas) : void =
        if (Initialized?). Assert("Hunger Bar UI is already initialized")
        set Initialized = true

        set RefLevelUpEvent = LevelUpEvent
        set Position = InPosition
        set RefCanvas = InCanvas

        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 203
                Widget := ExperienceBarTextureBlock
        )

        for (Index->CurrentExperienceBarTextureBlock : ExperienceBarTextureBlocks):
            RefCanvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := Position.X - ExperienceBarTextureBlock.GetDesiredSize().X/2.0 + (CurrentExperienceBarTextureBlock.GetDesiredSize().X-1*EXPERIENCE_BAR_SCALE)*Index + CurrentExperienceBarTextureBlock.GetDesiredSize().X/2.0, Top := Position.Y, Right := 0.0, Bottom := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 204
                    Widget := CurrentExperienceBarTextureBlock
            )
            CurrentExperienceBarTextureBlock.SetVisibility(widget_visibility.Visible)

        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y - 8.0*EXPERIENCE_BAR_SCALE, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 203
                Widget := LevelTextBlock
        )

        ExperienceBarTextureBlock.SetVisibility(widget_visibility.Visible)
        LevelTextBlock.SetVisibility(widget_visibility.Visible)
        LevelTextBlock.SetText(IntToMessage(Level))
        Update()
        
    var IsOpen : logic = true
    Show<public>() : void = 
        if (IsOpen?). PrintError("HungerBar is already open")
        set IsOpen = true
        for (CurrentExperienceBarTextureBlock : ExperienceBarTextureBlocks):
            CurrentExperienceBarTextureBlock.SetVisibility(widget_visibility.Visible)
        ExperienceBarTextureBlock.SetVisibility(widget_visibility.Visible)
        LevelTextBlock.SetVisibility(widget_visibility.Visible)
    
    Hide<public>() : void = 
        if (not IsOpen?). PrintError("HungerBar is already hidden")
        set IsOpen = false
        for (CurrentExperienceBarTextureBlock : ExperienceBarTextureBlocks):
            CurrentExperienceBarTextureBlock.SetVisibility(widget_visibility.Hidden)
        ExperienceBarTextureBlock.SetVisibility(widget_visibility.Hidden)
        LevelTextBlock.SetVisibility(widget_visibility.Hidden)


    Update<public>() : void =
        for (Index->CurrentExperienceBarTextureBlock : ExperienceBarTextureBlocks):
            if (Index < Floor[ExperiencePoints]):
                CurrentExperienceBarTextureBlock.SetImage(ExperienceBarFull)
            else if (Index >= Ceil[ExperiencePoints]):
                CurrentExperienceBarTextureBlock.SetImage(VerseAssets.TransparentTexture)
            else:
                if (Fraction(ExperiencePoints) < 0.33):
                    CurrentExperienceBarTextureBlock.SetImage(ExperienceBarQuarter)
                else if (Fraction(ExperiencePoints) < 0.66):
                    CurrentExperienceBarTextureBlock.SetImage(ExperienceBarHalf)
                else:
                    CurrentExperienceBarTextureBlock.SetImage(ExperienceBarThreeFourths)






hunger_bar_wrapper := class():
    ##### CONSTRUCT #####
    MaxHungerBars : float = 14.0
    var Hunger : float = START_HUNGER_AMOUNT

    ##### INITIALIZE #####
    var Position : vector2 = vector2{}
    var RefCanvas<private> : canvas = canvas{}


    ##### VARIABLES #####
    GetHunger<public>()<transacts> : float = Hunger
    SetHunger<private>(InHunger : float)<transacts> : void = set Hunger = InHunger
    
    
    SetHungerBar<public>(InHunger : float) : void =
        set Hunger = InHunger
        Update()

    DecreaseHungerBar<public>(Amount : float) : void =
        set Hunger = Max(0.0, Hunger-Amount)
        Update()
        # Print("Hunger: {Hunger}")

    IncreaseHungerBar<public>(Amount : float) : void =
        set Hunger = Min(MaxHungerBars, Hunger+Amount)
        Update()


    #### UI ####
    HungerCoilFull : texture = Assets.UI.HUD.T_HungerCoilFull 
    HungerCoilHalf : texture = Assets.UI.HUD.T_HungerCoilHalf 

    EmptyHungerBarTextureBlock : texture_block = texture_block:
        DefaultImage := Assets.UI.HUD.T_HungerBar 
        DefaultDesiredSize := vector2{X:= 81.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    HungerCoilTextureBlocks : []texture_block = array:
        texture_block:
            DefaultImage := Assets.UI.HUD.T_HungerCoilFull 
            DefaultDesiredSize := vector2{X:= 9.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := Assets.UI.HUD.T_HungerCoilFull 
            DefaultDesiredSize := vector2{X:= 9.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := Assets.UI.HUD.T_HungerCoilFull 
            DefaultDesiredSize := vector2{X:= 9.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := Assets.UI.HUD.T_HungerCoilFull 
            DefaultDesiredSize := vector2{X:= 9.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := Assets.UI.HUD.T_HungerCoilFull 
            DefaultDesiredSize := vector2{X:= 9.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := Assets.UI.HUD.T_HungerCoilFull 
            DefaultDesiredSize := vector2{X:= 9.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := Assets.UI.HUD.T_HungerCoilFull 
            DefaultDesiredSize := vector2{X:= 9.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := Assets.UI.HUD.T_HungerCoilFull 
            DefaultDesiredSize := vector2{X:= 9.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := Assets.UI.HUD.T_HungerCoilFull 
            DefaultDesiredSize := vector2{X:= 9.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        texture_block:
            DefaultImage := Assets.UI.HUD.T_HungerCoilFull 
            DefaultDesiredSize := vector2{X:= 9.0*HUNGER_BAR_SCALE, Y:= 9.0*HUNGER_BAR_SCALE}
            DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    Anchor : anchors = anchors{Minimum := vector2{X := 0.500000, Y := 0.950000}, Maximum := vector2{X := 0.500000, Y := 0.950000}}

    var Initialized : logic = false
    Initiate<public>(InPosition : vector2, InCanvas : canvas) : void =
        if (Initialized?). Assert("Hunger Bar UI is already initialized")
        set Initialized = true

        set Position = InPosition
        set RefCanvas = InCanvas


        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 203
                Widget := EmptyHungerBarTextureBlock
        )

        for (Index->HungerCoilTextureBlock : HungerCoilTextureBlocks):
            RefCanvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := Position.X + 36.0*HUNGER_BAR_SCALE - Index*8.0*HUNGER_BAR_SCALE, Top := Position.Y, Right := 0.0, Bottom := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 204
                    Widget := HungerCoilTextureBlock
            )
            HungerCoilTextureBlock.SetVisibility(widget_visibility.Visible)
        EmptyHungerBarTextureBlock.SetVisibility(widget_visibility.Visible)
        Update()
        
    var IsOpen : logic = true
    Show<public>() : void = 
        # if (IsOpen?). PrintError("HungerBar is already open")
        set IsOpen = true
        for (HungerCoilTextureBlock : HungerCoilTextureBlocks):
            HungerCoilTextureBlock.SetVisibility(widget_visibility.Visible)
        EmptyHungerBarTextureBlock.SetVisibility(widget_visibility.Visible)
        
    Hide<public>() : void = 
        # if (not IsOpen?). PrintError("HungerBar is already hidden")
        set IsOpen = false
        for (HungerCoilTextureBlock : HungerCoilTextureBlocks):
            HungerCoilTextureBlock.SetVisibility(widget_visibility.Hidden)
        EmptyHungerBarTextureBlock.SetVisibility(widget_visibility.Hidden)

    Update<public>() : void =
        # Print("Hunger: {Hunger}")
        for (Index->HungerCoilTextureBlock : HungerCoilTextureBlocks):
            if (Index < Floor[Hunger]):
                HungerCoilTextureBlock.SetImage(HungerCoilFull)
            else if (Index >= Ceil[Hunger]):
                HungerCoilTextureBlock.SetImage(VerseAssets.TransparentTexture)
            else if (Hunger > 0.1):
                if (Fraction(Hunger) > 0.5):
                    HungerCoilTextureBlock.SetImage(HungerCoilFull)
                else:
                    HungerCoilTextureBlock.SetImage(HungerCoilHalf)
            else:
                HungerCoilTextureBlock.SetImage(VerseAssets.TransparentTexture)

ui_hotbar_slot_wrapper := class():
    ##### CONSTRUCT #####
    block{}

    ##### INITIALIZE #####
    var Position<private> : vector2 = vector2{}
    var RefCanvas<private> : canvas = canvas{}

    ##### VARIABLES #####
    HotBarTextureBlock : texture_block = texture_block:
        DefaultImage := Assets.UI.T_ItemSlot 
        DefaultDesiredSize := vector2{X:= HOT_BAR_SLOT_SIZE, Y:= HOT_BAR_SLOT_SIZE}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    # HightlightTextureBlock : texture_block = texture_block:
    #     DefaultImage := Assets.UI.Inventory.HightlightTexture 
    #     DefaultDesiredSize := vector2{X:= 92.0, Y:= 92.0}
    #     DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
    RarityTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.TransparentTexture 
        DefaultDesiredSize := vector2{X:= HOT_BAR_SLOT_SIZE * BORDER_TO_CONTENT_ITEM_SLOT_FACTOR, Y:= HOT_BAR_SLOT_SIZE * BORDER_TO_CONTENT_ITEM_SLOT_FACTOR}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    ItemTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.TransparentTexture 
        DefaultDesiredSize := vector2{X:= 65.0, Y:= 65.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        
    CountTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=2.0, Y:=2.0}
        DefaultShadowOpacity := 1.0
        DefaultShadowColor := NamedColors.Black


    Anchor : anchors = anchors{Minimum := vector2{X := 0.500000, Y := 0.950000}, Maximum := vector2{X := 0.500000, Y := 0.950000}}


    var Initialized : logic = false
    Initiate<public>(InPosition : vector2, InCanvas : canvas) : void =
        if (Initialized?). Assert("Hotbar Slot UI is already initialized")
        set Initialized = true

        set Position = InPosition
        set RefCanvas = InCanvas


        CountTextBlock.SetText(StringToMessage(""))

        Height := -10.0

        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y + Height, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 200
                Widget := HotBarTextureBlock
        )

        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X - 1.0, Top := Position.Y - 1.0 + Height, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 201
                Widget := RarityTextureBlock
        )

        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y + Height, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 202
                Widget := ItemTextureBlock
        )
        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X - 28.0, Top := Position.Y - 22.0 + Height, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.0, Y:=0.5}
                SizeToContent := true
                ZOrder := 202
                Widget := CountTextBlock
        )
        HotBarTextureBlock.SetVisibility(widget_visibility.Visible)
        ItemTextureBlock.SetVisibility(widget_visibility.Visible)
        CountTextBlock.SetVisibility(widget_visibility.Visible)
        RarityTextureBlock.SetVisibility(widget_visibility.Visible)
        # HightlightTextureBlock.SetVisibility(widget_visibility.Hidden)
        set IsVisible = true

    Update<public>(InItemSlot : item_slot_wrapper) : void = 
        if (Item := InItemSlot.GetItem[], Count := Item.GetQuantity()):
            ItemTextureBlock.SetImage(Item.GetTexture())
            RarityTextureBlock.SetImage(Item.GetRarityTexture())
            CountTextBlock.SetText(IntToMessage(Count))
            # ItemTextureBlock.SetVisibility(widget_visibility.Visible)
        else:
            RarityTextureBlock.SetImage(VerseAssets.TransparentTexture)
            ItemTextureBlock.SetImage(VerseAssets.TransparentTexture)
            CountTextBlock.SetText(StringToMessage(""))
            # ItemTextureBlock.SetVisibility(widget_visibility.Hidden)
    
    MakeActive<public>() : void =
        HotBarTextureBlock.SetImage(Assets.UI.T_ItemSlot2)
        # HightlightTextureBlock.SetVisibility(widget_visibility.Visible)
            
    MakeInactive<public>() : void = 
        HotBarTextureBlock.SetImage(Assets.UI.T_ItemSlot)

        # HightlightTextureBlock.SetVisibility(widget_visibility.Hidden)

    var IsVisible : logic = true
    Hide<public>() : void =
        if (not IsVisible?). return
        HotBarTextureBlock.SetVisibility(widget_visibility.Hidden)
        ItemTextureBlock.SetVisibility(widget_visibility.Hidden)
        CountTextBlock.SetVisibility(widget_visibility.Hidden)
        RarityTextureBlock.SetVisibility(widget_visibility.Hidden)
        

        # HightlightTextureBlock.SetVisibility(widget_visibility.Hidden)
        set IsVisible = false

    Show<public>() : void =
        if (IsVisible?). return
        HotBarTextureBlock.SetVisibility(widget_visibility.Visible)
        ItemTextureBlock.SetVisibility(widget_visibility.Visible)
        CountTextBlock.SetVisibility(widget_visibility.Visible)
        RarityTextureBlock.SetVisibility(widget_visibility.Visible)
        
        # HightlightTextureBlock.SetVisibility(widget_visibility.Hidden)
        set IsVisible = true


ui_item_slot_wrapper := class():
    ##### CONSTRUCT #####
    var RefGameManager<private> : game_manager_device = game_manager_device{}

    ##### INITIALIZE #####
    var Position<private> : vector2 = vector2{}
    var SlotSize : float = 0.0
    var ContainerSize : float = 0.0
    var RefCanvas<private> : canvas = canvas{}

    ##### VARIABLES #####
    ItemSlotTextureBlock : texture_block = texture_block:
        DefaultImage := Assets.UI.T_ItemSlot
        DefaultDesiredSize := vector2{X:= 0.0, Y:= 0.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    RarityTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.TransparentTexture
        DefaultDesiredSize := vector2{X:= 0.0, Y:= 0.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    ItemTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.TransparentTexture 
        DefaultDesiredSize := vector2{X:= 0.0, Y:= 0.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}
        
    CountTextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=2.0, Y:=2.0}
        DefaultShadowOpacity := 1.0
        DefaultShadowColor := NamedColors.Black
    
    Button : button_quiet = button_quiet{}
    
    Anchor : anchors = anchors{Minimum := vector2{X := 0.500000, Y := 0.500000}, Maximum := vector2{X := 0.500000, Y := 0.500000}}
    
    var Initialized : logic = false
    Initiate(InPosition : vector2, InSlotSize : float, InContainerSize : float, InCanvas : canvas, InGameManager : game_manager_device) : void =
        if (Initialized?). Assert("Item Slot UI is already initialized")
        set Initialized = true
        
        set Position = InPosition
        set SlotSize = InSlotSize
        set ContainerSize = InContainerSize
        set RefCanvas = InCanvas
        set RefGameManager = InGameManager

        # HighlightTextureBlock.SetDesiredSize(vector2{X:=InContainerSize, Y:=InContainerSize})
        ItemTextureBlock.SetDesiredSize(vector2{X:=InContainerSize, Y:=InContainerSize})
        ItemSlotTextureBlock.SetDesiredSize(vector2{X:=InSlotSize, Y:=InSlotSize})
        Button.SetText(StringToMessage(""))
        CountTextBlock.SetText(IntToMessage(0))

        # Button.OnClick().Subscribe(OnClick)

        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y, Right := SlotSize, Bottom := SlotSize}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 201
                Widget := ItemSlotTextureBlock
        )
        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X - 1.0, Top := Position.Y - 1.0, Right := SlotSize*0.9, Bottom := SlotSize*0.9}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 202
                Widget := RarityTextureBlock
        )

        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y, Right := ContainerSize, Bottom := ContainerSize}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 203
                Widget := ItemTextureBlock
        )
        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor # +ContainerSize/2.0
                Offsets := margin{Left := Position.X - ContainerSize/2.0 + ContainerSize*0.1, Top := Position.Y - ContainerSize/2.0 + ContainerSize*0.1, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 204
                Widget := CountTextBlock
        )
        RefCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y, Right := ContainerSize, Bottom := ContainerSize}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := false
                ZOrder := 205
                Widget := Button
        )
        Close()


        
    var IsOpen : logic = false
    Open(InItemSlot : item_slot_wrapper) : void = 
        if (not Initialized?):
            Assert("Item Slot UI was not initialized")
        if (IsOpen?):
            return
        set IsOpen = true

        ItemSlotTextureBlock.SetVisibility(widget_visibility.Visible)
        Button.SetVisibility(widget_visibility.Visible)

        if:
            Item := InItemSlot.GetItem[]
            Quantity := InItemSlot.GetQuantity[]
        then:
            ItemTextureBlock.SetImage(Item.GetTexture())
            if (Quantity <> 0):
                CountTextBlock.SetText(IntToMessage(Quantity))
            else:
                Assert("THIS COULD NEVER HAPPEN. THIS ERROR IS BASICALLY IMPOSSILBE")
                CountTextBlock.SetText(StringToMessage(""))

            CountTextBlock.SetVisibility(widget_visibility.Visible)
            ItemTextureBlock.SetVisibility(widget_visibility.Visible)
            
    
    var Highlighted : logic = false

    Highlight<public>() : void =
        ItemSlotTextureBlock.SetImage(Assets.UI.T_ItemSlot2)
        set Highlighted = true


    Unhighlight<public>() : void =
        ItemSlotTextureBlock.SetImage(Assets.UI.T_ItemSlot)
        # if (not Highlighted?):
        #     PrintError("Wrong ItemSlot")
        set Highlighted = false

    #     Print("Unhighlight")
    #     ItemSlotTextureBlock.SetImage(Assets.UI.T_ItemSlot)
        # RefCanvas.RemoveWidget(ItemSlotTextureBlock)
        # RefCanvas.AddWidget(
        #     canvas_slot:
        #         Anchors := Anchor
        #         Offsets := margin{Left := Position.X, Top := Position.Y, Right := SlotSize, Bottom := SlotSize}
        #         Alignment := vector2{X:=0.5, Y:=0.5}
        #         SizeToContent := true
        #         ZOrder := 201
        #         Widget := ItemSlotTextureBlock
        # )
        # ItemSlotTextureBlock.SetVisibility(widget_visibility.Visible)


    Update(InItemSlot : item_slot_wrapper) : void = 
        if:
            Item := InItemSlot.GetItem[]
            Quantity := InItemSlot.GetQuantity[]
        then:
            RarityTextureBlock.SetImage(Item.GetRarityTexture())
            ItemTextureBlock.SetImage(Item.GetTexture())
            CountTextBlock.SetText(IntToMessage(Quantity))

            ItemSlotTextureBlock.SetVisibility(widget_visibility.Visible)
            ItemTextureBlock.SetVisibility(widget_visibility.Visible)
            CountTextBlock.SetVisibility(widget_visibility.Visible)
            RarityTextureBlock.SetVisibility(widget_visibility.Visible)


            # RefCanvas.RemoveWidget(ItemTextureBlock)
            # RefCanvas.AddWidget(
            #     canvas_slot:
            #         Anchors := Anchor
            #         Offsets := margin{Left := Position.X, Top := Position.Y, Right := ContainerSize, Bottom := ContainerSize}
            #         Alignment := vector2{X:=0.5, Y:=0.5}
            #         SizeToContent := true
            #         ZOrder := 2147483642
            #         Widget := ItemTextureBlock
            # )
            # ItemTextureBlock.SetVisibility(widget_visibility.Visible)
        else:
            RarityTextureBlock.SetImage(VerseAssets.TransparentTexture)
            ItemTextureBlock.SetImage(VerseAssets.TransparentTexture)

            ItemSlotTextureBlock.SetVisibility(widget_visibility.Visible)
            ItemTextureBlock.SetVisibility(widget_visibility.Visible)
            RarityTextureBlock.SetVisibility(widget_visibility.Visible)
            CountTextBlock.SetText(StringToMessage(""))


    Close() : void =
        Button.SetText(StringToMessage(""))
        CountTextBlock.SetVisibility(widget_visibility.Hidden)
        Button.SetVisibility(widget_visibility.Hidden)
        ItemTextureBlock.SetVisibility(widget_visibility.Hidden)
        ItemSlotTextureBlock.SetVisibility(widget_visibility.Hidden)
        RarityTextureBlock.SetVisibility(widget_visibility.Hidden)
        set IsOpen = false







            


ui_inventory_wrapper := class():
    ##### CONSTRUCT ##### 
    var RefGameManager<private> : game_manager_device = game_manager_device{}
    Canvas<private> : canvas = canvas{}

    ##### INITIALIZE ##### 

    ##### VARIABLES ##### 

    ##### FUNCTIONS #####
    GetCanvas()<transacts> : canvas = Canvas

    ##### UI #####
    Anchor : anchors = anchors{Minimum := vector2{X := 0.5, Y := 0.5}, Maximum := vector2{X := 0.5, Y := 0.5}}
    CloseButton : button_loud = button_loud{}
    InventoryTextureBlock : texture_block = texture_block:
        DefaultImage := Assets.UI.Inventory.T_Inventory
        DefaultDesiredSize := vector2{X:= 1920.0, Y:= 1080.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    var Initialized : logic = false
    Initiate(InGameManager : game_manager_device) : void =
        if (Initialized?). Assert("Inventory is already initialized")
        set Initialized = true

        set RefGameManager = InGameManager
        CloseButton.SetText(StringToMessage("CLOSE"))

        Canvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := 0.0, Top := 0.0, Right := 0.0, Bottom := 0.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 200
                Widget := InventoryTextureBlock
        )
        Canvas.AddWidget(
            canvas_slot: 
                Anchors := Anchor
                Offsets := margin{Left := 0.0, Top := 464.0, Right := 171.0, Bottom  := 81.0}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := true
                ZOrder := 201
                Widget := CloseButton
        )

    var IsOpen : logic = false
    Open(Player : player) : void = 
        if (not Initialized?). Assert("Inventory UI was not initialized")
        if (IsOpen?). return
        set IsOpen = true
        InventoryTextureBlock.SetVisibility(widget_visibility.Visible)
        CloseButton.SetVisibility(widget_visibility.Visible)
        
        if (PlayerUI := GetPlayerUI[Player]):
            PlayerUI.AddWidget(Canvas, player_ui_slot{ InputMode := ui_input_mode.All, ZOrder := 200 })
        else:
            PrintError("Could not retrieve Player UI")

    Update() : void =
        block:

    Close(Player : player) : void =
        set IsOpen = false
        if (PlayerUI := GetPlayerUI[Player]):
            PlayerUI.RemoveWidget(Canvas)
        else:
            PrintError("Could not retrieve Player UI")












fixed_ressource_popup_wrapper := class():
    var Canvas : canvas = canvas{}
    var Position : vector2 = vector2{}
    PopupLength : float = RESOURCE_POPUP_DURATION
    Anchor : anchors = anchors{Minimum := vector2{X := 0.535, Y := 0.500000}, Maximum := vector2{X := 0.535, Y := 0.500000}}
    HasBackground : logic = true

    var CurrentAmount : int = 0
    var CurrentTimer : float = 0.0
    ZOrder : type {_X:int where 0 <= _X, _X <= 2147483647} = 335

    var RessourceTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.Icons.IconStone
        DefaultDesiredSize := vector2{X:= 55.0, Y:= 55.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}

    var TextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=2.0, Y:=2.0}
        DefaultShadowOpacity := 1.0
        DefaultShadowColor := NamedColors.Black

    var StackBox : stack_box = stack_box{Orientation := orientation.Horizontal}

    var BackgroundTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.Icons.IconBackgroundRectangle
        DefaultDesiredSize := vector2{X:= 260.0 * 0.8, Y:= 180.0}


    var Initialized : logic = false
    Initiate() : void = 
        set StackBox = CreateStackBox()
        set Initialized = true

    CreateStackBox() : stack_box =
        MyStackBox : stack_box = stack_box:
            Orientation := orientation.Horizontal
            Slots := array:
                stack_box_slot:
                    Widget := RessourceTextureBlock
                    HorizontalAlignment := horizontal_alignment.Fill
                    VerticalAlignment := vertical_alignment.Center
                stack_box_slot:
                    Widget := TextBlock
                    HorizontalAlignment := horizontal_alignment.Fill
                    VerticalAlignment := vertical_alignment.Center
                    
    var IsOpen : logic = false
    Open<private>() : void = 
        if (not Initialized?). Assert("Fixed Resource Popup was not initialized")
        set IsOpen = true

        StackBox.SetVisibility(widget_visibility.Visible)
        RessourceTextureBlock.SetVisibility(widget_visibility.Visible)
        TextBlock.SetVisibility(widget_visibility.Visible)
        BackgroundTextureBlock.SetVisibility(widget_visibility.Visible)
        

        if (HasBackground?):
            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := Position.X - 20.0, Top := Position.Y}
                    Alignment := vector2{X:=0.0, Y:=0.5}
                    SizeToContent := true
                    ZOrder := ZOrder
                    Widget := BackgroundTextureBlock
            )
        Canvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y}
                Alignment := vector2{X:=0.0, Y:=0.5}
                SizeToContent := true
                ZOrder := ZOrder
                Widget := StackBox
        ) 

    Close() : void = 
        # RessourceTextureBlock.SetImage(VerseAssets.MissingTexture) 
        set MaybeLastItemType = false
        set CurrentAmount = 0
        set IsOpen = false
        StackBox.SetVisibility(widget_visibility.Hidden)
        RessourceTextureBlock.SetVisibility(widget_visibility.Hidden)
        TextBlock.SetVisibility(widget_visibility.Hidden)
        BackgroundTextureBlock.SetVisibility(widget_visibility.Hidden)
        Canvas.RemoveWidget(StackBox)
        Canvas.RemoveWidget(BackgroundTextureBlock)
                 
    var MaybeLastItemType : ?item_type = false 
    Popup(ItemType : item_type, Amount : int, ItemTexture : texture) : void =
        if:
            LastItemType := MaybeLastItemType?
            ItemType = LastItemType
        then:
            set CurrentAmount += Amount
        else:
            set CurrentAmount = Amount
            RessourceTextureBlock.SetImage(ItemTexture) 
            
        set MaybeLastItemType = option. ItemType
        set CurrentTimer = PopupLength
        TextBlock.SetText(StringToMessage("+{CurrentAmount}"))
        if (not IsOpen?). Open()














dynamic_ressource_popup_wrapper := class():
    Canvas<private> : canvas = canvas{}
    var Position<private> : vector2 = vector2{}
    var RefPlayer<private> : ?player = false

    var Amount : int = 0
    MaxWidgetOffset : float = 152.0

    var WidgetOffset : float = 0.0
    var WidgetOpacity : float = 1.0

    var RessourceIconSize : float = 55.0
    MinRessourceIconSize : float = 36.0 
    MaxRessourceIconSize : float = 60.0

    Anchor : anchors = anchors{Minimum := vector2{X := 0.535, Y := 0.500000}, Maximum := vector2{X := 0.535, Y := 0.500000}}

    var StackBox : stack_box = stack_box{Orientation := orientation.Horizontal}

    RessourceTextureBlock : texture_block = texture_block:
        DefaultImage := VerseAssets.TransparentTexture
        DefaultDesiredSize := vector2{X:= 55.0, Y:= 55.0}
        DefaultTint := color{R:=1.0, G:=1.0, B:=1.0}


    TextBlock : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultJustification := text_justification.Left
        DefaultOverflowPolicy := text_overflow_policy.Clip
        DefaultShadowOffset := option. vector2{X:=2.0, Y:=2.0}
        DefaultShadowOpacity := 1.0
        DefaultShadowColor := NamedColors.Black


    CreateStackBox() : stack_box =
        MyStackBox : stack_box = stack_box:
            Orientation := orientation.Horizontal
            Slots := array:
                stack_box_slot:
                    Widget := RessourceTextureBlock
                    HorizontalAlignment := horizontal_alignment.Fill
                    VerticalAlignment := vertical_alignment.Center
                stack_box_slot:
                    Widget := TextBlock
                    HorizontalAlignment := horizontal_alignment.Fill
                    VerticalAlignment := vertical_alignment.Center

    var Initialized : logic = false
    Initiate(InPlayer : player, InPosition : vector2) : void = 
        if (Initialized?):
            PrintError("DynamicResourcePopup already initialized")
            return
        set Initialized = true

        set RefPlayer = option. InPlayer
        set Position = InPosition

    SetTextOpacity(InOpacity : float) : void = 
        var TempOpacity : float = InOpacity
        if (TempOpacity > 1.0):
            set TempOpacity = 1.0
        else if (TempOpacity < 0.0):
            set TempOpacity = 0.0
        FinalOpacity := TempOpacity
        if (Opacity := type{_X:float where _X >= 0.000000, _X <= 1.000000}[FinalOpacity]):    
            TextBlock.SetShadowOpacity(Opacity)
            TextBlock.SetTextOpacity(Opacity)


    var IsOpen : logic = false
    Popup(ItemType : item_type, ZOrder : int, InAmount : int, ItemTexture : texture) : void =
        Open(ItemType, ZOrder, InAmount, ItemTexture)
            
    Open(ItemType : item_type, ZOrder : int, InAmount : int, ItemTexture : texture) : void = 
        if (not Initialized?):
            PrintError("DynamicResourcePopup is not initialized")
            return
        if (IsOpen?):
            # PrintError("DynamicPopupWrapper is already open")
            return
        set Amount = InAmount
        set WidgetOffset = 0.0
        set WidgetOpacity = 1.0
        set RessourceIconSize = MaxRessourceIconSize
        set AnimationFinished = false

        set StackBox = CreateStackBox()
        TextBlock.SetText(StringToMessage("+{Amount}"))
        RessourceTextureBlock.SetImage(ItemTexture)

        StackBox.SetVisibility(widget_visibility.Visible)
        RessourceTextureBlock.SetVisibility(widget_visibility.Visible)
        TextBlock.SetVisibility(widget_visibility.Visible)

        # Canvas.AddWidget(
        #     canvas_slot:
        #         Anchors := Anchor
        #         Offsets := margin{Left := Position.X, Top := Position.Y}
        #         Alignment := vector2{X:=0.0, Y:=0.5}
        #         SizeToContent := true
        #         ZOrder := 0
        #         Widget := StackBox
        # ) 
        var ActualZOrder : type{_X:int where 0 <= _X, _X <= 2147483647} = 2
        if (NewZOrder := type{_X:int where 0 <= _X, _X <= 2147483647}[ZOrder]):
            set ActualZOrder = NewZOrder
        if (Player := RefPlayer?, PlayerUI := GetPlayerUI[Player]):
            PlayerUI.AddWidget(Canvas, player_ui_slot{InputMode:=ui_input_mode.None, ZOrder := ActualZOrder})
        else:
            PrintError("Could not retrieve Player UI")

        set IsOpen = true

    Close() : void = 
        StackBox.SetVisibility(widget_visibility.Hidden)
        RessourceTextureBlock.SetVisibility(widget_visibility.Hidden)
        TextBlock.SetVisibility(widget_visibility.Hidden)
        Canvas.RemoveWidget(StackBox)
        if (Player := RefPlayer?, PlayerUI := GetPlayerUI[Player]):
            PlayerUI.RemoveWidget(Canvas)
        else:
            PrintError("Could not retrieve Player UI")
        set IsOpen = false

    Reset() : void = 
        set Amount = 0
        set WidgetOffset = 0.0
        set WidgetOpacity = 1.0
        set RessourceIconSize = MaxRessourceIconSize

        RessourceTextureBlock.SetDesiredSize(vector2{X:=MaxRessourceIconSize, Y:=MaxRessourceIconSize})
        SetTextOpacity(1.0)

        
    var AnimationFinished : logic = false
    Move() : void = 
        if (not IsOpen?):
            return

        Speed : float = 2.0
        Step : float = Speed * MaxWidgetOffset / 100.0
        TotalSteps : float = MaxWidgetOffset / Step
        StepNormalized : float = 1.0 / TotalSteps

        if (not AnimationFinished?):
            set WidgetOffset -= Step
            set WidgetOpacity -= StepNormalized

            if (RessourceIconSize >= MinRessourceIconSize):
                set RessourceIconSize -= StepNormalized * 35.0

            StackBox.SetVisibility(widget_visibility.Hidden)
            Canvas.RemoveWidget(StackBox)
            StackBox.SetVisibility(widget_visibility.Visible)
            
            RessourceTextureBlock.SetDesiredSize(vector2{X:=RessourceIconSize, Y:=RessourceIconSize})
            SetTextOpacity(WidgetOpacity)
            set StackBox = CreateStackBox()

            # MyCanvas : canvas = canvas:
            #     Slots := array:
            #         canvas_slot:
            #             Anchors := Anchor
            #             Offsets := margin{Left := Position.X, Top := Position.Y + WidgetOffset}
            #             Alignment := vector2{X:=0.0, Y:=0.5}
            #             SizeToContent := true
            #             Widget := StackBox
        
            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := Position.X, Top := Position.Y + WidgetOffset}
                    Alignment := vector2{X:=0.0, Y:=0.5}
                    SizeToContent := true
                    Widget := StackBox
            )
            


            # Canvas.AddWidget(
            #     canvas_slot:
            #         Anchors := Anchor
            #         Offsets := margin{Left := Position.X, Top := Position.Y + WidgetOffset}
            #         Alignment := vector2{X:=0.0, Y:=0.5}
            #         SizeToContent := true
            #         Widget := StackBox
            # )
            if (WidgetOffset < -MaxWidgetOffset):
                set AnimationFinished = true
                # Sleep(0.0)
        else:
            Close()
        
    # PopupSuspended()<suspends> : void =
    #     set AnimationFinished = false
    #     Speed : float = 2.0
    #     Step : float = Speed * MaxWidgetOffset / 100.0
    #     TotalSteps : float = MaxWidgetOffset / Step
    #     StepNormalized : float = 1.0 / TotalSteps

    #     loop:
    #         if (AnimationFinished?). break
    #         set WidgetOffset -= Step
    #         set WidgetOpacity -= StepNormalized

    #         if (RessourceIconSize >= MinRessourceIconSize):
    #             set RessourceIconSize -= StepNormalized * 35.0

    #         StackBox.SetVisibility(widget_visibility.Hidden)
    #         Canvas.RemoveWidget(StackBox)
    #         StackBox.SetVisibility(widget_visibility.Visible)
            
    #         RessourceTextureBlock.SetDesiredSize(vector2{X:=RessourceIconSize, Y:=RessourceIconSize})
    #         SetTextOpacity(WidgetOpacity)
    #         set StackBox = CreateStackBox()

    #         Canvas.AddWidget(
    #             canvas_slot:
    #                 Anchors := Anchor
    #                 Offsets := margin{Left := Position.X, Top := Position.Y + WidgetOffset}
    #                 Alignment := vector2{X:=0.0, Y:=0.5}
    #                 SizeToContent := true
    #                 Widget := StackBox
    #         )
    #         if (WidgetOffset < -MaxWidgetOffset):
    #             set AnimationFinished = true
    #             Sleep(0.0)
    #     Close()









ui_manager_device := class(creative_device):
    OnBegin<override>()<suspends>:void=
        block:

    

texture_wrapper := class<unique>():
    TextureBlock<protected> : texture_block = texture_block:
        DefaultImage := VerseAssets.MissingTexture
    
    var Texture : texture

    ZOrder : type{_X:int where 0 <= _X, _X <= 2147483647} = 2
    Anchor : anchors = anchors{Minimum := vector2{X := 0.5, Y := 0.5}, Maximum := vector2{X := 0.5, Y := 0.5}}
    var Id : int = 0

    var Name : string = ""

    var Position<protected> : vector2 = vector2{}

    var Initialized : logic = false


    InitializeAndAddToCanvas<public>(InCanvas : canvas, InPosition : vector2, Size : vector2) : void =
        if (Initialized?). Assert("Texture Wrapper is already initialized, {Name}")
        set Initialized = true

        set Position = InPosition
        TextureBlock.SetImage(Texture)
        InCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y , Right := Size.X, Bottom := Size.Y}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := false
                ZOrder := 60
                Widget := TextureBlock
        )
    
    SetTexture<public>(NewTexture : texture) : void =
        set Texture = NewTexture
        TextureBlock.SetImage(Texture)

    Hide<public>() : void =
        TextureBlock.SetVisibility(widget_visibility.Hidden)
    
    Show<public>() : void =
        TextureBlock.SetVisibility(widget_visibility.Visible)
    
    GetWidgets<public>()<transacts> : []widget =
        return array{TextureBlock}

texture_button := class<unique>(texture_wrapper):
    
    Button : button_quiet = button_quiet{}
    ButtonSize : vector2
    ClickHandlerFunction : type {baka(Player : player, num : int) : void} # what the sigma

    InitializeAndAddToCanvas<override>(InCanvas : canvas, InPosition : vector2, Size : vector2) : void =
        if (Initialized?). Assert("Texture Button is already initialized")
        set Initialized = true

        set Position = InPosition
        TextureBlock.SetImage(Texture)
        InCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y , Right := Size.X, Bottom := Size.Y}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := false
                ZOrder := 61
                Widget := TextureBlock
        )
        InCanvas.AddWidget(
            canvas_slot:
                Anchors := Anchor
                Offsets := margin{Left := Position.X, Top := Position.Y , Right := ButtonSize.X, Bottom := ButtonSize.Y}
                Alignment := vector2{X:=0.5, Y:=0.5}
                SizeToContent := false
                ZOrder := 87
                Widget := Button
        )

        Button.OnClick().Subscribe(ClickHandler)
    
    ClickHandler(WidgetMessage : widget_message) : void =
        ClickHandlerFunction(WidgetMessage.Player, Id)
    
    GetWidgets<override>()<transacts>: []widget =
        return array{TextureBlock, Button}

wrap_box := class():

    StartPosition : vector2
    Size : vector2
    ItemSize : vector2
    Padding : vector2
    FirstItemPadding : vector2
    var TextureWrappers<public> : []texture_wrapper = array{}

    var Initialized : logic = false

    LoadItemsOntoCanvas<public>(InCanvas : canvas) : void =
        var LastTexturePosition : vector2 = FirstItemPadding
        for (TextureWrapper : TextureWrappers):
            TextureWrapper.InitializeAndAddToCanvas(InCanvas, LastTexturePosition+StartPosition, ItemSize)
            set LastTexturePosition.X += ItemSize.X + Padding.X

            if (LastTexturePosition.X + ItemSize.X >= Size.X):
                set LastTexturePosition.X = FirstItemPadding.X
                set LastTexturePosition.Y += Padding.Y + ItemSize.Y
    

    AddWidget<public>(TextureWrapper : texture_wrapper) : void =
        set TextureWrappers += array{TextureWrapper}
        
    ClearWidgets<public>(InCanvas : canvas) : void =
        for(TextureWrapper : TextureWrappers):
            for(Widget : TextureWrapper.GetWidgets()):
                InCanvas.RemoveWidget(Widget)
        set TextureWrappers = array{}



crafting_bench_interface := class():
    RefItemManager : item_manager_device = item_manager_device{}
    Position : vector2 = vector2{}
    CraftItemFunction : type{ CraftItem(Player : player, Recipe : recipe_wrapper) : void }
    GetRecipesFunction : type{ GetRecipes(Player : player) : []recipe_wrapper }
    GetAvailabilityMatrix : type{GetItemAvailabilityMatrix(Player : player, Recipe : recipe_wrapper)<transacts> : []logic}
    AllRecipes : []recipe_wrapper

    var CraftableRecipes<private> : []recipe_wrapper = array{}
    
    var MaybeCurrentSelectedRecipeIndex : ?int = false
    
    var Canvas : canvas = canvas{}
    
    RecipeStartPosition : vector2 = vector2{X:=-446.0, Y:=-185.0}
    RecipeSize : vector2  = vector2{X:=420.0, Y:=450.0}
    RecipeItemSize : vector2  = vector2{X:=40.0, Y:=40.0}
    RecipePadding : vector2  = vector2{X:=40.0, Y:=40.0}
    RecipeFirstItemPadding : vector2  = vector2{X:=8.0, Y:=-1.0} 

    var PossibleRecipesWrapBox : wrap_box = wrap_box:
        StartPosition := vector2{X:=-446.0, Y:=-185.0},
        Size := vector2{X:=420.0, Y:=450.0},
        ItemSize := vector2{X:=40.0, Y:=40.0},
        Padding := vector2{X:=40.0, Y:=40.0},
        FirstItemPadding := vector2{X:=8.0, Y:=-1.0}  
    
    var PossibleRecipesItemWrapperWrapBox : wrap_box = wrap_box:
        StartPosition := vector2{X:=-445.0, Y:=-185.0},
        Size := vector2{X:=420.0, Y:=450.0},
        ItemSize := vector2{X:=60.0, Y:=60.0},
        Padding := vector2{X:=20.0, Y:=20.0},
        FirstItemPadding := vector2{X:=8.0, Y:=-1.0}  
    
    var CurrentRecipeWrapBox : wrap_box = wrap_box:
        StartPosition := vector2{X:= 40.0, Y:=-130.0},
        Size := vector2{X:=230.0, Y:=230.0},
        ItemSize := vector2{X:=60.0, Y:=60.0},
        Padding := vector2{X:=23.0, Y:=23.0},
        FirstItemPadding := vector2{X:=0.0, Y:=0.0}   
    
    var UnsufficientItemWrapperWrapBox : wrap_box = wrap_box:
        StartPosition := vector2{X:=40.0, Y:=-131.0}
        Size := vector2{X:=206.0+74.0, Y:=400.0}
        ItemSize := vector2{X:=74.0, Y:=74.0}
        Padding := vector2{X:=9.0, Y:=9.0}
        FirstItemPadding := vector2{X:=0.0, Y:=0.0}
        

    var CrafingBackgroundUi : texture_block = texture_block:
        DefaultImage := Skyblock.Assets.UI.CraftingTable.T_CraftingTableUI
    
    
    var CraftedItemTextureWrapper : texture_wrapper = texture_wrapper{Texture:=VerseAssets.MissingTexture, ZOrder:=5}

    var CraftBtn : button_loud = button_loud{}
    var CloseBtn : button_loud = button_loud{}
    
    var CraftedItemName : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultShadowOpacity := 0.0
    
    var MaybeRightPageBtnWrapper : ?texture_button = false
    var MaybeLeftPageBtnWrapper : ?texture_button = false

    var PageDisplay : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultShadowOpacity := 0.0

    var ItemsPerPage : int = 0
    var CurPage : int = 1
    var MaxPages : int = 1

    Anchor : anchors = anchors{Minimum := vector2{X := 0.5, Y := 0.5}, Maximum := vector2{X := 0.5, Y := 0.5}}
    

    Initialize<public>() : void =
        

        CraftBtn.SetText(StringToMessage("Craft Item"))
        CloseBtn.SetText(StringToMessage("Close"))
                
        CraftBtn.OnClick().Subscribe(CraftItemWrapper)
        CloseBtn.OnClick().Subscribe(Close)
        CraftedItemTextureWrapper.InitializeAndAddToCanvas(Canvas, vector2{X:=398.0, Y:=-45.0}, vector2{X:=90.0, Y:=90.0})

        if(NewItemsPerPageY := Floor[(RecipeSize.Y-RecipeFirstItemPadding.Y) / (RecipeItemSize.Y + RecipePadding.Y)], NewItemsPerPageX := Floor[(RecipeSize.X-RecipeFirstItemPadding.X) / (RecipeItemSize.X + RecipePadding.X)]):
            set ItemsPerPage = NewItemsPerPageY*NewItemsPerPageX
            # Print("Items per Page: {ItemsPerPage}")
        

        set MaybeRightPageBtnWrapper = option{
            texture_button:
                ButtonSize := vector2{X:=30.0, Y:=30.0},
                Texture:=VerseAssets.TransparentTexture,
                ClickHandlerFunction:=NextPage
        }
        
        set MaybeLeftPageBtnWrapper = option{
            texture_button:
                ButtonSize := vector2{X:=30.0, Y:=30.0},
                Texture:=VerseAssets.TransparentTexture,
                ClickHandlerFunction:=PrevPage
        }

        if(LeftPageBtnWrapper := MaybeLeftPageBtnWrapper?, RightPageBtnWrapper := MaybeRightPageBtnWrapper?):
            LeftPageBtnWrapper.InitializeAndAddToCanvas(Canvas, vector2{X:=-345.0, Y:=195.0}, vector2{X:=30.0, Y:=30.0})
            RightPageBtnWrapper.InitializeAndAddToCanvas(Canvas, vector2{X:=-210.0, Y:=195.0}, vector2{X:=30.0, Y:=30.0})
        
        for(X:= 0..8):
            TxtWrapper := texture_wrapper:
                Texture:=Assets.UI.CraftingTable.ItemSlotRed
            UnsufficientItemWrapperWrapBox.AddWidget(
                TxtWrapper
            )
            TxtWrapper.Hide()

        UnsufficientItemWrapperWrapBox.LoadItemsOntoCanvas(Canvas)

    ChooseRecipe(Player : player, RecipeId: int) : void =
        CurrentRecipeWrapBox.ClearWidgets(Canvas)
        var ItemTexture : texture = VerseAssets.TransparentTexture
        
        if(CurrentRecipe := AllRecipes[RecipeId]):
            if(FlattenedMatrix:=CurrentRecipe.GetRecipeMatrixFlattened[]):
                for(ItemType : FlattenedMatrix):
                    var FoundRecipeForItem : logic = false
                    set ItemTexture = VerseAssets.TransparentTexture
                    if:
                        ItemType <> item_type.None 
                        ItemClass := RefItemManager.GetItemClass[ItemType]
                    then:
                        set ItemTexture = ItemClass.GetTexture()
                    else:
                        set ItemTexture = VerseAssets.TransparentTexture
                    
                    for(BtnId->Recipe : AllRecipes):
                        if(Recipe.GetCraftedItemType() = ItemType):
                            set FoundRecipeForItem = true
                            CurrentRecipeWrapBox.AddWidget(
                                texture_button: 
                                    Id := BtnId
                                    Texture := ItemTexture
                                    ButtonSize := vector2{X:=55.0, Y:=55.0}
                                    ClickHandlerFunction := ChooseRecipe

                            )
                    
                    if(FoundRecipeForItem = false):
                        CurrentRecipeWrapBox.AddWidget(
                                texture_wrapper: 
                                    Texture := ItemTexture
                        )

            CurrentRecipeWrapBox.LoadItemsOntoCanvas(Canvas)
            set ItemTexture = VerseAssets.TransparentTexture
            if:
                ItemClass := RefItemManager.GetItemClass[CurrentRecipe.GetCraftedItemType()]
            then:
                set ItemTexture = ItemClass.GetTexture()
            CraftedItemTextureWrapper.SetTexture(ItemTexture) 
            CraftedItemTextureWrapper.Show()
        
            set MaybeCurrentSelectedRecipeIndex = option{ RecipeId }    
        
            CraftedItemName.SetText(StringToMessage(CurrentRecipe.GetCraftedItemName()))
            
            for(Index->ItemAvailable : GetAvailabilityMatrix(Player, CurrentRecipe)):
                if(TxtWrapper := UnsufficientItemWrapperWrapBox.TextureWrappers[Index]):
                    if(ItemAvailable = false):
                        TxtWrapper.Show()
                    else:
                        TxtWrapper.Hide()
            
            if(not CraftableRecipes.Find[CurrentRecipe]):
                CraftBtn.SetEnabled(false)
            else:
                CraftBtn.SetEnabled(true)

    ClearCurrentRecipe() : void =
        CurrentRecipeWrapBox.ClearWidgets(Canvas)
        CraftedItemTextureWrapper.Hide()
        set MaybeCurrentSelectedRecipeIndex = false

    CraftItemWrapper<private>(WidgetMessage : widget_message) : void =
        if(CurrentSelectedRecipeIndex:=MaybeCurrentSelectedRecipeIndex?, CraftedRecipe := AllRecipes[CurrentSelectedRecipeIndex]):
            CraftItemFunction(WidgetMessage.Player, CraftedRecipe)
        # ClearCurrentRecipe()
        RefreshRecipes(WidgetMessage.Player)
        
    
    NextPage(Player : player, __ : int) : void=
        set CurPage = Min(CurPage+1, MaxPages)
        RefreshRecipes(Player)

    PrevPage(Player : player, __ : int) : void=
        set CurPage  = Max(CurPage-1, 1)
        RefreshRecipes(Player)

    RefreshRecipes(Player : player) : void =

        PossibleRecipesWrapBox.ClearWidgets(Canvas)
        PossibleRecipesItemWrapperWrapBox.ClearWidgets(Canvas)
        set CraftableRecipes = GetRecipesFunction(Player)
        # Print("Craftable recipe length: {CraftableRecipes.Length}")
        if(CraftableRecipesPage := CraftableRecipes.Slice[ItemsPerPage*(CurPage-1), Min(ItemsPerPage*CurPage, CraftableRecipes.Length)]):

            for(CraftableRecipe : CraftableRecipesPage):

                
                var ItemTexture : texture = VerseAssets.TransparentTexture
                if:
                    ItemClass := RefItemManager.GetItemClass[CraftableRecipe.GetCraftedItemType()]
                then:
                    set ItemTexture = ItemClass.GetTexture()
                # else:
                #     Print("Could not find Item Class")
                if:
                    TextureButtonId := AllRecipes.Find[CraftableRecipe]
                then:
                    TextureButton := texture_button:
                        Id:=TextureButtonId
                        Texture := ItemTexture
                        ClickHandlerFunction := ChooseRecipe
                        ButtonSize := vector2{X:=55.0, Y:=55.0}

                    PossibleRecipesWrapBox.AddWidget(TextureButton)
                    PossibleRecipesItemWrapperWrapBox.AddWidget(
                        texture_wrapper {Texture := DefaultImage:=Assets.UI.CraftingTable.T_ItemWrapper}
                    )

        
        

        PossibleRecipesWrapBox.LoadItemsOntoCanvas(Canvas)
        PossibleRecipesItemWrapperWrapBox.LoadItemsOntoCanvas(Canvas)
        
        if(NewMaxPerPages := CraftableRecipes.Length / ItemsPerPage):
           set MaxPages = Max(Ceil(NewMaxPerPages), 1)
            PageDisplay.SetText(StringToMessage("{CurPage}/{MaxPages}"))


    Open(Agent : agent) : void = 
        ClearCurrentRecipe()
        if(Player := player[Agent]):
            RefreshRecipes(Player)
            CraftedItemTextureWrapper.Hide()

            for(TxtWrapper : UnsufficientItemWrapperWrapBox.TextureWrappers):
                TxtWrapper.Hide()

            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := 0.0, Top := 0.0 , Right := 1920.0, Bottom := 1080.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 2
                    Widget := CrafingBackgroundUi
            )

            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := 235.0, Top := 120.0, Right := 440.0, Bottom := 45.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 3
                    Widget := CraftBtn
            )

            Canvas.AddWidget(
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 0.0, Top := 464.0, Right := 171.0, Bottom  := 81.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := CloseBtn
            )
            
            Canvas.AddWidget(
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 230.0, Top := -225.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := CraftedItemName
            )

            Canvas.AddWidget(
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := -275.0, Top := 195.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 201
                    Widget := PageDisplay
            )
            if (PlayerUI := GetPlayerUI[Player]):
                PlayerUI.AddWidget(Canvas, player_ui_slot{ InputMode := ui_input_mode.All, ZOrder := 200 })
            else:
                PrintError("Could not retrieve Player UI")


    Close(WidgetMessage : widget_message) : void = 
        if (PlayerUI := GetPlayerUI[WidgetMessage.Player]):
            PlayerUI.RemoveWidget(Canvas)
        else:
            PrintError("Could not retrieve Player UI")

        


furnace_interface := class():
    RefItemManager : item_manager_device 
    Position : vector2 = vector2{}
    CookItemFunction : type{ CraftItem(Player : player, Recipe : furnace_recipe_wrapper)<suspends> : void }
    CollectItemFunction : type{ CraftItem(Player : player, Recipe : furnace_recipe_wrapper) : void }
    GetRecipesFunction : type{ GetRecipes(Player : player) : []furnace_recipe_wrapper }
    TimeToCook : float

    var CraftableRecipes<private> : []furnace_recipe_wrapper = array{}
    var MaybeCurrentSelectedRecipe : ?furnace_recipe_wrapper = false
    
    var Canvas : canvas = canvas{}

    var PossibleRecipesWrapBox : wrap_box = wrap_box:
        StartPosition := vector2{X:=-470.0, Y:=-125.0},
        Size := vector2{X:=750.0, Y:=385.0},
        ItemSize := vector2{X:=40.0, Y:=40.0},
        Padding := vector2{X:=40.0, Y:=40.0},
        FirstItemPadding := vector2{X:=0.0, Y:=0.0}  
    
    var PossibleRecipesItemWrapperWrapBox : wrap_box = wrap_box:
        StartPosition := vector2{X:=-470.0, Y:=-125.0},
        Size := vector2{X:=750.0, Y:=385.0},
        ItemSize := vector2{X:=60.0, Y:=60.0},
        Padding := vector2{X:=20.0, Y:=20.0},
        FirstItemPadding := vector2{X:=0.0, Y:=0.0}  

    var CrafingBackgroundUi : texture_block = texture_block:
        DefaultImage := Skyblock.Assets.UI.Furnace.T_Furnace
    
    
    var CookedItemTextureWrapper : texture_wrapper = texture_wrapper{Texture:=VerseAssets.MissingTexture, ZOrder:=5}
    var InputItemTextureWrapper : texture_wrapper = texture_wrapper{Texture:=VerseAssets.MissingTexture, ZOrder:=5}

    var CookBtn : button_loud = button_loud{}
    var TakeBtn : button_loud = button_loud{}
    var CloseBtn : button_loud = button_loud{}
    
    var CookedItemName : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultShadowOpacity := 0.0
    
    var ArrowFill : color_block = color_block{
        DefaultColor:=color{R:=58.0, G:=97.0, B:=161.0}
    }

    var ArrowLoadingBar : color_block = color_block{
        DefaultColor:=NamedColors.White
    }


    Anchor : anchors = anchors{Minimum := vector2{X := 0.5, Y := 0.5}, Maximum := vector2{X := 0.5, Y := 0.5}}
    
    var CurrentlyCooking : logic = false

    Initialize() : void = 
        

        CookBtn.SetText(StringToMessage("Burn"))
        TakeBtn.SetText(StringToMessage("Collect"))
        CloseBtn.SetText(StringToMessage("Close"))
                
        CookBtn.OnClick().Subscribe(CookItemWrapper)
        TakeBtn.OnClick().Subscribe(CollectItemWrapper)
        CloseBtn.OnClick().Subscribe(Close)
        CookedItemTextureWrapper.InitializeAndAddToCanvas(Canvas, vector2{X:=461.0, Y:=-42.0}, vector2{X:=60.0, Y:=60.0})
        InputItemTextureWrapper.InitializeAndAddToCanvas(Canvas, vector2{X:=327.0, Y:=-42.0}, vector2{X:=60.0, Y:=60.0})

        ArrowLoadingBar.SetDesiredSize(vector2{X:=45.0, Y:=30.0})

    ChooseRecipe(Player : player, RecipeId: int) : void =
        if(CurrentlyCooking = true): 
            return
        if(CurrentRecipe := CraftableRecipes[RecipeId], CookedItemType:=CurrentRecipe.GetCookedItemType(), InputItemType:=CurrentRecipe.GetNeededItemType()):
    
            var CookedItemTexture : texture = VerseAssets.TransparentTexture
            var InputItemTexture : texture = VerseAssets.TransparentTexture
            if:
                CookedItemClass := RefItemManager.GetItemClass[CookedItemType]
                InputItemClass := RefItemManager.GetItemClass[InputItemType]
            then:
                set CookedItemTexture = CookedItemClass.GetTexture()
                set InputItemTexture = InputItemClass.GetTexture()

                CookedItemTextureWrapper.SetTexture(CookedItemTexture) 
                InputItemTextureWrapper.SetTexture(InputItemTexture) 

            CookedItemTextureWrapper.Show()
            InputItemTextureWrapper.Show()
        
            set MaybeCurrentSelectedRecipe = option{ CurrentRecipe }    
        
            CookedItemName.SetText(StringToMessage(CurrentRecipe.GetCookedItemName()))

    ClearCurrentRecipe() : void =
        CookedItemTextureWrapper.Hide()
        InputItemTextureWrapper.Hide()
        set MaybeCurrentSelectedRecipe = false
    
    CookItemWrapper(WidgetMessage : widget_message) : void =
        spawn . CookItemSuspends(WidgetMessage)

    CookItemSuspends<private>(WidgetMessage : widget_message)<suspends> : void =
        if(CurrentSelectedRecipe:=MaybeCurrentSelectedRecipe?):

            CookBtn.SetEnabled(false)
            TakeBtn.SetEnabled(false)

            set CurrentlyCooking = true

            CookItemFunction(WidgetMessage.Player, CurrentSelectedRecipe)
            RefreshRecipes(WidgetMessage.Player)
            
            LoadingBarUpdateRate := 0.1
            LoadingBarFinalWidth := ArrowLoadingBar.GetDesiredSize().X
            WidthIncreasePerUpdate := LoadingBarFinalWidth / (TimeToCook / LoadingBarUpdateRate)

            ArrowLoadingBar.SetVisibility(widget_visibility.Visible)
            ArrowLoadingBar.SetDesiredSize(vector2{X:=0.0, Y:=ArrowLoadingBar.GetDesiredSize().Y})

            for(X:= 0..Ceil[TimeToCook / LoadingBarUpdateRate]):
                ArrowLoadingBar.SetDesiredSize(vector2{X:=ArrowLoadingBar.GetDesiredSize().X + WidthIncreasePerUpdate, Y:=ArrowLoadingBar.GetDesiredSize().Y})
                Sleep(LoadingBarUpdateRate)
                

            TakeBtn.SetEnabled(true)

        

    CollectItemWrapper<private>(WidgetMessage : widget_message) : void =
        if(CurrentSelectedRecipe:=MaybeCurrentSelectedRecipe?):
            CollectItemFunction(WidgetMessage.Player, CurrentSelectedRecipe)
            CookBtn.SetEnabled(true)
            set CurrentlyCooking = false
            ArrowLoadingBar.SetVisibility(widget_visibility.Hidden)
        RefreshRecipes(WidgetMessage.Player)

    RefreshRecipes(Player : player) : void =

        PossibleRecipesWrapBox.ClearWidgets(Canvas)
        PossibleRecipesItemWrapperWrapBox.ClearWidgets(Canvas)
        set CraftableRecipes = GetRecipesFunction(Player)
        var TextureButtonId : int = 0
        # Print("Craftable recipe length: {CraftableRecipes.Length}")

        for(CraftableRecipe : CraftableRecipes):

            
            var ItemTexture : texture = VerseAssets.TransparentTexture
            if:
                ItemClass := RefItemManager.GetItemClass[CraftableRecipe.GetCookedItemType()]
            then:
                # Print("Could get item texture")
                set ItemTexture = ItemClass.GetTexture()

            TextureButton := texture_button:
                Id:=TextureButtonId
                Texture := ItemTexture
                ClickHandlerFunction := ChooseRecipe
                ButtonSize := vector2{X:=55.0, Y:=55.0}

            PossibleRecipesWrapBox.AddWidget(TextureButton)
            PossibleRecipesItemWrapperWrapBox.AddWidget(
                texture_wrapper {Texture := DefaultImage:=Assets.UI.CraftingTable.T_ItemWrapper}
            )

            set TextureButtonId += 1
        
        

        PossibleRecipesWrapBox.LoadItemsOntoCanvas(Canvas)
        PossibleRecipesItemWrapperWrapBox.LoadItemsOntoCanvas(Canvas)



    Open(Agent : agent) : void = 
        
        if(Player := player[Agent]):
            if(CurrentlyCooking = false):
                ClearCurrentRecipe()
                RefreshRecipes(Player)
                CookedItemTextureWrapper.Hide()
                InputItemTextureWrapper.Hide()
                ArrowLoadingBar.SetVisibility(widget_visibility.Hidden)

            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := 0.0, Top := 0.0 , Right := 1920.0, Bottom := 1080.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 2
                    Widget := CrafingBackgroundUi
            )

            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := 394.0, Top := 55.0, Right := 222.0, Bottom := 45.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 3
                    Widget := CookBtn
            )

            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := 394.0, Top := 125.0, Right := 222.0, Bottom := 45.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 3
                    Widget := TakeBtn
            )

            Canvas.AddWidget(
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 0.0, Top := 464.0, Right := 171.0, Bottom  := 81.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 2147483640
                    Widget := CloseBtn
            )
            
            Canvas.AddWidget(
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 390.0, Top := -160.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 2147483640
                    Widget := CookedItemName
            )

            Canvas.AddWidget(
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 395.0, Top := -40.0, Right := 45.0, Bottom  := 30.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 15
                    Widget := ArrowFill
            )

            Canvas.AddWidget(
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 375.0, Top := -56.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.0, Y:=0.0}
                    SizeToContent := true
                    ZOrder := 2147483641
                    Widget := ArrowLoadingBar
            )

            if (PlayerUI := GetPlayerUI[Player]):
                PlayerUI.AddWidget(Canvas, player_ui_slot{ InputMode := ui_input_mode.All, ZOrder := 200 })
            else:
                PrintError("Could not retrieve Player UI")


    Close(WidgetMessage : widget_message) : void = 
        if (PlayerUI := GetPlayerUI[WidgetMessage.Player]):
            PlayerUI.RemoveWidget(Canvas)
        else:
            PrintError("Could not retrieve Player UI")





villager_interface := class():
    RefItemManager : item_manager_device 
    Position : vector2 = vector2{}
    BuyItemFunction : type{ CraftItem(Player : player, Recipe : villager_recipe_wrapper) : void }
    GetRecipesFunction : type{ GetRecipes(Player : player) : []villager_recipe_wrapper }
    CanAffordRecipe : type{ Bakadillow(Player : player, Recipe : villager_recipe_wrapper )<transacts> : logic}

    var CraftableRecipes<private> : []villager_recipe_wrapper = array{}
    var MaybeCurrentSelectedRecipe : ?villager_recipe_wrapper = false
    
    var Canvas : canvas = canvas{}

    var PossibleRecipesWrapBox : wrap_box = wrap_box:
        StartPosition := vector2{X:=-470.0, Y:=-125.0},
        Size := vector2{X:=750.0, Y:=385.0},
        ItemSize := vector2{X:=40.0, Y:=40.0},
        Padding := vector2{X:=40.0, Y:=40.0},
        FirstItemPadding := vector2{X:=0.0, Y:=0.0}  
    
    var PossibleRecipesItemWrapperWrapBox : wrap_box = wrap_box:
        StartPosition := vector2{X:=-470.0, Y:=-125.0},
        Size := vector2{X:=750.0, Y:=385.0},
        ItemSize := vector2{X:=60.0, Y:=60.0},
        Padding := vector2{X:=20.0, Y:=20.0},
        FirstItemPadding := vector2{X:=0.0, Y:=0.0}  

    var CrafingBackgroundUi : texture_block = texture_block:
        DefaultImage := Skyblock.Assets.UI.Furnace.T_Furnace
    
    
    var CookedItemTextureWrapper : texture_wrapper = texture_wrapper{Texture:=VerseAssets.MissingTexture, ZOrder:=5}
    var InputItemTextureWrapper : texture_wrapper = texture_wrapper{Texture:=VerseAssets.MissingTexture, ZOrder:=5}

    var CookBtn : button_loud = button_loud{}
    var CloseBtn : button_loud = button_loud{}
    
    var CookedItemName : text_block = text_block:
        DefaultTextColor := NamedColors.White
        DefaultTextOpacity := 1.0
        DefaultShadowOpacity := 0.0


    Anchor : anchors = anchors{Minimum := vector2{X := 0.5, Y := 0.5}, Maximum := vector2{X := 0.5, Y := 0.5}}
    
    var CurrentlyCooking : logic = false

    Initialize() : void = 
        

        CookBtn.SetText(StringToMessage("Buy"))
        CloseBtn.SetText(StringToMessage("Close"))
                
        CookBtn.OnClick().Subscribe(CookItemWrapper)
        CloseBtn.OnClick().Subscribe(Close)
        CookedItemTextureWrapper.InitializeAndAddToCanvas(Canvas, vector2{X:=461.0, Y:=-42.0}, vector2{X:=60.0, Y:=60.0})
        InputItemTextureWrapper.InitializeAndAddToCanvas(Canvas, vector2{X:=327.0, Y:=-42.0}, vector2{X:=60.0, Y:=60.0})


    ChooseRecipe(Player : player, RecipeId: int) : void =
        if(CurrentlyCooking = true): 
            return

        

        if (CurrentRecipe := CraftableRecipes[RecipeId], CookedItemType:=CurrentRecipe.BoughtItemType, InputItemType:=CurrentRecipe.NeededItemType):
            var CookedItemTexture : texture = VerseAssets.TransparentTexture
            var InputItemTexture : texture = VerseAssets.TransparentTexture
            if:
                CookedItemClass := RefItemManager.GetItemClass[CookedItemType]
                InputItemClass := RefItemManager.GetItemClass[InputItemType]
            then:
                set CookedItemTexture = CookedItemClass.GetTexture()
                set InputItemTexture = InputItemClass.GetTexture()

                CookedItemTextureWrapper.SetTexture(CookedItemTexture) 
                InputItemTextureWrapper.SetTexture(InputItemTexture) 
            else:
                Print("Could not get Item Class lol??")

            CookedItemTextureWrapper.Show()
            InputItemTextureWrapper.Show()
        
            set MaybeCurrentSelectedRecipe = option{ CurrentRecipe }    
            CookedItemName.SetText(StringToMessage(RefItemManager.GetItemName(CurrentRecipe.BoughtItemType)))
            
            if(CanAffordRecipe(Player, CurrentRecipe) = true):
                CookBtn.SetEnabled(true)
            else:
                CookBtn.SetEnabled(false)

    ClearCurrentRecipe() : void =
        CookedItemTextureWrapper.Hide()
        InputItemTextureWrapper.Hide()
        set MaybeCurrentSelectedRecipe = false
    
    CookItemWrapper(WidgetMessage : widget_message) : void =
        # spawn . CookItemSuspends(WidgetMessage)
        
        if(CurrentSelectedRecipe := MaybeCurrentSelectedRecipe?):
            BuyItemFunction(WidgetMessage.Player, CurrentSelectedRecipe)

            if(CanAffordRecipe(WidgetMessage.Player, CurrentSelectedRecipe) = true):
                CookBtn.SetEnabled(true)
            else:
                CookBtn.SetEnabled(false)
        
    RefreshRecipes(Player : player) : void =

        PossibleRecipesWrapBox.ClearWidgets(Canvas)
        PossibleRecipesItemWrapperWrapBox.ClearWidgets(Canvas)
        set CraftableRecipes = GetRecipesFunction(Player)
        var TextureButtonId : int = 0
        # Print("Craftable recipe length: {CraftableRecipes.Length}")

        for(CraftableRecipe : CraftableRecipes):

            
            var ItemTexture : texture = VerseAssets.TransparentTexture
            if:
                ItemClass := RefItemManager.GetItemClass[CraftableRecipe.BoughtItemType]
            then:
                # Print("Could get item texture")
                set ItemTexture = ItemClass.GetTexture()

            TextureButton := texture_button:
                Id:=TextureButtonId
                Texture := ItemTexture
                ClickHandlerFunction := ChooseRecipe
                ButtonSize := vector2{X:=55.0, Y:=55.0}

            PossibleRecipesWrapBox.AddWidget(TextureButton)
            PossibleRecipesItemWrapperWrapBox.AddWidget(
                texture_wrapper {Texture := DefaultImage:=Assets.UI.CraftingTable.T_ItemWrapper}
            )

            set TextureButtonId += 1
        
        

        PossibleRecipesWrapBox.LoadItemsOntoCanvas(Canvas)
        PossibleRecipesItemWrapperWrapBox.LoadItemsOntoCanvas(Canvas)



    Open(Agent : agent) : void = 
        
        if(Player := player[Agent]):
            if(CurrentlyCooking = false):
                ClearCurrentRecipe()
                RefreshRecipes(Player)
                CookedItemTextureWrapper.Hide()
                InputItemTextureWrapper.Hide()

            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := 0.0, Top := 0.0 , Right := 1920.0, Bottom := 1080.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 2
                    Widget := CrafingBackgroundUi
            )

            Canvas.AddWidget(
                canvas_slot:
                    Anchors := Anchor
                    Offsets := margin{Left := 394.0, Top := 55.0, Right := 222.0, Bottom := 45.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := false
                    ZOrder := 3
                    Widget := CookBtn
            )

            Canvas.AddWidget(
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 0.0, Top := 464.0, Right := 171.0, Bottom  := 81.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 2147483640
                    Widget := CloseBtn
            )
            
            Canvas.AddWidget(
                canvas_slot: 
                    Anchors := Anchor
                    Offsets := margin{Left := 390.0, Top := -160.0, Right := 0.0, Bottom  := 0.0}
                    Alignment := vector2{X:=0.5, Y:=0.5}
                    SizeToContent := true
                    ZOrder := 2147483640
                    Widget := CookedItemName
            )

            if (PlayerUI := GetPlayerUI[Player]):
                PlayerUI.AddWidget(Canvas, player_ui_slot{ InputMode := ui_input_mode.All, ZOrder := 200 })
            else:
                PrintError("Could not retrieve Player UI")


    Close(WidgetMessage : widget_message) : void = 
        if (PlayerUI := GetPlayerUI[WidgetMessage.Player]):
            PlayerUI.RemoveWidget(Canvas)
        else:
            PrintError("Could not retrieve Player UI")
--- </ui_manager_device.verse> ---

--- <villager_manger_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }

villager_recipe_wrapper := class<unique>():
    @editable NeededItemType : item_type = item_type.None
    @editable NeededItemAmount : int = 1

    @editable BoughtItemType : item_type = item_type.None
    @editable BoughtItemAmount : int = 1


villager_manager_wrapper := class():
    RefVillagerManager : villager_manager_device
    RefPlayer : player

    var MaybeCraftingBenchInterface : ?villager_interface = false

    Initialize()<suspends> : void =
        set MaybeCraftingBenchInterface = option{
            villager_interface:
                RefItemManager := RefVillagerManager.ItemManager
                BuyItemFunction:=RefVillagerManager.BuyItem
                GetRecipesFunction:=RefVillagerManager.GetCraftableRecipes
                CanAffordRecipe:=RefVillagerManager.CanAffordRecipe
        }
        
        if(CraftingBenchInterface := MaybeCraftingBenchInterface?):
            CraftingBenchInterface.Initialize()
        
    Open() : void =
        if(CraftingBenchInterface := MaybeCraftingBenchInterface?):
            CraftingBenchInterface.Open(RefPlayer)

villager_manager_device := class(creative_device):
    @editable GameManager : game_manager_device = game_manager_device{}
    @editable ItemManager : item_manager_device = item_manager_device{}


    @editable Recipes : []villager_recipe_wrapper = array{}
    @editable VillagerButton : button_device = button_device{}
    BoughtItemEvent : event(increase_event_data) = event(increase_event_data){}

    BuyItem(Player : player, Recipe : villager_recipe_wrapper) : void =
        if(CustomPlayer := GameManager.GetCustomPlayer[Player]):
            if:
                NeededItemAmount := Recipe.NeededItemAmount
                NeededItemType := Recipe.NeededItemType
                CustomPlayer.GetItemAmount(NeededItemType) > Recipe.NeededItemAmount
                BoughtItemAmount := Recipe.BoughtItemAmount
                BoughtItemType := Recipe.BoughtItemType
                ItemName := ItemManager.GetItemName(BoughtItemType)
            then:
                CustomPlayer.ConsumeItem(NeededItemType, Recipe.NeededItemAmount)
                ItemManager.GrantItem(Player, Recipe.BoughtItemType, ?Amount:=Recipe.BoughtItemAmount)
                BoughtItemEvent.Signal(increase_event_data{Agent:=Player, Value:=ItemName, Type:=quest_type.Buy, Amount:=Recipe.BoughtItemAmount})    
            else:
                Print("Needed Amount: {Recipe.NeededItemAmount} | Amount: {CustomPlayer.GetItemAmount(Recipe.NeededItemType)}")
                return


    GetCraftableRecipes(Player : player) : []villager_recipe_wrapper =
        return Recipes
    
    OpenShop(Agent : agent) : void =
        if(CustomPlayer:=GameManager.GetCustomPlayer[Agent]):
            CustomPlayer.OpenShop()

    OnBegin<override>()<suspends> : void =
        VillagerButton.InteractedWithEvent.Subscribe(OpenShop)
    
    CanAffordRecipe(Player : player, Recipe : villager_recipe_wrapper)<transacts> : logic = 
        if(CustomPlayer := GameManager.GetCustomPlayer[Player]):
            if:
                NeededItemAmount := Recipe.NeededItemAmount
                NeededItemType := Recipe.NeededItemType
                CustomPlayer.GetItemAmount(NeededItemType) > Recipe.NeededItemAmount
            then:
                return true
        
        return false--- </villager_manger_device.verse> ---

--- <wither_skeleton_behavior.verse> ---
using { /Fortnite.com/AI }
using { /Verse.org/Simulation }
using { /Fortnite.com/Characters }
using { /Fortnite.com/Animation/PlayAnimation }
using { /Verse.org/Assets }
using { /Verse.org/SpatialMath }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /Fortnite.com/Devices }

wither_skeleton_behavior := class(npc_behavior):

    var EntityBaseBehaviorInstance : entity_base_behaviour = entity_base_behaviour{}
    ATTACK_RANGE : float = 50.0
    var AttackAnim : animation_sequence = Assets.Models.WitherSkeleton.animation_mskeleton_attack
    var DeathAnim : animation_sequence = Assets.Models.WitherSkeleton.animation_mskeleton_knocked_out

    OnBegin<override>()<suspends>:void=
        # return
        # entity_base_class_tag
        TaggedObjects := FindObjectsWithTag(entity_base_class_tag{})
        
        if(TaggedEntityBehaviorBaseInstance := entity_base_behaviour[TaggedObjects[0]]):
            set EntityBaseBehaviorInstance = TaggedEntityBehaviorBaseInstance
        else:
            PrintError("Entity Base Class could not be fetched.")
            # Assert("Entity Base Class could not be fetched.")

        if:
            NPCAgent := GetAgent[]
            NPCChar := NPCAgent.GetFortCharacter[]

            NPCNav := NPCChar.GetNavigatable[]
            NPCFocus := NPCChar.GetFocusInterface[]
            NPCAnim := NPCChar.GetPlayAnimationController[]
        
        then:

            NPCSpawnPoint := NPCChar.GetTransform().Translation
            
            loop:

                if(not NPCChar.IsActive[]):
                    break

                Sleep(0.1)
                if(NewTarget := EntityBaseBehaviorInstance.FindNearestTarget[NPCChar], NewAgent := NewTarget.GetAgent[]):
                    spawn . NPCFocus.MaintainFocus(NewAgent)
                    NavTarget := MakeNavigationTarget(NewAgent)
                    spawn . NPCNav.NavigateTo(NavTarget, ?MovementType := movement_types.Walking, ?ReachRadius := ATTACK_RANGE)  
                    if(Distance(NPCChar.GetTransform().Translation, NewTarget.GetTransform().Translation) <= 130.0):
                        NPCAnim.Play(AttackAnim)
                        Sleep(0.25)
                        EntityBaseBehaviorInstance.Attack(NewAgent, NPCChar, 20.0)
                        Sleep(0.5)
                --- </wither_skeleton_behavior.verse> ---

--- <world_manager_device.verse> ---

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Simulation/Tags }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }

regenerative_structure_part_wrapper := class():
    GridPosition : vector3i = vector3i{}
    GetGridPosition<public>()<transacts> : vector3i = GridPosition
    var MaybeDestroyedTime<private> : ?float = false
    GetMaybeDestroyedTime<public>()<transacts> : ?float = MaybeDestroyedTime
    SetDestroyedTime(Time: float) : void = set MaybeDestroyedTime = option{Time}
    ClearDestroyedTime() : void = set MaybeDestroyedTime = false

regenerative_block_wrapper := class(): 
    GridPosition : vector3i
    BlockType : block_type
    var DestroyedTime : ?float
    RegenerativeTime : float 

regenerative_structure_wrapper := class<concrete>():
    @editable StructureName<public> : string = ""
    @editable RegenerativeTime<public> : float = 15.0
    
    @editable BlockType<public> : block_type = block_type.None
    @editable BlockPositions<public> : []creative_prop = array{}
    var Parts<public> : []regenerative_structure_part_wrapper = array{}


    var RefBlockManager<private> : ?block_manager_device = false

    SetBlockManager<internal>(InBlockManager : block_manager_device) : void =
        set RefBlockManager = option{InBlockManager}

    Initialize<public>(InBlockManager : block_manager_device) : void =
        set RefBlockManager = option. InBlockManager
        if (BlockManager := RefBlockManager?):
            for:
                BlockPosition : BlockPositions
                Transform := BlockPosition.GetTransform()
                GridPosition := W2G(Transform.Translation)
            do:
                RegenerativePart := regenerative_structure_part_wrapper:
                    GridPosition := GridPosition 
                set Parts += array. RegenerativePart
            spawn. StartRegenerationCheck()

    StartRegenerationCheck<public>()<suspends> : void =
        if (BlockManager := RefBlockManager?):
            loop:
                Sleep(0.1)
                for:
                    Part : Parts
                do:
                    CurrentTime := GetSecondsSinceEpoch()
                    # if:
                    #     DestroyedTime := Part.GetMaybeDestroyedTime()?
                    # then:
                    #     Print("DestroyedTime: {DestroyedTime - CurrentTime}")

                    if:
                        GridPosition := Part.GetGridPosition()
                        not BlockManager.GetBlock(GridPosition)?
                    then:
                        if:
                            DestroyedTime := Part.GetMaybeDestroyedTime()?
                            CurrentTime - DestroyedTime >= RegenerativeTime
                        then:
                            BlockManager.SpawnBlock(BlockType, GridPosition, IdentityRotation())
                            Part.ClearDestroyedTime()
                        else if:
                            not Part.GetMaybeDestroyedTime()?
                        then:
                            Part.SetDestroyedTime(GetSecondsSinceEpoch())
                    else:
                        Part.ClearDestroyedTime()


prebuilt_structure_part_wrapper := class():
    @editable BlockType : block_type = block_type.None
    @editable BlockPositions : []creative_prop = array{}

prebuilt_structure_wrapper := class():
    @editable Parts : []prebuilt_structure_part_wrapper = array{} 
    Build(BlockManager : block_manager_device) : void = for (Part : Parts). BlockManager.BuildPrebuildBlocks(Part.BlockType, Part.BlockPositions)


starter_crafting_table_prebuild_tag := class(tag){}

crafting_table_prebuild_tag := class(tag){}


grass_block_prebuild_tag := class(tag){}
dirt_prebuild_tag := class(tag){}
oak_log_prebuild_tag := class(tag){}
oak_leaves_prebuild_tag := class(tag){}
hayball_prebuild_tag := class(tag){}

spruce_sapling_prebuild_tag := class(tag){}

farmland_prebuild_tag := class(tag){}
oak_planks_prebuild_tag := class(tag){}

cobblestone_prebuild_tag := class(tag){}
stone_prebuild_tag := class(tag){}
diorite_prebuild_tag := class(tag){}
gray_concrete_prebuild_tag := class(tag){}
iron_ore_prebuild_tag := class(tag){}
iron_block_prebuild_tag := class(tag){}

white_wool_prebuild_tag := class(tag){}

regenerating_iron_ore_prebuild_tag := class(tag){}
regenerating_iron_block_prebuild_tag := class(tag){}
regenerating_diamond_block_prebuild_tag := class(tag){}

diamond_block_prebuild_tag := class(tag){}

cobblestone_generator_prebuild_tag := class(tag){}

sand_prebuild_tag := class(tag){}
sandstone_prebuild_tag := class(tag){}

lucky_block_grappler_prebuild_tag := class(tag){}
lucky_block_normal_prebuild_tag := class(tag){}

obsidian_prebuild_tag := class(tag){}


world_manager_device := class(creative_device):
    @editable BlockManager : block_manager_device = block_manager_device{}

    @editable RegenerativeStructures : []regenerative_structure_wrapper = array{}

    OnBegin<override>()<suspends>:void=
        if (not BlockManager.IsInitialized?):
            BlockManager.InitializedEvent.Await()

            
        BlockManager.CheckReference()

        for (RegenerativeStructure : RegenerativeStructures):
            RegenerativeStructure.Initialize(BlockManager)

        Delay := 0.25

        FindAndBuildTaggedBlocks(block_type.GrassBlock, grass_block_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.Dirt, dirt_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.OakLog, oak_log_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.OakLeaves, oak_leaves_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.Cobblestone, cobblestone_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.Stone, stone_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.Diorite, diorite_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.GrayConcrete, gray_concrete_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.IronOre, iron_ore_prebuild_tag{})

        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.Farmland, farmland_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.OakPlanks, oak_planks_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.CobblestoneGenerator, cobblestone_generator_prebuild_tag{})
        
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.CraftingTable, starter_crafting_table_prebuild_tag{}, ?Indestructable := true)
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.CraftingTable, crafting_table_prebuild_tag{})
        
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.IronOre, regenerating_iron_ore_prebuild_tag{}, ?RespawnTime := option. 60.0)

        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.SpruceSapling, spruce_sapling_prebuild_tag{})

        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.Hayball, hayball_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.IronBlock, iron_block_prebuild_tag{})
        
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.WhiteWool, white_wool_prebuild_tag{})

        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.DiamondBlock, diamond_block_prebuild_tag{})

        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.Sand, sand_prebuild_tag{})
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.Sandstone, sandstone_prebuild_tag{})

        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.LuckyblockGrappler, lucky_block_grappler_prebuild_tag{}, ?RespawnTime := option. 60.0)
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.LuckyblockNormal, lucky_block_normal_prebuild_tag{}, ?RespawnTime := option. 120.0)

        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.IronBlock, regenerating_iron_block_prebuild_tag{},  ?RespawnTime := option. 120.0)
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.DiamondBlock, regenerating_diamond_block_prebuild_tag{},  ?RespawnTime := option. 215.0)

        
        Sleep(Delay)
        FindAndBuildTaggedBlocks(block_type.Obsidian, obsidian_prebuild_tag{})


        

    FindAndBuildTaggedBlocks(BlockTypeToBuild : block_type, TagToFind : tag, ?RespawnTime : ?float = false, ?Indestructable : logic = false) : void =
        if (RespawnTime? and Indestructable?):
            Assert("World Manager cannot spawn Block which is both Respawnable and Indestructable")

        var FoundProps : []creative_prop = array{}
        for (CreativeObject : Self.FindCreativeObjectsWithTag(TagToFind)):
            if (Prop := creative_prop[CreativeObject]):
                set FoundProps += array{Prop}

        # Print("Found {FoundProps.Length} props with the tag.")
        if (FoundProps.Length > 0):
            BlockManager.BuildPrebuildBlocks(BlockTypeToBuild, FoundProps, ?RespawnTime := RespawnTime, ?Indestructable := Indestructable)
        else:
            block{}


            # Print("No props found with the specified tag. Nothing to build.")
--- </world_manager_device.verse> ---
</MINECRAFT RECREATION PROJECT EXAMPLE>